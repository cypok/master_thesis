\documentclass[14pt,titlepage,draft]{extarticle}
% use final option instead of draft to get "release" version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PACKAGES
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{ucs}
\usepackage[utf8x]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{indentfirst}

\usepackage{geometry}

\usepackage[usenames,dvipsnames]{color}

\usepackage{ifdraft}

\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{mathtools} % some extensions over amsmath

% should be loaded after hyperref & ams*
\usepackage[norefs,nocites,msgs]{refcheck}

\usepackage{xspace} % for \xspace
\usepackage{pbox}

\usepackage{footmisc}
\renewcommand{\footnotelayout}{\small}

% prevent underfull boxes in bibliography
\usepackage{etoolbox}
\apptocmd{\sloppy}{\hbadness 10000\relax}{}{}

\usepackage[obeyDraft, textwidth=3cm, textsize=footnotesize,
  backgroundcolor=orange!50, linecolor=black!50]{todonotes}

\usepackage{float}

% should be loaded after float and before algorithm
% to correctly link algorithms
\usepackage[pdftex,unicode,hidelinks,final]{hyperref}

\usepackage{algpseudocode}
\algrenewcommand{\algorithmiccomment}[1]{\hfill \textit{#1}}

\newfloat{sample}{htbp}{loa}
\floatname{sample}{Пример}

\newfloat{algorithm}{tbp}{loa}
\floatname{algorithm}{Алгоритм}

\usepackage{multicol}

% should be loaded after hyperref & ams*
\usepackage[norefs,nocites,msgs]{refcheck}

\usepackage[raggedright]{titlesec}
% this is done because titlesec somehow defines \chapter
% which must not be defined in article
% (this crashes some packages, e.g. \listoftodos from todonotes)
\let\chapter\undefined

\usepackage{array}
% Issue \raggedright to achieve the desired horizontal alignment,
% Declare \let\newline\\ to allow to use \newline for manual line breaks within
%   a cell (note that \centering & friends change the meaning of \\ -- this is
%   the problem with Jake's solution),
% Issue \arraybackslash (i.e., \let\\\tabularnewline) to allow (again) to use
%   \\ for ending rows,
% Issue \hspace{0pt} to allow the first word in a cell to be hyphenated.
\newcolumntype{L}[1]{>{\raggedright\let\newline\\\arraybackslash\hspace{0pt}}p{#1}}

\usepackage{../../common/cypokcommon}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% DOCUMENT-SPECIFIC COMMANDS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\input{../../common/gitinfo}
\newcommand{\GitCommitsURL}{http://github.com/cypok/master_thesis/commit/}

\newcommand{\java}{\eng{Java}\xspace}

\newcommand{\M}{\ensuremath{\mathbb{M}}}
\newcommand{\Ms}{\ensuremath{\mathbb{\widebar{M}}}}
\newcommand{\Mf}[1]{\ensuremath{\mathrm{#1}}}

\let\mathphi\phi
\renewcommand{\phi}{\ensuremath{\mathphi}}

\newcommand{\type}[1]{\mathrm{#1}}
\newcommand{\field}[1]{\mathrm{#1}}

\newcommand{\op}[1]{\mathbf{#1}}

\newcommand{\pts}[1]{\widebar{#1}}

\newcommand{\AOTyped}[1]{O^{\type{#1}}}
\newcommand{\AO}{O}
\newcommand{\AOGlobal}{\AO_{global}}

\newcommand{\TClosure}{\mathcal{TC}}

\newcommand{\Lattice}{\mathcal{L}}
\newcommand{\meet}{\wedge}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% TEXT FORMAT
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\geometry{a4paper,top=2cm,bottom=2cm,bindingoffset=0cm}
\ifdraft{
  % <leftmargin> | <marginpar> | <sep> | <text> | <rightmargin>
  %    0.5cm     |     3cm     | 0.5cm |  16cm  |     1cm
  \geometry{reversemp=true,includemp=true,
            marginparwidth=3cm,marginparsep=0.5cm,
            left=0.5cm,textwidth=16cm}
}{
  % <leftmargin> | <text> | <rightmargin>
  %     3cm      |  16cm  |     2cm
  \geometry{left=3cm,textwidth=16cm}
}
\linespread{1.3}

%\setcounter{tocdepth}{2} % contents depth

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% BODY
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand\thetitle{
  Применение анализа указателей и синонимов
  для оптимизации многопоточных программ
}
\newcommand\theauthor{
  Владимир Парфиненко
}

\title{\thetitle}
\author{\theauthor}

\hypersetup{
  pdfinfo={
    Title = {\thetitle},
    Author = {\theauthor},
    Subject = {}
  }
}

\begin{document}

  \thispagestyle{empty}
  \begin{center}
    \ifdraft{
      \
      \vspace{3cm}

      {\Large \scshape Черновик \par}

      \vspace{2cm}

      Магистерская диссертация

      \vspace{0.2cm}

      {\large Парфиненко Владимир Владимирович \par}

      \vspace{1.5cm}

      {\large \scshape \bfseries
        Применение анализа указателей и синонимов\\
        для оптимизации многопоточных программ \par
      }

      \vfill

      Git info

      \begin{table}[!h]
        \centering
        \begin{tabular}{r L{0.5\textwidth}}
          sha1: & \href{\GitCommitsURL\GitAbbrHash}{\texttt{\GitAbbrHash}} \\
          title:& \GitSubject \\
          date: & \GitDate
        \end{tabular}
      \end{table}
    }{
      Министерство образования и науки Российской Федерации

      \vspace{0.7cm}

      Федеральное государственное бюджетное образовательное учреждение\\
      высшего профессионального образования\\
      <<Новосибирский национальный исследовательский\\
      государственный университет>> (НГУ)

      \vspace{0.7cm}

      Механико"=математический факультет

      \vspace{0.2cm}

      Кафедра программирования

      \vspace{1.2cm}

      Магистерская диссертация

      \vspace{0.5cm}

      {\large Парфиненко Владимир Владимирович \par}

      \vspace{1.1cm}

      {\large \scshape \bfseries
        Применение анализа указателей и синонимов\\
        для оптимизации многопоточных программ \par
      }

      \vspace{2.5cm}


      \hfill\pbox{\textwidth}{
        Научные руководители:\\
        м.\,н.\,с.~ИСИ~СО~РАН, Павлов~П.\,Е.,\\
        зав.\,лаб.~ИСИ~СО~РАН, к.\,т.\,н.~Шелехов~В.\,И.
      }

      \vfill

      Новосибирск 2013
    }
  \end{center}

  \clearpage
  \listoftodos

  \tableofcontents

  \sectionwithoutnumber{Введение}

    Статический анализ программ активно применяется в оптимизирующих
    компиляторах. Одним из видов статического анализа является анализ
    указателей и синонимов. Результаты такого анализа могут быть использованы
    для усиления других видов анализа, проводимых оптимизирующим компилятором,
    и, как следствие, для повышения качества оптимизирующих преобразований.
    Таким образом может быть усилен достаточно обширный класс анализов и
    оптимизаций, как классических (удаление общих
    подвыражений, чистка циклов, протяжка констант и присваиваний, удаление
    проверок времени исполнения и др.), так и объектно"=ориентированных
    (девиртуализация, удаление избыточной синхронизации, \eng{escape}"=анализ,
    аллокация объектов на стеке, открытая подстановка объектов и др.).

    Для программ, исполняемых в управляемых средах \engdef{managed
    environments}, таких, как JVM\footnote{\eng{JVM, Java Virtual Machine}~---
    виртуальная машина \java, основная часть исполняющей системы \java.} или
    CLR\footnote{\eng{CLR, Common Language Runtime}~--- виртуальная машина,
    интерпретирующая и исполняющая код на языке CIL, в который компилируются
    программы, написанные, в частности, на .NET"=совместимых языках
    программирования.}, значение анализа указателей и синонимов для
    качественной оптимизации кода существенно возрастает. Это связано с двумя
    основными причинами. Во-первых, в управляемых средах затруднен или вообще
    отсутствует доступ программиста к низкоуровневым, небезопасным средствам
    (например, адресной арифметике и ручному управлению памятью), что
    осложняет ручную оптимизацию и вынуждает оптимизирующий компилятор
    (виртуальную машину) проводить более глубокий анализ и более агрессивные
    оптимизации программы для достижения приемлемого уровня производительности.

    Во-вторых, любая программа в управляемой среде является многопоточной, а
    сама среда обеспечивает поддержку средств многопоточного программирования,
    таких, как потоки исполнения \engdef{threads}, атомарные операции,
    примитивы синхронизации. Более того, семантика любого участка кода
    программы (например, отдельной процедуры) не может считаться
    независимой от многопоточной среды~--- семантика всех взаимодействий кода с
    разделяемой памятью задается так называемой моделью памяти данного
    языка\slash{}среды, которая описывает влияние различных потоков исполнения друг на
    друга через разделяемую память и тем самым определяет корректность тех или
    иных преобразований программы~\cite{manson_jmm}. На практике это означает,
    что не любые оптимизирующие преобразования однопоточной программы будут
    являться корректными, если рассматривать ту же программу в многопоточной
    среде. Корректное и при этом не чрезмерно препятствующее оптимизациям
    определение зависимостей и связей в программе возможно только при
    проведении нетривиального анализа указателей и синонимов.

    Данная работа посвящена разработке алгоритма анализа указателей и синонимов
    для языка \java, учитывающего вышеприведенные соображения.

  \section{Постановка задачи}

    Целью данной работы является разработка алгоритма анализа указателей и
    синонимов для языка \java, учитывающего особенности языка и его модели
    памяти.

    Для достижения поставленной цели необходимо провести сравнительный анализ
    существующих алгоритмов, обосновать их сравнительную пригодность (включая
    результативность и производительность) для использования в оптимизирующем
    компиляторе. Используя эти данные, нужно разработать новый алгоритм анализа
    указателей, учитывающий особенности управляемых языков программирования.

    Разработанный алгоритм требуется реализовать на базе системы \eng{Excelsior
    Research Virtual Machine}, включающей статический компилятор и среду
    исполнения для платформы \eng{Java~SE}. В качестве пользователя анализа
    также требуется реализовать некоторую оптимизацию и провести замеры ее
    эффективности.

  \section{Существующие алгоритмы анализа указателей}

    \emph{Анализ указателей}~--- это один из видов статического анализа,
    который определяет, на какие объекты в памяти могут указывать выражения
    ссылочного типа в программе (такие объекты называются целями выражения
    ссылочного типа). \emph{Анализ синонимов} похож на анализ указателей: его
    целью является определение, могут ли два выражения быть синонимами, то есть
    ссылаться на одно и то же место в памяти~\cite{andersen}.

    Существует множество алгоритмов анализа указателей для разных языков
    программирования~\cite{hind_pointer_analysis_not_solved_yet}. Различаются
    они по точности получаемых результатов и временной\slash{}емкостной
    сложности.

    В настоящее время базовыми являются два алгоритма, которые отличаются
    представлением информации о целях указателей. И именно на двух этих
    алгоритмах основываются многие другие.
    Первый~--- это алгоритм Стинсгарда, который имеет
    практически линейную временную сложность\footnote{
      Временная сложность алгоритма Стинсгарда
      $O(N \alpha(N))$, где $N$~--- размер анализируемой программы,
      $\alpha$~--- обратная функция Аккермана. Она является очень медленно
      растущей, и при анализе асимптотики алгоритмов можно принять ее за
      константу.
    }~\cite{steensgaard}. Однако этот алгоритм предоставляет существенно менее
    точные результаты по сравнению со вторым алгоритмом, алгоритмом
    Андерсена. Хотя этот алгоритм и потребляет время, в худшем случае
    пропорциональное кубу от размера программы~\cite{andersen}, на практике оба
    алгоритма имеют сравнимую скорость работы при анализе небольших программ
    (до \num{3000} строк)~\cite{shapiro_fast_and_accurate}.

    Разработанный в данной работе алгоритм анализа основывается на идеях
    алгоритма Андерсена, так как точность алгоритма Стинсгарда не является
    достаточной для статического компилятора управляемого языка
    программирования.

    Для сравнения точности алгоритмов анализа указателей необходимо ввести
    некую меру точности. В качестве простой меры точности алгоритма часто
    используется усредненное количество синонимов для всех переменных
    ссылочного типа, появляющихся в
    программе~\cite[раздел~3.2]{hind_pointer_analysis_not_solved_yet}
    (также существуют и более изощренные
    меры~\cite{hind_pointer_analysis_not_solved_yet,diwan_tbaa}).
    Понятно, что для <<идеального>> алгоритма анализа это число будет
    минимальным, а для самого консервативного алгоритма~--- максимальным.

  \subsection{Чувствительные к потоку управления алгоритмы}
    \label{section:choosing_flow_insensitive}

    Важной характеристикой алгоритмов анализа указателей является
    чувствительность к потоку управления в программе
    \engdef{flow"=sensitivity}.

    Алгоритм анализа, \emph{чувствительный к потоку управления}, работает с
    графом потока управления программы, и результирующая информация о целях
    выражений приписывается каждой отдельной операции. За счет этого анализ
    учитывает только те последовательности исполнения операций, которые
    действительно реализуемы.

    \emph{Нечувствительный к потоку управления} алгоритм анализа рассматривает
    программу как неупорядоченный набор операций. Такой алгоритм
    консервативно полагает, что операции могут идти в произвольном порядке и
    повторяться произвольное количество раз.

    Алгоритм анализа, чувствительный к потоку управления, дает более точные
    результаты, при этом потребляя значительно больше ресурсов, таких как
    память и время~\cite[раздел.~4.4]{hind_pointer_analysis_not_solved_yet}.
    Такое потребление ресурсов является достаточным для отказа от
    использования на практике подобных алгоритмов анализа в статическом
    компиляторе.

    Поэтому алгоритм, разработанный в рамках этой работы, является
    нечувствительным к потоку управления. Однако ухудшение точности при таком
    выборе может быть также неприемлемым.
    Для решения этой проблемы и получения сравнимой точности необходимо было
    существенно модифицировать внутреннее представление программы, с которым
    будет работать алгоритм анализа указателей. Эти изменения описаны в
    разделе~\ref{section:increase_accuracy}.

  \subsection{Межпроцедурные алгоритмы}

    Не менее важной чертой алгоритмов анализа является то, как они
    обрабатывают вызовы подпрограмм.

    \emph{Внутрипроцедурные алгоритмы} при анализе отдельной процедуры не
    выходят за ее пределы и все вызовы обрабатывают консервативно: полагается,
    что может исполняться абсолютно произвольный набор операций, модифицирующий
    поля всех разделяемых объектов.

    \emph{Межпроцедурный алгоритм} анализа при обработке вызова может
    предварительно провести анализ вызываемой подпрограммы и как-либо учесть
    эту информацию.

    Понятно, что межпроцедурный алгоритм дает более точные результаты,
    а внутрипроцедурный потребляет существенно меньше времени и
    памяти~\cite[с.~117]{andersen}.

    Также нужно заметить, что при рассмотрении управляемых языков
    программирования, где большинство вызовов является виртуальными,
    межпроцедурный алгоритм анализа дополнительно усложняется. Поэтому в
    данной работе будет описан внутрипроцедурный алгоритм, хотя и реализация
    межпроцедурной его версии не исключается в будущих работах.

  \section{Особенности языка \texorpdfstring{\java}{Java}}

    В этом разделе описаны ключевые особенности языка \java, которые необходимо
    учесть при разработке алгоритма анализа указателей и оптимизации удаления
    чтений полей объектов.

  \subsection{Система типов}
    \label{section:type_system}

    Опишем строгую систему типов языка \java.
    Все типы делятся на ссылочные и примитивные (скалярные).
    Примитивные типы можно не рассматривать в контексте анализа указателей,
    так как они не могут переносить информацию о целях указателей.
    Ссылочные типы~--- это классы, интерфейсы и массивы.
    Для любого выражения ссылочного типа можно определить его формальный тип:
    источниками формальных типов являются типы параметров метода, типы
    возвращаемых значений и типы полей.

    На множестве ссылочных типов можно определить отношение частичного
    порядка: $A \leq B$ ($B$ совместим по присваиванию с $A$) тогда и только
    тогда, когда значение типа $B$ можно присвоить
    в переменную типа $A$~\cite{nastia_type_analysis}.
    Также можно ввести отношение совместимости двух типов, истинное тогда и
    только тогда, когда существует тип, совместимый по присваиванию с ними
    обоими:
    \[
      A \text{ и } B \text{ совместимы }
      \Leftrightarrow
      \exists C\colon A \leq C \land B \leq C.
    \]

    Согласно спецификации языка \java, во время исполнения программы
    выражение ссылочного типа может указывать только на те объекты, тип
    которых совместим по присваиванию с формальным типом этого выражения.
    Из этого получаем, что два выражения, имеющие несовместимые типы, не
    могут указывать на один и тот же объект и быть синонимами.

  \subsection{Модель памяти}

    Модель памяти для многопоточной системы определяет в каком
    порядке могут происходить доступы к памяти в программе и, как следствие,
    какие значения может возвращать конкретное чтение памяти. В данном разделе
    описана модель памяти языка \java.

    Модели памяти различаются по тому, насколько сильные ограничения
    накладываются на последовательность исполнения операций чтения и записи.
    Модель памяти может быть очень строгой и требовать последовательного
    исполнения всех операций чтения и записи~\cite{lamport}.
    Такая модель сильно ограничивает набор используемых оптимизаций, так как
    многим из них требуется менять отдельные операции чтения и записи местами,
    а строгая модель памяти не позволяет это сделать, даже если между
    операциями нет зависимости по управлению и данным.
    Слабая модель памяти может не определять какого-либо жесткого порядка
    исполнения операций. Основываясь на этой модели, компилятор может довольно
    сильно преобразовывать программу с целью ее оптимизации, однако
    разработчику придется потратить много ресурсов для написания корректной
    программы в рамках такой слабой модели памяти.

    Модель памяти, представленная в спецификации языка \java версии~5.0
    является компромиссом между возможностью проведения широкого класса
    оптимизаций и удобством разработки программ на языке \java. Подробное
    описание можно найти в спецификации JSR-133~\cite{jsr133}. Модель памяти
    является достаточно строгой и однозначно определяет, как будут исполняться
    корректно синхронизированные программы (программы, в которых отсутствуют
    конфликты доступа\footnote{
      Конфликт доступа \engdef{data-race} образуют две операции доступа к
      разделяемой памяти из разных потоков, если эти операции не упорядочены в
      рамках модели памяти и хотя бы одна из них~--- запись (подробнее
      см.~\cite[раздел~2.1]{manson_jmm}).
    } \engdef{data-race free}). Однако она является и достаточно слабой,
    позволяя проводить многие оптимизации.

  \section{Алгоритм анализа указателей}

    В этом разделе описан разработанный алгоритм анализа указателей. Он является
    внутрипроцедурным и нечувствительным к потоку управления. Основой алгоритма
    является проведение анализа потока данных на графе зависимостей по данным.
    \todo{Порядок подразделов возможно нужно переделать}

  \subsection{Внутреннее представление}
    \label{section:ir_ops}

    Сначала необходимо описать внутреннее представление, с которым работает
    алгоритм. Программа представляется неупорядоченным набором операций в
    SSA-форме\footnote{
      Будем говорить, что программа находится в SSA-форме (\eng{Static Single
      Assignment}), если каждой из переменных значение присваивается лишь
      единожды~\cite{ssa}.
      Любую программу можно перевести в SSA-форму посредством
      версионирования переменных и расстановки \phi-функций~\cite{ssa}.
      Для перевода в SSA-форму и вывода из нее существуют эффективные
      алгоритмы~\cite{bilardi_ssa, briggs_ssa}.
    }, которые в общем случае имеют вид:
    \[ var \gets \op{operation}[id_1, \ldots, id_M](arg_1, \ldots, arg_N), \]
    где
    $N \geq 0$~--- количество аргументов операции,
    $arg_i$~--- $i$-ый аргумент операции (переменная),
    $M \geq 0$~--- количество константных параметров операции,
    $id_i$~--- $i$-ый параметр (идентификатор типа или поля),
    $var$~--- результат операции (переменная, может отсутствовать).

    В таблице~\ref{tabular:basic_operations} приведен список базовых операций
    языка \java и их внутреннее представление для алгоритма анализа.
    Представление некоторых других операций будет дано в этом и последующих
    разделах, а семантика всех операций будет подробно описана в
    разделе~\ref{section:flow_functions}.

    \begin{table}[htb]
      \centering

      \begin{tabular}{|p{0.6\textwidth}|p{0.3\textwidth}|}\hline
        \textbf{\java операция} &
          \textbf{Внутреннее представление}\\ \hline

        Получение формального параметра ссылочного типа или
        чтение статического поля
        & $a \gets \op{shared}$
        \\ \hline

        Получение нулевого указателя
        & $a \gets \op{null}$
        \\ \hline

        \phi-функция ссылочного типа
        & $a \gets \op{phi}(b_1, \ldots, b_N)$
        \\ \hline

        Создание нового объекта типа $\type{T}$
        & $a \gets \op{new}[\type{T}]$
        \\ \hline

        Чтение поля ссылочного типа $\field{f}$ объекта $a$
        & $a \gets \op{getfield}[\field{f}](a)$
        \\ \hline

        Запись в поле $\field{f}$ объекта $a$ значения ссылочного типа $b$
        & $\op{putfield}[\field{f}](a, b)$
        \\ \hline

        Запись в статическое поле значения ссылочного типа $a$
        & $\op{escape}(a)$
        \\ \hline

      \end{tabular}
      \caption{Базовые операции языка \java и их внутреннее представление}
      \label{tabular:basic_operations}
    \end{table}

    Заметим, что операция присваивания значения одной переменной другой
    отсутствует.
    Это связано с тем, что для программы в SSA-форме все копии переменных
    тривиальным образом могут быть удалены~\cite{ssa}.

    Вызов метода с параметрами ссылочного типа $p_1, \ldots, p_N$, возвращающего
    значение ссылочного типа $a$ (параметры и возвращаемое значение могут
    отсутствовать), интерпретируется как набор операций:
    \begin{gather*}
      \op{escape}(p_1), \\
      \ldots, \\
      \op{escape}(p_N), \\
      a \gets \op{shared}.
    \end{gather*}

    Чтение и запись $i$-го элемента массива консервативно преобразуется в
    работу с синтетическим полем $\field{elements}$, которое добавляется всем
    типам"=массивам.

  \subsection{Использование информации о типах}
    \label{section:op_types}

    Учет строгой системы типов языка \java важен для проведения точного анализа
    указателей.

    Определим для каждой операции внутреннего представления, порождающей
    значение ссылочного типа, ее формальный тип
    (см.~таблицу~\ref{tabular:ops_types}).

    \begin{table}[htb]
      \centering

      \begin{tabular}{|p{0.3\textwidth}|p{0.6\textwidth}|}\hline
        \textbf{Операция} &
          \textbf{Формальный тип}\\ \hline

        $a \gets \op{null}$
        & $\type{NullType}$~--- искусственный тип, совместимый по
          присваиванию с любым ссылочным типом, что соответствует
          семантике операции
        \\ \hline

        $a \gets \op{phi}(b_1, \ldots, b_N)$
        & Наибольшая нижняя грань множества типов $\{b_1, \ldots, b_N\}$
        \\ \hline

        $a \gets \op{new}[\type{T}]$
        & $\type{T}$
        \\ \hline

        $a \gets \op{getfield}[\field{f}](a)$
        & Тип поля $\field{f}$
        \\ \hline

        $a \gets \op{cast}[\type{T}](b)$
        & $\type{T}$
        \\ \hline

      \end{tabular}
      \caption{Формальные типы операций внутреннего представления}
      \label{tabular:ops_types}
    \end{table}

    Для операции $\op{shared}$ формальный тип также может быть определен из
    свойств соответствующей ему \java операции.
    Добавим константный параметр, определяющий формальный тип:
    \[a \gets \op{shared}[\type{T}],\]
    где $\type{T}$~--- тип параметра, если операция соответствует
    получению формального параметра метода, тип поля, если операция
    соответствует чтению статического поля, или тип возвращаемого значения,
    если операция соответствует вызову.

    Рассмотрим еще одну операцию языка \java, операцию преобразования типа. При
    преобразовании типа выражения $x$ к типу $\type{T}$ происходит следующее:
    если значение выражения $x$ не совместимо по присваиванию с типом $T$,
    будет выброшено исключение во время исполнения.
    Поэтому в рамках алгоритма анализа можно считать, что результат
    преобразования всегда имеет формальный тип $T$.
    Введем соответствующую операцию внутреннего представления:
    \[ a \gets \op{cast}[\type{T}](x). \]

  \subsection{Повышение точности анализа}
    \label{section:increase_accuracy}

    В разделе~\ref{section:choosing_flow_insensitive} уже было замечено, что
    точность нечувствительного к потоку управления алгоритма может быть
    существенно ниже по сравнению с чувствительным к потоку управления
    алгоритмом.
    \todo{я хочу умолчать про то, что SSA-форма дает эффект строгих
    присваиваний, ибо сейчас я сразу формулирую все для SSA-формы. Это ок?}

    Для того чтобы понять, где же именно теряется точность, достаточно
    рассмотреть пример~\ref{sample:insensitive_getfields}. В
    строках~\ref{sample:insensitive_getfields:gf1}
    и~\ref{sample:insensitive_getfields:gf2} находятся два чтения поля, которые
    для алгоритма, нечувствительного к потоку управления, абсолютно идентичны,
    и результатом анализа будет то, что переменные $u$ и $v$ могут быть
    синонимами. Чувствительный к потоку управления алгоритм сможет в данном
    случае получить более точный результат за счет информации о том, что между
    чтениями данного поля была запись в него.

    \begin{sample}
      \begin{algorithmic}[1]
        \State $a \gets \op{new}[\type{T}]$
        \State $x \gets \op{new}[\type{Object}]$
        \State $y \gets \op{new}[\type{Object}]$
        \State $\op{putfield}[\field{f}](a, x)$
        \State $u \gets \op{getfield}[\field{f}](a)$
          \label{sample:insensitive_getfields:gf1}
        \State $\op{putfield}[\field{f}](a, y)$
        \State $v \gets \op{getfield}[\field{f}](a)$
          \label{sample:insensitive_getfields:gf2}
      \end{algorithmic}
      \caption{Два чтения различных значений из одного поля}
      \label{sample:insensitive_getfields}
    \end{sample}

    Ключевым моментом является то, что благодаря информации о потоке
    управления алгоритм может анализировать связи по памяти: какие модификации
    памяти могут влиять на какие чтения памяти. Нечувствительный к потоку
    управления алгоритм тоже мог бы учитывать эти связи, если бы они были явно
    выражены, как связи по значениям переменных.

    Далее опишем способ явного выражения зависимостей по памяти, который
    позволяет существенно повысить точность алгоритма.

  \subsection{\texorpdfstring{\M}{M}"=переменная и зависимости по памяти}

    Одним из способов выражения зависимостей по памяти является введение
    специальной переменной, представляющей образ всей памяти.
    Введем такую переменную, \emph{\M"=переменную}\footnote{
      От слова <<\eng{memory}>> (с англ. память).
    }.
    Значение этой переменной используется в качестве явного аргумента в
    операциях, читающих память, и является результатом операций, модифицирующих
    память. Также наравне с обычными переменными \M"=переменная версионируется
    при переводе в SSA-форму и может быть аргументом и результатом
    \phi"=функций.

    Для наглядности рассмотрим
    пример~\ref{sample:insensitive_getfields_with_m} с \M"=переменной, который
    эквивалентен примеру~\ref{sample:insensitive_getfields}.

    \begin{sample}
      \begin{algorithmic}[1]
        \State $a \gets \op{new}[\type{T}]$
        \State $x \gets \op{new}[\type{Object}]$
        \State $y \gets \op{new}[\type{Object}]$
        \State $\M_1 \gets \op{putfield}[\field{f}](\M_0, a, x)$
        \State $u \gets \op{getfield}[\field{f}](\M_1, a)$
        \State $\M_2 \gets \op{putfield}[\field{f}](\M_1, a, y)$
        \State $v \gets \op{getfield}[\field{f}](\M_2, a)$
      \end{algorithmic}
      \caption{Два чтения различных значений из одного поля с \M"=переменной}
      \label{sample:insensitive_getfields_with_m}
    \end{sample}

    Важно понимать, что на самом деле \M"=переменная является некоторой
    абстракцией памяти. Она не присутствует в явном виде в исходном коде
    программы и должна быть специально введена на некотором этапе компиляции
    программы. Аналогично эта переменная не имеет никакого физического
    воплощения в машинном коде и должна быть удалена перед кодогенерацией.

    Итого \M"=переменная позволяет явно выразить все зависимости по памяти
    между операциями. Для этого необходимо модифицировать набор операций
    внутреннего представления, описанных в разделе~\ref{section:ir_ops},
    следующим образом:
    \begin{itemize}
      \item Операции $\op{getfield}, \op{shared}$ первым
            аргументом принимают \M"=переменную.
      \item Операции $\op{putfield}, \op{escape}$
            первым аргументом принимают \M"=переменную и в качестве результата
            порождают \M"=переменную.
    \end{itemize}
    Дополнительно требуется ввести операцию, порождающую изначальное значение
    \M"=переменной:
    \[\M_0 \gets \op{initialmemory}.\]
    Эта операция добавляется в самое начало анализируемой программы.
    \todo{есть подозрения, про \M"=переменную можно рассказать больше. Воду
    лить не хочется, но тогда не понятно что же нужно}

  \subsection{Абстрактные объекты и значение \texorpdfstring{\M}{M}"=переменной}
    \label{section:ao_lattices}

    Опишем потоковое свойство, с которым будет работать анализ потока
    данных.

    Определим множество \emph{абстрактных объектов}, которые являются
    целями указателей при проведении анализа.
    Такие объекты будем обозначать как $\AO_{idx} \in AbsObjects$,
    а множество целей, на которые может указывать переменная ссылочного типа
    $x$: $\pts{x} \subseteq AbsObjects$.

    Один абстрактный объект может соответствовать одному или более объектам при
    исполнении программы. Однако два различных абстрактных объекта
    соответствуют разным объектам при исполнении программы.
    Это позволяет определять возможность синонимичности двух
    выражений ссылочного типа $x$ и $y$ с совместимыми типами: они могут быть
    синонимами тогда и только тогда, когда $\pts{x} \cap \pts{y} \ne
    \emptyset$.

    Источниками абстрактных объектов служат операции создания новых объектов:
    каждой из таких операций сопоставляется уникальный абстрактный объект.
    Объекты, приходящие в метод извне (формальные параметры, результат вызова и
    др.), представляются с помощью одного специального абстрактного объекта
    $\AOGlobal$. Таким образом консервативно полагается, что все значения,
    приходящие извне анализируемого метода, могут быть синонимами.

    Введем предикат $IsSingle\colon AbsObjects \to \{0, 1\}$, который
    выполняется тогда и только тогда, когда абстрактный объект соответствует
    ровно одному объекту при исполнении программы. Объект $\AOGlobal$ по
    определению представляет совокупность объектов:
    \[ IsSingle(\AOGlobal) = 0. \]
    Для объекта, соответствующего операции создания нового объекта, ситуация
    сложнее: предикат не выполняется тогда и только тогда, когда операция
    находится в некотором цикле и область жизни ее результата выходит за тело
    этого цикла. В рамках данной работы будем консервативно считать, что
    предикат выполняется только для объектов, порожденных вне циклов, однако с
    помощью анализа времени жизни переменных предикат может быть уточнен.

    Каждый абстрактный объект имеет точный тип (класс или массив). Тип
    абстрактного объекта, соответствующего операции создания нового объекта,
    определяется типом операции. Тип абстрактного объекта $\AOGlobal$ равен
    искусственному типу, который совместим по присваиванию с любым другим
    ссылочным типом (это необходимо для того, чтобы этот абстрактный объект мог
    быть целью выражения, имеющего произвольный формальный тип). Абстрактный
    объект типа $\type{T}$ будем обозначать $\AOTyped{T}$.

    Теперь рассмотрим более сложную \emph{\Ms"=структуру}, которая служит для
    выражения состояния памяти, значения \M"=переменной.
    Эта структура является кортежем из двух множеств:
    \[ \Ms = (\Mf{fields}, \Mf{shared}). \]
    Опишем каждое из этих множеств.

    Во-первых, \Ms"=структура содержит информацию о множестве целей полей
    абстрактных объектов:
    \[
      \Ms.\Mf{fields} \subseteq
        (AbsObjects \times Fields) \times
        \powerset{AbsObjects},
    \]
    где $Fields$~--- это множество идентификаторов полей объектов,
    присутствующих в анализируемой программе.
    Заметим, что это множество можно рассматривать как отображение:
    \[
      \Ms.\Mf{fields}(O, f) = pts \Leftrightarrow
        (O, f, pts) \in \Ms.\Mf{fields}.
    \]

    Во-вторых, \Ms"=структура содержит информацию о разделяемых объектах,
    то есть объектах, которые утекли \engdef{escaped} из анализируемого метода
    и могут быть прочитаны из произвольной разделяемой памяти. Множество
    разделяемых объектов есть подмножество множества абстрактных объектов:
    \[ \Ms.\Mf{shared} \subseteq AbsObjects. \]

    Для решения задачи анализа потока данных зададим полурешетку\footnote{
      Полурешетки и их свойства подробно описаны в монографии
      Мучника~\cite{muchnick}.
    }
    \todo{что-нибудь более конкретное чем Мучник? Ахо? Нильсон?}
    множеств целей выражений ссылочного типа \engdef{points-to set}:
    \[ \Lattice^{PTS} = (\powerset{AbsObjects}, \meet^{PTS}).\]
    Оператор $\meet^{PTS}$ определим следующим образом
    \[
      \forall x \subseteq AbsObjects, \forall y \subseteq AbsObjects
      \colon
      x \meet^{PTS} y = x \cup y,
    \]
    тогда отношения $\leq^{PTS}$ и $<^{PTS}$ имеют вид:
    \begin{align*}
      x \leq^{PTS} y &\Leftrightarrow y \subseteq x, \\
      x <^{PTS} y &\Leftrightarrow y \subset x.
    \end{align*}
    Соответственно нижний элемент $\bot^{PTS} = AbsObjects$
    и верхний элемент $\top^{PTS} = \emptyset$.

    Заметим, что мощность множества абстрактных объектов для любого
    метода конечна и равна $N + 1$,
    где $N$~--- количество операций создания новых объектов, которое ограничено
    размером анализируемого метода.

    Из этого следует конечность множества значений свойств полурешетки
    $\Lattice^{PTS}$, что дает конечную высоту полурешетки и гарантирует
    обрывание всех строго убывающих цепей.

    Множество $Fields$ также фиксировано и конечно в рамках одного метода.
    Тогда \Ms"=структуру можно представить как конечный кортеж подмножеств
    множества абстрактных объектов.
    Это позволяет определить полурешетку свойств операций, порождающих
    \M"=переменную, как конечное произведение полурешеток $\Lattice^{PTS}$:
    \[\Lattice^M = (MemStructs, \meet^M) =
      \Lattice^{PTS} \times \ldots \times \Lattice^{PTS},\]
    где $MemStructs$~--- множество всех \Ms"=структур.

    Теперь можно определить общую полурешетку свойств для всех операций
    внутреннего представления:
    \[ \Lattice = (L, \meet) = \Lattice^{PTS} \times \Lattice^M. \]

    Из конечной высоты полурешетки $\Lattice^{PTS}$
    и обрывания в ней всех строго убывающих цепей следуют аналогичные свойства
    для решетки $\Lattice^M$ и, соответственно, для решетки $\Lattice$.

  \subsection{Анализ потока данных}

    Сформулируем понятие задачи анализа потока данных на графе зависимостей по
    данным.

    \emph{Граф зависимостей по данным}~--- это ориентированный граф
    $G = (V, E)$, где
    \begin{itemize}
      \item $V$~--- это множество операций программы, каждая из которых имеет
            результат и в качестве аргументов имеет результаты других операций
            из $V$,
      \item $E \subseteq V^2$~--- это множество, представляющее связи между
            операциями: $(u, v) \in E$ тогда и только тогда, когда операция $v$
            имеет своим аргументом результат операции $u$.
    \end{itemize}

    Выделим в этом графе множество \emph{входных} вершин,
    \[ V_{entry} = \{ v \mid v \in V, \lnot \exists u\colon (u, v) \in E \}. \]
    То есть это множество образуют операции, которые не зависят от других по
    данным.

    Далее рассматриваем некоторую полурешетку свойств $\Lattice = (L, \meet)$.

    \emph{Монотонной потоковой функцией} назовем функцию $f^N \colon L^N \to L$
    такую, что
    \begin{multline*}
      \forall i\colon 1 \leq i \leq N,
      \forall x_1, \ldots, x_{i-1}, x_{i+1}, \ldots, x_N, y, z \in L \colon
        y \leq z \Rightarrow \\
        \Rightarrow
        f(x_1, \ldots, x_{i-1}, y, x_{i+1}, \ldots, x_N) \leq
        f(x_1, \ldots, x_{i-1}, z, x_{i+1}, \ldots, x_N).
    \end{multline*}

    \emph{Задачей анализа потока данных} назовем кортеж $(G, \Lattice,
    \mathcal{F}, I, F)$, где
    \begin{itemize}
      \item $G = (V, E)$~--- граф зависимостей по данным с выделенным
            множеством входных вершин $V_{entry} \subseteq V$,
      \item $\Lattice = (L, \meet)$~--- полурешетка потоковых свойств конечной
            высоты с обрывающимися строго убывающими цепями,
      \item $\mathcal{F}$~--- множество монотонных потоковых функций,
      \item $I\colon V_{entry} \to L$~--- начальные значения потоковых свойств
            на входных вершинах,
      \item $F\colon (V \setminus V_{entry}) \to \mathcal{F}$~--- отображение
            вершин в монотонные потоковые функции.
    \end{itemize}

    Такая постановка задачи несколько отличается от классической постановки
    анализа потока данных~\cite{muchnick, nielson}, но может быть сведена к
    таковой введением более сложной полурешетки свойств.
    Соответственно, итеративный алгоритм с небольшими модификациями подходит
    для решения этой задачи анализа, будет давать корректные результаты и
    гарантированно сходиться~\cite{kildall}.

    Теперь задачу анализа указателей можно сформулировать в терминах задачи
    анализа потока данных.

    Заметим, что после введения \M"=переменной все операции внутреннего
    представления имеют некоторый результат: либо значение ссылочного типа,
    либо \M"=переменную. Тогда можно рассматривать граф зависимостей по данным
    на множестве этих операций. Входными вершинами является множество вершин с
    операциями без аргументов
    ($\op{null}$, $\op{new}$, $\op{initialmemory}$).

    Полурешетка свойств для анализа указателей определена в
    разделе~\ref{section:ao_lattices}.

    Начальные значения потоковых свойств и потоковые функции описаны
    в разделе~\ref{section:flow_functions}.

    Результатами работы алгоритма являются множества абстрактных объектов,
    являющиеся целями выражений ссылочного типа. Итого, два выражения могут быть
    синонимами тогда и только тогда, когда они имеют совместимые по
    присваиванию типы (см.~раздел~\ref{section:op_types}) и множества их целей
    имеют непустое пересечение.

    Также алгоритм предоставляет информацию о том, может ли переменная
    ссылочного типа $x$ указывать на разделяемый объект в некоторой точке
    программы, задаваемой \M"=переменной: может тогда и только тогда, когда
    хотя бы один абстрактный объект из множества целей этой переменной
    принадлежит множеству $\Ms.\Mf{shared}$.

  \subsection{Семантика операций}
    \label{section:flow_functions}

    В этом разделе описана семантика всех операций, представленных ранее, в
    терминах анализа потока данных.

    Все операции внутреннего представления имеют только один результат:
    значение ссылочного типа или \M"=переменную. Поэтому одна компонента
    потокового свойства всегда будет равна нижнему элементу:
    \begin{itemize}
      \item $(\pts{x}, \bot^M) \in L, \pts{x} \in L^{PTS}$ для операции,
            возвращающей значение ссылочного типа $x$;
      \item $(\bot^M, \Ms_i) \in L, \Ms_i \in L^M$ для операции, порождающей
            \M"=переменную $\M_i$.
    \end{itemize}

    Значение нулевого указателя соответствует пустому множеству целей
    выражения:
    \[
      x \gets \op{null} \colon \quad
      \pts{x} = \emptyset.
    \]

    Создание нового объекта порождает множество из одного уникального
    абстрактного объекта:
    \[
      x \gets \op{new}[\type{T}] \colon \quad
      \pts{x} = \{\AO_i\}.
    \]

    Начальное значение \M"=переменной содержит пустые множества целей в
    множестве \Mf{fields}. Множество \Mf{shared}
    содержит единственный объект $\AOGlobal$.
    \begin{gather*}
      \M \gets \op{initialmemory} \colon \\
      \begin{aligned}
        &\Ms.\Mf{fields} = \{ (\AO, f, \emptyset) \mid
          \AO \in AbsObjects, f \in Fields \}, \\
        &\Ms.\Mf{shared} = \{\AOGlobal\}.
      \end{aligned}
    \end{gather*}

    Утекание объектов в разделяемую память моделируется операцией, которая
    добавляет данный объект в множество \Mf{shared}. Причем здесь и далее
    при добавлении в множество \Mf{shared} какого-либо объекта, добавляются
    также и все объекты, доступные через его поля.
    \begin{gather*}
      \M' \gets \op{escape}(\M, a) \colon \\
      \begin{aligned}
        &\Ms'.\Mf{fields} = \Ms.\Mf{fields}, \\
        &\Ms'.\Mf{shared} = \Ms.\Mf{shared} \cup \TClosure_\Ms(\pts{a}),
      \end{aligned}
    \end{gather*}
    где $\TClosure_\Ms(set)$~--- это транзитивное замыкание \engdef{transitive
    closure} множества объектов и множеств целей их полей.
    $\TClosure_\M(set)$ может быть вычислено следующим образом:
    \[\left\{\begin{aligned}
      &\TClosure_\Ms^0(set) = set; \\
      &\TClosure_\Ms^{i+1}(set) = \TClosure_\Ms^i(set) \cup
        \smashoperator{\bigcup_{\substack{\AO \in \TClosure_\Ms^i(set)\\
                           f \in Fields}}}
          \Ms.\Mf{fields}(\AO, f); \\
      &\TClosure_\Ms(set) =
        \bigcup_{i \in \mathbb{N}} \TClosure_\Ms^i(set).
    \end{aligned}\right.\]

    Результат чтения из разделяемой памяти есть множество разделяемых объектов
    из \M"=переменной, отфильтрованных по типу:
    \[ x \gets \op{shared}[\type{T}](\M) \colon \quad
       \pts{x} = \{ \AO^{\type{T'}} \mid
         \AO^{\type{T'}} \in \Ms.\Mf{shared} \text{ и }
         \type{T} \leq \type{T'} \}. \]

    Чтение поля из переменной $a$ возвращает множество объектов, записанных
    непосредственно в это поле. Однако если переменная $a$ может указывать
    хотя бы на один разделяемый объект, то возвращаемое множество расширяется
    всеми разделяемыми объектами:
    \begin{gather*}
      x \gets \op{getfield}[\field{f}](\M, a) \colon \\
      \pts{x} = \left( \bigcup_{\AO \in \pts{a}} \Ms.\Mf{fields}(\AO,
      \field{f}) \right) \cup
      \begin{cases}
        \Ms.\Mf{shared}, & \text{если } \pts{a} \cap
          \Ms.\Mf{shared} \ne \emptyset; \\
        \emptyset, & \text{иначе}.
      \end{cases}
    \end{gather*}

    Запись значения $x$ в поле $\field{f}$ переменной $a$ модифицирует значение
    памяти, изменяя множество целей $\Mf{fields}(\AO, \field{f})$ для всех
    $\AO \in \pts{a}$, и если переменная $a$ может указывать хоть на один
    разделяемый объект, то записываемые объекты утекают.

    Заметим, что если множество $\pts{a}$ содержит только один абстрактный
    объект $\AO$, соответствующий единственному реальному объекту при
    исполнении, то множество целей $\Mf{fields}(\AO, \field{f})$ можно
    заместить множеством $\pts{x}$\footnote{
      Подобное замещение целей ссылочного поля называется строгим присваиванием
      \engdef{strong update} и существенно повышает точность
      анализа~\cite{lhotak_strong_update}.
    }.
    В противном случае множество целей должно быть консервативно расширено, а
    не замещено, так как при исполнении программы запись случится только для
    одного из реальных объектов, соответствующих абстрактным.
    \begin{gather*}
      \M' \gets \op{putfield}[\field{f}](\M, a, x) \colon \\
      \begin{aligned}
        &\Ms'.\Mf{fields} = \{ (\AO, g, fieldpts(\AO, g, pts)) \mid
          (\AO, g, pts) \in \Ms.\Mf{fields} \}, \\
        &fieldpts(\AO, g, pts) =
          \begin{cases}
            \emptyset, & \text{если } \pts{a} = \emptyset; \\
            pts, & \text{если } \pts{a} \neq \emptyset \text{ и } (\AO \notin \pts{a} \text{ или } g
              \neq \field{f}); \\
            \pts{x}, & \text{если } \pts{a} = \{\AO\} \text{ и } IsSingle(\AO)
              \text{ и } g = \type{f}; \\
            pts \cup \pts{x}, & \text{иначе},
          \end{cases} \\
        &\Ms'.\Mf{shared} = \Ms.\Mf{shared} \cup
          \begin{cases}
            \TClosure_\Ms(\pts{x}), & \text{если }
              \pts{a} \cap \Ms.\Mf{shared} \ne \emptyset;\\
            \emptyset, & \text{иначе}.
          \end{cases}
      \end{aligned}
    \end{gather*}
    Рассмотрим подробнее случай, когда множество целей $\pts{a}$ пусто: это
    может быть только в том случае, когда $a$ является пустым указателем.
    Операция записи поля пустого указателя в любом случае завершится ошибкой
    исполнения, поэтому корректно считать, что множества целей полей объектов
    после этой операции могут быть любыми, в том числе пустыми. Это также
    необходимо для сохранения монотонности по аргументу $a$, то есть для
    произвольного $x$ должно быть выполнено следующее:
    \begin{multline*}
      \pts{a_1} = \{\AO\}, \pts{a_0} = \emptyset, \pts{a_1} \leq \pts{a_0}
        \Rightarrow \\ \Rightarrow
        \left. fieldpts(\AO, \type{f}, pts) \right|_{a = a_1} \leq
        \left. fieldpts(\AO, \type{f}, pts) \right|_{a = a_0},
    \end{multline*}
    что возможно, только если правая часть есть пустое множество.

    Операция преобразования типа фильтрует множество объектов, исключая
    несовместимые по присваиванию:
    \begin{gather*}
      x \gets \op{cast}[\type{T}](a) \colon \\
      \pts{x} = \{ \AOTyped{T'} \mid \AOTyped{T'} \in \pts{a} \text{ и }
        T \leq T' \}.
    \end{gather*}

    В результате перевода программы в SSA-форму могут появиться \phi"=функции
    от переменных ссылочного типа и от \M"=переменных. Оба вида функций
    обладают довольно простой семантикой:
    \[
      x \gets \op{phi}(a_1, \ldots, a_N) \colon \quad
      \pts{x} = \bigcup_{i = 1}^N \pts{a_i},
    \]
    \begin{gather*}
      \M' \gets \op{phi}(\M_1, \ldots, \M_N) \colon \\
      \begin{aligned}
        &\begin{split}
          \Ms'.\Mf{fields} = \{&(\AO, f, \bigcup_{i = 1}^N pts_i) \mid
            \AO \in AbsObjects, f \in Fields, \\
            & 1 \leq i \leq N\colon
            (\AO, f, pts_i) \in \Ms_i.\Mf{fields} \},
       \end{split} \\
        &\Ms'.\Mf{shared} = \bigcup_{i = 1}^N \Ms_i.\Mf{shared}.
      \end{aligned}
    \end{gather*}

    Монотонность рассмотренных потоковых функций в большинстве случаев
    не вызывает сомнений и может быть непосредственным образом проверена.
    Единственный нетривиальный момент~--- это монотонность функции для операции
    $\op{putfield}$ по второму аргументу, что уже было разобрано ранее.

  \section{Оптимизация удаления чтений полей}

    В данном разделе описана оптимизация удаления чтений полей объектов. Под
    удалением в данном случае понимается замена результата чтения поля на
    значение, которое было ранее туда записано. Эта оптимизация активно
    использует результаты анализа синонимов и семантику многопоточных программ.

    При проведении такой оптимизации важно учитывать модель памяти языка, так
    как без нее оптимизация чтений полей разделяемых объектов невозможна из-за
    консервативного предположения, что такие поля могут быть изменены в
    произвольный момент времени другими потоками многопоточной программы.

    Модель памяти языка \java позволяет сохранять значения полей
    разделяемых объектов и использовать их при последующих чтениях.
    Однако модель памяти задает и то, когда значения таких полей обязаны
    быть перечитаны из разделяемой памяти: при чтении
    \eng{volatile}\footnote{
      Модификатор \eng{volatile}. В языке \java применим к статическим и
      обычным полям, обладает особой семантикой в рамках модели памяти.
    } поля и при входе в блок синхронизации\footnote{
      Блок синхронизации представляет блок кода, при входе в который происходит
      попытка захвата мьютекса, а при выходе~--- его освобождение.
    }.
    С учетом этой информации удаления чтений полей разделяемых объектов могут
    проводиться более эффективно.

    Оптимизация проводится на внутреннем представлении с \M"=переменной,
    схожим с тем, что описано в разделе~\ref{section:ir_ops}, но имеющим
    несколько другой набор операций
    (см.~табл.~\ref{tabular:read_elimination_operations}).

    \begin{table}[htb]
      \centering

      \begin{tabular}{|p{0.55\textwidth}|p{0.35\textwidth}|}\hline
        \textbf{\java операция} &
          \textbf{Внутреннее представление}\\ \hline

        Искусственная операция порождения начального значения памяти
        & $\M \gets \op{initialmemory}$
        \\ \hline

        Чтение поля $\field{f}$ объекта $a$
        & $a \gets \op{getfield}[\field{f}](\M, a)$
        \\ \hline

        Запись в поле $\field{f}$ объекта $a$ значения $b$
        & $\M' \gets \op{putfield}[\field{f}](\M, a, b)$
        \\ \hline

        \phi-функция для \M"=переменной
        & $\M' \gets \op{phi}(\M_1, \ldots, \M_N)$
        \\ \hline

      \end{tabular}
      \caption{Операции языка \java необходимые для проведения оптимизации
               удаления чтений полей}
      \label{tabular:read_elimination_operations}
    \end{table}

    Дополнительно во внутреннее представление добавляется операция
    $\op{reload}$:
    \[ \M' \gets \op{reload}(\M), \]
    которая соответствует перечитыванию полей всех разделяемых объектов и
    потенциально может их все изменять.
    Она добавляется перед чтением \eng{volatile} поля, перед входом в блок
    синхронизации. Также $\op{reload}$ добавляется на место вызова другого
    метода, что необходимо, так как вызываемый метод может также модифицировать
    значения полей всех разделяемых объектов.

    Далее рассматриваем две операции, запись в поле и чтение этого же поля того
    же объекта\footnote{
      На самом деле для проведения такой оптимизации достаточно синонимичности
      объектов. В данном случае консервативно считаем, что объекты
      синонимичны, если они равны.
    }:
    \begin{align*}
      \M_1 &\gets \op{putfield}[\field{f}](\M_0, a, x), \\
      y &\gets \op{getfield}[\field{f}](\M_k, a).
    \end{align*}

    Понятно, что зависимости по значению \M"=переменной образуют связный
    ориентированный граф \emph{зависимостей по памяти}, начальной вершиной
    которого является операция $\op{initialmemory}$.
    Замена переменной $y$ на $x$ корректна, если первая операция доминирует над
    второй в графе зависимостей по памяти и на любом пути из первой во
    вторую нет операций, модифицирующих поле $\field{f}$ объекта $a$.

    Рассмотрим, какие операции могут модифицировать данное поле.
    Операция \[\M_{i+1} \gets \op{reload}(\M_i)\] может изменять произвольные
    поля разделяемых объектов, то есть если $a$ может указывать на разделяемый
    объект в этой точке программы, то считается, что данная операция может
    изменить поле $\field{f}$ объекта $a$.
    Операция
    \[\M_{i+1} \gets \op{putfield}[\field{f}](\M_i, b, z)
      \text{ при } b \neq a\]
    может изменить поле $\field{f}$ объекта $a$ тогда и только тогда, когда
    $a$ и $b$ могут быть синонимами.
    А операция
    \[\M_{i+1} \gets \op{putfield}[\field{g}](\M_i, b, z)
      \text{ при } \field{g} \neq \field{f} \text{ и любом } b\]
    никогда не может изменить поле $\field{f}$ какого-либо объекта.

  \subsection{Алгоритм}

    В данном разделе представлен алгоритм, который проводит описанную
    ранее оптимизацию для двух операций или сообщает, что это сделать нельзя.

    На входе алгоритм принимает две операции $opPut$ и $opGet$ следующего вида:
    \begin{align*}
      opPut &\colon \M_1 \gets \op{putfield}[\field{f}](\M_0, a, x), \\
      opGet &\colon y \gets \op{getfield}[\field{f}](\M_k, a).
    \end{align*}

    Алгоритм~\ref{algorithm:read_elimination_algorithm} реализует логику,
    описанную в предыдущем разделе для проверки, можно ли заменить переменную
    $y$ на $x$. Он работает с графом зависимостей по памяти и фактически
    проходит в обратном направлении по всем путям,
    которые входят в $opGet$ и, так как $opPut$ доминирует над $opGet$, эти пути
    обязательно дойдут до операции $opPut$, где и оборвутся благодаря тому, что
    в $worklist$ добавляются только операции, которых нет в $processed$. Это
    также гарантирует то, что алгоритм не будет дважды проверять одну и ту же
    операцию, что, следовательно, дает сходимость алгоритма при конечном
    множестве операций.

    \begin{algorithm}
      \begin{algorithmic}[1]
        \If{$opPut$ не доминирует над $opGet$}
          \State закончить с результатом <<нельзя заменить>>
        \EndIf
        \State $worklist = \{opGet\}$
        \State $processed = \{opPut\}$
        \While{$worklist \neq \emptyset$}
          \State выбрать операцию $op \in worklist$ и удалить ее
          \State добавить $op$ в $processed$
          \If{$op$ не может модифицировать поле $\field{f}$ объекта $a$}
            \State $preds = $ множество \M"=аргументов $op$
            \State добавить $(preds \setminus processed)$ в $worklist$
          \Else
            \State закончить с результатом <<нельзя заменить>>
          \EndIf
        \EndWhile
        \State закончить с результатом <<можно заменить>>
      \end{algorithmic}
      \caption{Алгоритм удаления чтений полей объектов}
      \label{algorithm:read_elimination_algorithm}
    \end{algorithm}

  \subsection{Замечания}

    Важным наблюдением является то, что аналогичная оптимизация может быть
    проведена для удаления чтений статических полей и элементов массивов.

    Необходимо также заметить, что представленный алгоритм является эффективным
    для проверки возможности замены одной операции на другую. Однако в общем
    случае задача ставится так, что необходимо для данного чтения поля найти
    подходящую запись в поле, на аргумент которой можно будет заменить
    результат чтения. Подобная задача может быть реализована перебором пар
    операций, а эффективная реализация выходит за рамки данной работы.

    Интересное наблюдение заключается в том, что удаление чтений полей позволяет
    уточнить анализ указателей, что в свою очередь увеличивает количество
    чтений полей, которые можно удалить. Таким образом, анализ указателей и
    рассмотренную оптимизацию имеет смысл выполнять последовательно до
    достижения неподвижной точки.

  \section{Реализация}

    Разработанный алгоритм анализа указателей был реализован в рамках
    статического компилятора языка \java, входящего в систему \eng{Excelsior
    RVM}.

    Алгоритм анализа представлен в виде отдельной компоненты компилятора,
    написанного на языке программирования \eng{Scala}~\cite{scala_lang}.
    Оптимизация удаления чтений полей также реализована в виде отдельной
    компоненты. Функциональность обоих компонент проверяется набором модульных
    тестов \engdef{unit tests}.

    Проведение оптимизации удаления чтений полей, использующей результаты
    анализа, добавлено в основной цикл оптимизаций компилятора.
    В таких условиях компилятор успешно собирает тестовый набор \java программ.
    В частности, в этот набор входит \eng{SPECjvm2008}~--- это группа
    приложений, состоящая из нескольких реальных приложений и некоторого
    количества искусственных бенчмарков, приложений для измерения
    производительности~\cite{spec_jvm2008}. Общее количество методов в данном
    наборе: \num{37933}.

    Заметим, что непосредственная проверка точности и корректности анализа на
    больших программах невозможна. Однако косвенные оценки можно получить по
    результатам оптимизации, использующей анализ синонимов. Было установлено,
    что при сборке набора \eng{SPECjvm2008} было удалено \num{10556} чтений
    полей при использовании разработанного алгоритма анализа, а при
    использовании консервативного алгоритма анализа, который основывается
    только на  информации о типах\footnote{
      Такой анализ консервативно считает, что два выражения ссылочного типа
      могут быть синонимами тогда и только тогда, когда они имеют совместимые
      типы~\cite{diwan_tbaa}.
    },
    количество удаленных чтений существенно меньше: \num{732}.
    \todo{перепроверить эти цифры}
    Эти цифры не могут гарантировать высокую абсолютную точность результатов,
    но могут служить показателем того, что они достаточно точны для
    эффективного проведения оптимизаций, использующих анализ синонимов.

    Точных временных\slash{}емкостных оценок сложности разработанного алгоритма в
    данной работе не приводится, однако на практике было установлено, что
    алгоритм несущественно влияет на общее время работы компилятора и с
    небольшими доработками может быть использован в промышленном компиляторе.

  \sectionwithoutnumber{Заключение}

    Целью данной работы являлась разработка алгоритма анализа указателей и
    синонимов для языка \java, учитывающего особенности языка и его модели
    памяти.

    В ходе работы было сделано следующее:
    \begin{itemize}
      \item Проведен анализ существующих алгоритмов анализа указателей и
            синонимов, выделены их основные отличительные характеристики.
      \item Разработана схема выражения зависимостей между операциями
            работающими с памятью: все операции языка \java, работающие с
            памятью, были выражены через набор примитивных операций, работающих
            с \M"=переменной. Семантика этих операций подробно описана и
            согласована с моделью памяти языка.
      \item Разработан внутрипроцедурный, нечувствительный к потоку управления
            алгоритм анализа указателей, использующий \M"=переменную для
            выражения зависимостей по данным.
      \item Разработан алгоритм оптимизации, позволяющей заменять чтения полей
            объектов на значения, которые были ранее в эти поля записаны. Этот
            алгоритм активно использует результаты анализа синонимов.
      \item Реализованы алгоритм анализа указателей и оптимизация удаления
            чтений полей в рамках проекта \eng{Excelsior RVM}. Проведен набор
            тестов, демонстрирующих эффективность представленных алгоритмов.
    \end{itemize}

    В дальнейшем планируется усовершенствование алгоритма для проведения
    межпроцедурного анализа указателей и оценка его временной\slash{}емкостной
    сложности.

    Также планируется реализовать представленный алгоритм анализа
    указателей в промышленном статическом компиляторе языка \java в
    рамках проекта \eng{Excelsior JET}. Потребуется проведение более
    тщательного комплексного тестирования и поддержки некоторых дополнительных
    возможностей компилятора, которые не вошли в данную работу.

  \bibliographystyle{../../common/gost705}
  \bibliography{../../common/biblio}

\end{document}

