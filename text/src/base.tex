\documentclass[14pt,titlepage,draft]{extarticle}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PACKAGES
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{ucs}
\usepackage[utf8x]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{indentfirst}

\usepackage{geometry}

\usepackage[usenames,dvipsnames]{color}

\usepackage{ifdraft}

\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{mathtools} % some extensions over amsmath

% should be loaded after hyperref & ams*
\usepackage[norefs,nocites,msgs]{refcheck}

\usepackage{xspace} % for \xspace
\usepackage{pbox}

\usepackage{footmisc}
\renewcommand{\footnotelayout}{\small}

% prevent underfull boxes in bibliography
\usepackage{etoolbox}
\apptocmd{\sloppy}{\hbadness 10000\relax}{}{}

\usepackage[obeyDraft, textwidth=3cm, textsize=footnotesize,
  backgroundcolor=orange!50, linecolor=black!50]{todonotes}

\usepackage{float}
\newfloat{algorithm}{!htb}{loa}

% should be loaded after float and before algorithm
% to correctly link algorithms
\usepackage[pdftex,unicode,hidelinks,final]{hyperref}

\usepackage{algorithm}
\usepackage{algpseudocode}
\floatname{algorithm}{Пример}
\newcommand{\algorithmictitle}[1]{\hspace{8mm}\textbf{#1}}
\algrenewcommand{\algorithmiccomment}[1]{\hfill \textit{#1}}

\usepackage{float}
\newfloat{algorithm}{!htb}{loa}

\usepackage{multicol}

% should be loaded after hyperref & ams*
\usepackage[norefs,nocites,msgs]{refcheck}

\usepackage[raggedright]{titlesec}

\usepackage{../../common/cypokcommon}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% DOCUMENT-SPECIFIC COMMANDS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\input{../../common/gitinfo}

\newcommand{\java}{\eng{Java}\xspace}

\newcommand{\M}{\ensuremath{\mathbb{M}}}
\newcommand{\Ms}{\ensuremath{\mathbb{\widebar{M}}}}
\newcommand{\Mfield}[1]{\ensuremath{\mathrm{#1}}}

\let\mathphi\phi
\renewcommand{\phi}{\ensuremath{\mathphi}}

\newcommand{\type}[1]{\mathrm{#1}}
\newcommand{\field}[1]{\mathrm{#1}}
\newcommand{\sfield}[2]{\type{#1}.\field{#2}}
\newcommand{\method}[1]{\mathrm{#1}}
\newcommand{\smethod}[2]{\type{#1}.\method{#2}}

\newcommand{\op}[1]{\mathbf{#1}}

\newcommand{\pts}[1]{\widebar{#1}}

\newcommand{\AO}[1]{O_{#1}}
\newcommand{\AOGlobal}{\AO{global}}

\newcommand{\Lattice}{\mathcal{L}}
\newcommand{\meet}{\wedge}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% TEXT FORMAT
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\geometry{a4paper,top=2cm,bottom=2cm,bindingoffset=0cm}
\ifdraft{
  % <leftmargin> | <marginpar> | <sep> | <text> | <rightmargin>
  %    0.5cm     |     3cm     | 0.5cm |  16cm  |     1cm
  \geometry{reversemp=true,includemp=true,
            marginparwidth=3cm,marginparsep=0.5cm,
            left=0.5cm,textwidth=16cm}
}{
  % <leftmargin> | <text> | <rightmargin>
  %     3cm      |  16cm  |     2cm
  \geometry{left=3cm,textwidth=16cm}
}
\linespread{1.3}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% BODY
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand\thetitle{
  Применение анализа указателей и синонимов
  для оптимизации многопоточных программ
}
\newcommand\theauthor{
  Владимир Парфиненко
}

\title{\thetitle}
\author{\theauthor}

\hypersetup{
  pdfinfo={
    Title = {\thetitle},
    Author = {\theauthor},
    Subject = {}
  }
}

\begin{document}

  \thispagestyle{empty}
  \begin{center}
    \ifdraft{
      \
      \vspace{3cm}

      {\Large \scshape Черновик \par}

      \vspace{2cm}

      Работа на соискание степени магистра

      \vspace{0.2cm}

      {\large Парфиненко Владимир Владимирович \par}

      \vspace{1.5cm}

      {\large \scshape \bfseries
        Применение анализа указателей и синонимов\\
        для оптимизации многопоточных программ \par
      }

      \vfill

      Git info

      \begin{table}[!htb]
        \centering
        \begin{tabular}{rp{0.5\textwidth}}
          sha1: & \texttt{\GitAbbrHash} \\
          title:& \GitSubject \\
          date: & \GitDate
        \end{tabular}
      \end{table}
    }{
      Министерство образования и науки\\
      Российской Федерации

      \vspace{0.7cm}

      Государственное образовательное учреждение\\
      высшего профессионального образования\\
      <<Новосибирский национальный исследовательский\\
      государственный университет>> (НГУ)

      \vspace{0.7cm}

      Механико"=математический факультет

      \vspace{0.2cm}

      Кафедра программирования

      \vspace{1.2cm}

      Квалификационная работа на соискание\\
      степени магистра

      \vspace{0.5cm}

      {\large Парфиненко Владимир Владимирович \par}

      \vspace{1.1cm}

      {\large \scshape \bfseries
        Применение анализа указателей и синонимов\\
        для оптимизации многопоточных программ \par
      }

      \vspace{2.5cm}


      \hfill\pbox{\textwidth}{
        Научные руководители:\\
        м.\,н.\,с.~ИСИ~СО~РАН, Павлов~П.\,Е.,\\
        зав.\,лаб.~ИСИ~СО~РАН, к.\,т.\,н.~Шелехов~В.\,И.
      }

      \vfill

      Новосибирск 2013
    }
  \end{center}

  \listoftodos

  \tableofcontents

  \sectionwithoutnumber{Введение}

    Статический анализ программ активно применяется в оптимизирующих
    компиляторах. Одним из видов статического анализа является анализ
    указателей и синонимов. Результаты такого анализа могут быть использованы
    для усиления других видов анализа, проводимых оптимизирующим компилятором,
    и, как следствие, для повышения качества оптимизирующих преобразований.
    Таким образом может быть усилен достаточно обширный класс анализов и
    оптимизаций, как классических (таких например, как удаление общих
    подвыражений, чистка циклов, протяжка констант и присваиваний, удаление
    проверок времени исполнения), так и объектно"=ориентированных
    (девиртуализация, удаление избыточной синхронизации, \eng{escape}"=анализ,
    аллокация объектов на стеке, открытая подстановка объектов).

    Для программ, исполняемых в управляемых средах \engdef{managed
    environments}, таких, как JVM\footnote{\eng{JVM, Java Virtual Machine}~---
    виртуальная машина \java, основная часть исполняющей системы \java.}, или
    CLR\footnote{\eng{CLR, Common Language Runtime}~--- виртуальная машина,
    интерпретирующая и исполняющая код на языке CIL, в который компилируются
    программы, написанные, в частности, на .NET"=совместимых языках
    программирования.}, значение анализа указателей и синонимов для
    качественной оптимизации кода существенно возрастает. Это связано с двумя
    основными причинами. Во-первых, в управляемых средах затруднен или вообще
    отсутствует доступ программиста к низкоуровневым, небезопасным средствам
    (таким, например, как адресная арифметика и ручное управление памятью), что
    затрудняет ручную оптимизацию и вынуждает оптимизирующий компилятор
    (виртуальную машину) проводить более глубокий анализ и более агрессивные
    оптимизации программы для достижения приемлемого уровня производительности.

    Во-вторых, любая программа в управляемой среде является многопоточной, а
    сама среда обеспечивает поддержку средств многопоточного программирования,
    таких, как потоки исполнения \engdef{threads}, атомарные операции,
    примитивы синхронизации. Более того, семантика любого участка кода
    программы (например, отдельной процедуры) более не может считаться
    независимой от многопоточной среды~--- семантика всех взаимодействий кода с
    разделяемой памятью описывается так называемой моделью памяти данного
    языка/среды, которая описывает влияние различных потоков исполнения друг на
    друга через разделяемую память и тем самым определяет корректность тех или
    иных преобразований программы~\cite{manson_jmm}. На практике это означает,
    что не всякие оптимизирующие преобразования однопоточной программы будут
    являться корректными, если рассматривать ту же программу в многопоточной
    среде. Корректное и при этом не чрезмерно препятствующее оптимизациям
    определение зависимостей и связей в программе возможно только при
    проведении нетривиального анализа указателей и синонимов.

    Данная работа посвящена разработке алгоритма анализа указателей и синонимов
    для языка \java, учитывающего вышеприведенные соображения.

  \section{Постановка задачи}

    Целью данной работы является разработка алгоритма анализа указателей и
    синонимов для языка \java, учитывающего особенности языка и его модели
    памяти.

    Для достижения поставленной цели необходимо провести сравнительный анализ
    существующих алгоритмов, обосновать их сравнительную пригодность (включая
    результативность и производительность) для использования в оптимизирующем
    компиляторе. Используя эти данные, нужно разработать новый алгоритм анализа
    указателей, учитывающий особенности управляемых языков программирования.

    Разработанный алгоритм требуется реализовать на базе системы \eng{Excelsior
    Research Virtual Machine}, включающей статический компилятор и среду
    исполнения для платформы \eng{Java~SE}. В качестве пользователя анализа
    также требуется реализовать некоторую оптимизацию и провести замеры ее
    эффективности.
    \todo{добавить про необходимость реализации удаления избыточных чтений}

  \section{Существующие алгоритмы анализа указателей}

    \emph{Анализ указателей}~--- это один из видов статического анализа,
    который определяет, на какие объекты в памяти могут указывать выражения
    ссылочного типа в программе (такие объекты называются целями выражения
    ссылочного типа). \emph{Анализ синонимов} похож на анализ указателей: его
    целью является определение, могут ли два выражения быть синонимами, то есть
    ссылаться на одно и то же место в памяти~\cite{andersen}.

    Существует множество алгоритмов анализа указателей для разных языков
    программирования~\cite{hind_pointer_analysis_not_solved_yet}. Различаются
    они по точности получаемых результатов и временной/емкостной сложности.

    В настоящее время базовыми являются два алгоритма, которые отличаются
    представлением информации о целях указателей. И именно на двух этих
    алгоритмах основываются многие другие.
    Первый~--- это алгоритм Стинсгарда, который имеет
    практически линейную временную сложность\footnote{
      Временная сложность алгоритма Стинсгарда
      $O(N \alpha(N))$, где $N$~--- размер анализируемой программы,
      $\alpha$~--- обратная функция Аккермана. Она является очень медленно
      растущей, и при анализе асимптотики алгоритмов можно принять ее за
      константу.
    }~\cite{steensgaard}. Однако этот алгоритм предоставляет существенно менее
    точные результаты по сравнению со вторым алгоритмом, алгоритмом
    Андерсена. Хотя этот алгоритм и потребляет время, в худшем случае
    пропорциональное кубу от размера программы~\cite{andersen}, на практике оба
    алгоритма имеют сравнимую скорость работы при анализе небольших программ
    (до \num{3000} строк)~\cite{shapiro_fast_and_accurate}.

    Разработанный в данной работе алгоритм анализа основывается на идеях
    алгоритма Андерсена, так как точность алгоритма Стинсгарда не является
    достаточной для статического компилятора управляемого языка
    программирования.

    Для сравнения точности алгоритмов анализа указателей необходимо ввести
    некую меру точности. В качестве простой меры точности алгоритма часто
    используется усредненное количество синонимов для всех переменных
    ссылочного типа, появляющихся в
    программе~\cite[раздел~3.2]{hind_pointer_analysis_not_solved_yet}
    (также существуют и более изощренные
    меры~\cite{hind_pointer_analysis_not_solved_yet,diwan_tbaa}).
    Понятно, что для <<идеального>> алгоритма анализа это число будет
    минимальным, а для самого консервативного алгоритма~--- максимальным.

  \subsection{Чувствительные к потоку управления алгоритмы}
    \label{section:choosing_flow_insensitive}

    Важной характеристикой алгоритмов анализа указателей является
    чувствительность к потоку управления в программе
    \engdef{flow"=sensitivity}.

    Алгоритм анализа, \emph{чувствительный к потоку управления}, работает с
    графом потока управления программы, и результирующая информация о целях
    выражений приписывается каждой отдельной операции. За счет этого анализ
    учитывает только те последовательности исполнения операций, которые
    действительно реализуемы.

    \emph{Нечувствительный к потоку управления} алгоритм анализа рассматривает
    программу как неупорядоченный набор операций. Такой алгоритм
    консервативно полагает, что операции могут идти в произвольном порядке и
    повторяться произвольное количество раз.

    Алгоритм анализа, чувствительный к потоку управления, дает более точные
    результаты, при этом потребляя значительно больше ресурсов, таких как
    память и время~\cite[раздел.~4.4]{hind_pointer_analysis_not_solved_yet}.
    Такое потребление ресурсов является достаточным для отказа от
    использования на практике подобных алгоритмов анализа в статическом
    компиляторе.

    Поэтому алгоритм, разработанный в рамках этой работы, является
    нечувствительным к потоку управления. Однако ухудшение точности при таком
    выборе может быть также неприемлемым.
    Для решения этой проблемы и получения сравнимой точности пришлось
    существенно модифицировать внутреннее представление программы, с которым
    будет работать алгоритм анализа указателей. Эти изменения описаны в
    разделе~\ref{section:increase_accuracy}.

  \subsection{Межпроцедурные алгоритмы}

    Не менее важной чертой алгоритмов анализа является то, как они
    обрабатывают вызовы подпрограмм.

    \emph{Внутрипроцедурные алгоритмы} при анализе отдельной процедуры не
    выходят за ее пределы и все вызовы обрабатывают консервативно: полагается,
    что может исполняться абсолютно произвольный набор операций, модифицирующий
    поля всех разделяемых объектов.

    \emph{Межпроцедурный алгоритм} анализа при обработке вызова может
    предварительно провести анализ вызываемой подпрограммы и как-либо учесть
    эту информацию.

    Понятно, что межпроцедурный алгоритм дает более точные результаты,
    а внутрипроцедурный потребляет существенно меньше времени и
    памяти~\cite[с.~117]{andersen}.

    Также нужно заметить, что при рассмотрении управляемых языков
    программирования, где большинство вызовов является виртуальными,
    межпроцедурный алгоритм анализа дополнительно усложняется. Поэтому в
    данной работе будет описан внутрипроцедурный алгоритм, хотя и реализация
    межпроцедурной его версии не исключается в будущих работах.

  \section{Особенности языка \texorpdfstring{\java}{Java}}

    В этом разделе описаны ключевые особенности языка \java, которые необходимо
    учесть при разработке алгоритма анализа указателей и оптимизации удаления
    чтений полей объектов.

  \subsection{Система типов}
    \label{section:type_system}

    Опишем строгую систему типов языка \java.
    Все типы делятся на ссылочные и примитивные (скалярные).
    Примитивные типы можно не рассматривать в контексте анализа указателей,
    так как они не могут переносить информацию о целях указателей.
    Ссылочные типы~--- это классы, интерфейсы и массивы.
    Для любого выражения ссылочного типа можно определить его формальный тип:
    источниками формальных типов являются типы параметров метода, типы
    возвращаемых значений и типы полей.

    На множестве ссылочных типов можно определить отношение частичного
    порядка: $A \leq B$ ($B$ совместим по присваиванию с $A$) тогда и только
    тогда, когда значение типа $B$ можно присвоить
    в переменную типа $A$~\cite{nastia_type_analysis}.
    Также можно ввести отношение совместимости двух типов, истинное тогда и
    только тогда, когда существует тип, совместимый по присваиванию с ними
    обоими:
    \[
      A \text{ и } B \text{ совместимы }
      \Leftrightarrow
      \exists C\colon A \leq C \land B \leq C.
    \]

    Согласно спецификации языка \java, во время исполнения программы
    выражение ссылочного типа может указывать только на те объекты, тип
    которых совместим по присваиванию с формальным типом этого выражения.
    Из этого получаем, что два выражения, имеющие несовместимые типы, не
    могут указывать на один и тот же объект и быть синонимами.

  \subsection{Модель памяти}

    Модель памяти для многопоточной системы определяет в каком
    порядке могут происходить доступы к памяти в программе и, как следствие,
    какие значения может возвращать конкретное чтение памяти. В данном разделе
    описана модель памяти языка \java.

    Модели памяти различаются по тому, насколько сильные ограничения
    накладываются на последовательность исполнения операций чтения и записи.
    Модель памяти может быть очень строгой и требовать последовательного
    исполнения всех операций чтения и записи~\cite{lamport}.
    Такая модель сильно ограничивает набор используемых оптимизаций, так как
    многим из них требуется менять отдельные операции чтения и записи местами,
    а строгая модель памяти не позволяет это сделать, даже если между
    операциями нет зависимости по управлению и данным.
    Слабая модель памяти может не определять какого-либо жесткого порядка
    исполнения операций. Основываясь на этой модели, компилятор может довольно
    сильно преобразовывать программу с целью ее оптимизации, однако
    разработчику придется потратить много ресурсов для написания корректной
    программы в рамках такой слабой модели памяти.

    Модель памяти, представленная в спецификации языка \java версии 5.0
    является компромиссом между возможностью проведения широкого класса
    оптимизаций и удобством разработки программ на языке \java. Подробное
    описание можно найти в спецификации JSR-133~\cite{jsr133}. Модель памяти
    является достаточно строгой и однозначно определяет, как будут исполняться
    корректно синхронизированные программы (программы, в которых отсутствуют
    конфликты доступа\footnote{
      Конфликт доступа \engdef{data-race} образуют две операции доступа к
      разделяемой памяти из разных потоков, если хотя бы одна из них~---
      запись и эти операции не упорядочены в рамках модели памяти (подробнее
      см.~\cite[раздел~2.1]{manson_jmm}).
    } \engdef{data-race free}). Однако она является и достаточно слабой,
    позволяя проводить многие оптимизации.

  \section{Алгоритм анализа указателей}

    В этом разделе описан разработанный алгоритм анализа указателей. Он является
    внутрипроцедурным и нечувствительным к потоку управления. Основой алгоритма
    является проведение анализа потока данных на графе потока данных программы.

  \subsection{Внутреннее представление}
    \label{section:dfg}

    Сначала необходимо описать внутреннее представление, с которым работает
    алгоритм. Программа представляется неупорядоченным набором операций в
    SSA-форме\footnote{
      Будем говорить, что программа находится в SSA-форме (\eng{Static Single
      Assignment}), если существует не более одного присваивания в любую из
      переменных~\cite{ssa}.
      Любую программу можно перевести в SSA-форму посредством
      версионирования переменных и расстановки \phi-функций~\cite{ssa}.
      Для перевода в SSA-форму и вывода из нее существуют эффективные
      алгоритмы~\cite{bilardi_ssa, briggs_ssa}.
    }, которые в общем случае имеют вид:
    \[ var \gets \op{operation}[id_1, \ldots, id_M](arg_1, \ldots, arg_N), \]
    где
    $N \geq 0$~--- количество аргументов операции;
    $arg_i$~--- $i$-ый аргумент операции (переменная);
    $M \geq 0$~--- количество константных параметров операции;
    $id_i$~--- $i$-ый параметр (идентификатор типа, поля или метода);
    $var$~--- результат операции (переменная, может отсутствовать).
    Множество операций представлено в разделе~\ref{section:ir_ops}.

    Изначально алгоритм строит ориентированный граф $G = (V, E)$. Множество
    $V$~--- это множество всех операций внутреннего
    представления программы.
    Множество $E \subseteq V^2$ представляет связи между операциями:
    $(u, v) \in E$ тогда и только тогда, когда операция $v$ имеет своим
    аргументов результат операции $u$.

    На этом графе алгоритм и будет проводить анализ потока данных.

  \subsection{Базовые операции языка \texorpdfstring{\java}{Java}}
    \label{section:ir_ops}

    В таблице~\ref{tabular:basic_operations} приведен список базовых операций
    языка \java и их внутреннее представление для алгоритма анализа.
    Представление некоторых других операций будет дано в этом и последующих
    разделах, а семантика всех операций будет подробно описана в
    разделе~\todoref.

    \begin{table}[htb]
      \centering

      \begin{tabular}{|p{0.6\textwidth}|p{0.3\textwidth}|}\hline
        \textbf{\java операция} &
          \textbf{Внутреннее представление}\\ \hline

        получение формального параметра ссылочного типа
        & $a \gets \op{shared}$
        \\ \hline

        получение нулевого указателя
        & $a \gets \op{null}$
        \\ \hline

        \phi-функция ссылочного типа
        & $a \gets \op{phi}(b_1, \ldots, b_N)$
        \\ \hline

        создание нового объекта типа $\type{T}$
        & $a \gets \op{new}[\type{T}]$
        \\ \hline

        чтение поля ссылочного типа $\field{f}$ объекта $a$
        & $a \gets \op{getfield}[\field{f}](a)$
        \\ \hline

        чтение статического поля ссылочного типа $\sfield{T}{f}$
        & $a \gets \op{getstatic}[\sfield{T}{f}]$
        \\ \hline

        запись в поле $\field{f}$ объекта $a$ значения ссылочного типа $b$
        & $\op{putfield}[\field{f}](a, b)$
        \\ \hline

        запись в статическое поле $\sfield{T}{f}$ значения ссылочного типа $b$
        & $\op{putstatic}[\sfield{T}{f}](b)$
        \\ \hline

      \end{tabular}
      \caption{Базовые операции языка \java и их внутреннее представление}
      \label{tabular:basic_operations}
    \end{table}

    Заметим, что операция присваивания одной переменной в другую отсутствует.
    Это связано с тем, что для программы в SSA-форме все копии переменных
    тривиальным образом могут быть удалены~\cite{ssa}.

    Вызов метода с параметрами ссылочного типа $p_1, \ldots, p_N$, возвращающего
    значение ссылочного типа $a$ (параметры и возвращаемое значение могут
    отсутствовать) интерпретируется как пара операций:
    \begin{gather*}
      \op{escape}(p_1, \ldots, p_N), \\
      a \gets \op{shared}.
    \end{gather*}

    Чтение и запись $i$-го элемента массива консервативно преобразуется в
    работу с синтетическим полем $\field{elements}$, которое добавляется всем
    типам"=массивам.

  \subsection{Использование информации о типах}

    Учет строгой системы типов языка \java важен для проведения точного анализа
    указателей.

    Определим для каждой операции внутреннего представления, порождающей
    значение ссылочного типа, ее формальный тип
    (см.~таблицу~\ref{tabular:ops_types}).

    \begin{table}[htb]
      \centering

      \begin{tabular}{|p{0.3\textwidth}|p{0.6\textwidth}|}\hline
        \textbf{Операция} &
          \textbf{Формальный тип}\\ \hline

        $a \gets \op{null}$
        & $\type{NullType}$~--- искусственный тип, совместимый по
          присваиванию с любым ссылочным типом, что соответствует
          семантике операции
        \\ \hline

        $a \gets \op{phi}(b_1, \ldots, b_N)$
        & наибольшая нижняя грань множества типов $\{b_1, \ldots, b_N\}$
        \\ \hline

        $a \gets \op{new}[\type{T}]$
        & T
        \\ \hline

        $a \gets \op{getfield}[\field{f}](a)$
        & тип поля $\field{f}$
        \\ \hline

        $a \gets \op{getstatic}[\sfield{T}{f}]$
        & тип поля $\sfield{T}{f}$
        \\ \hline

      \end{tabular}
      \caption{Формальные типы операций внутреннего представления}
      \label{tabular:ops_types}
    \end{table}

    Для операции $\op{shared}$ формальный тип также может быть определен из
    свойств соответствующей ему \java операции.
    Добавим константный параметр, определяющий формальный тип:
    \[a \gets \op{shared}[\type{T}],\]
    где $\type{T}$~--- тип параметра, если операция соответствует
    получению формального параметра метода, или тип возвращаемого значения,
    если операция соответствует вызову.

    Рассмотрим еще одну операцию языка \java, операцию преобразования типа. При
    преобразовании типа выражения $x$ к типу $\type{T}$ происходит следующее:
    если значение выражения $x$ не совместимо по присваиванию с типом $T$,
    будет выброшено исключение во время исполнения.
    Поэтому в рамках алгоритма анализа можно считать, что результат
    преобразования всегда имеет формальный тип $T$.
    Введем соответствующую операцию внутреннего представления:
    \[ a \gets \op{cast}[\type{T}](x). \]

  \subsection{Повышение точности анализа}
    \label{section:increase_accuracy}

    В разделе~\ref{section:choosing_flow_insensitive} уже было замечено, что
    точность нечувствительного к потоку управления алгоритма может быть
    существенно ниже по сравнению с чувствительным к потоку управления
    алгоритмом.
    \todo{я хочу умолчать про то, что SSA-форма дает эффект строгих
    присваиваний, ибо сейчас я сразу формулирую все для SSA-формы. Это ок?}

    Для того чтобы понять, где же именно теряется точность, достаточно
    рассмотреть пример~\ref{code:insensitive_getfields}. В
    строках~\ref{code:insensitive_getfields:gf1}
    и~\ref{code:insensitive_getfields:gf2} находятся два чтения поля, которые
    для алгоритма, нечувствительного к потоку управления, абсолютно идентичны и
    результатом анализа будет то, что переменные $u$ и $v$ могут быть
    синонимами. Чувствительный к потоку управления алгоритм сможет в данном
    случае получить более точный результат за счет информации о том, что между
    чтениями данного поля была запись в него.

    \begin{algorithm}
      \caption{Два чтения различных значений из одного поля}
      \label{code:insensitive_getfields}
      \begin{algorithmic}[1]
        \State $a \gets \op{new}[\type{T}]$
        \State $x \gets \op{new}[\type{Object}]$
        \State $y \gets \op{new}[\type{Object}]$
        \State $\op{putfield}[\field{f}](a, x)$
        \State $u \gets \op{getfield}[\field{f}](a)$
          \label{code:insensitive_getfields:gf1}
        \State $\op{putfield}[\field{f}](a, y)$
        \State $v \gets \op{getfield}[\field{f}](a)$
          \label{code:insensitive_getfields:gf2}
      \end{algorithmic}
    \end{algorithm}

    Ключевым моментом является то, что благодаря информации о потоке
    управления, алгоритм может анализировать связи по памяти: какие модификации
    памяти могут влиять на какие чтения памяти. Нечувствительный к потоку
    управления алгоритм тоже мог бы учитывать эти связи, если бы они были явно
    выражены, как связи по значениям переменных.

    Далее опишем способ явного выражения зависимостей по памяти, который
    позволяет существенно повысить точность алгоритма.

  \subsection{\texorpdfstring{\M}{M}"=переменная и зависимости по памяти}

    Одним из способов выражения зависимостей по памяти является введение
    специальной переменной, представляющей образ всей памяти.

    Введем такую переменную, \emph{\M"=переменную}\footnote{
      От слова <<\eng{memory}>> (с англ. память).
    }.
    Значение этой переменной используется в качестве явного аргумента в
    операциях, читающих память, и является результатом операций, модифицирующих
    память. Так же наравне с обычными переменными \M"=переменная версионируется
    при переводе в SSA-форму и может быть аргументом и результатом
    \phi"=функций.

    Для наглядности можно рассмотреть
    пример~\ref{code:insensitive_getfields_with_m} с \M"=переменной, который
    эквивалентен примеру~\ref{code:insensitive_getfields}.

    \begin{algorithm}
      \caption{Два чтения различных значений из одного поля с \M"=переменной}
      \label{code:insensitive_getfields_with_m}
      \begin{algorithmic}[1]
        \State $a \gets \op{new}[\type{T}]$
        \State $x \gets \op{new}[\type{Object}]$
        \State $y \gets \op{new}[\type{Object}]$
        \State $\M_1 \gets \op{putfield}[\field{f}](\M_0, a, x)$
        \State $u \gets \op{getfield}[\field{f}](\M_1, a)$
        \State $\M_2 \gets \op{putfield}[\field{f}](\M_1, a, y)$
        \State $v \gets \op{getfield}[\field{f}](\M_2, a)$
      \end{algorithmic}
    \end{algorithm}

    Важно понимать, что на самом деле \M"=переменная является некоторой
    абстракцией памяти. Она не присутствует в явном виде в исходном коде
    программы и должна быть специально введена на некотором этапе компиляции
    программы. Аналогично эта переменная не имеет никакого физического
    воплощения в машинном коде и должна быть удалена перед кодогенерацией.

    Итого \M"=переменная позволяет явно выразить все зависимости по памяти
    между операциями. Для этого необходимо модифицировать набор операций
    внутреннего представления, описанных в разделе~\ref{section:ir_ops},
    следующим образом:
    \begin{itemize}
      \item операции $\op{getfield}, \op{getstatic}, \op{shared}$ первым
            аргументом принимают \M"=переменную;
      \item операции $\op{putfield}, \op{putstatic}, \op{escape}$
            первым аргументом принимают \M"=переменную и в качестве результата
            порождают \M"=переменную.
    \end{itemize}
    Дополнительно требуется ввести операцию, порождающую изначальное значение
    \M"=переменной:
    \[\M_0 \gets \op{initialmemory}.\]
    Эта операция добавляется в самое начало анализируемой программы.
    \todo{есть подозрения, про \M"=переменную можно рассказать больше. Воду
    лить не хочется, но тогда не понятно что же нужно}
    \todo{похвастаться, как M-переменная помогает анализировать поля утекающего
    объекта: до утекания результаты идеальные!}

  \subsection{Абстрактные объекты и значение \texorpdfstring{\M}{M}"=переменной}
    \label{section:ao_lattices}

    Определим потоковое свойство, с которым будет работать анализ потока
    данных.

    Определим множество \emph{абстрактных объектов}, которые являются
    целями указателей при проведении анализа.
    Такие объекты будем обозначать как $\AO{idx} \in AbstractObjects$;
    множество целей, на которые может указывать переменная ссылочного типа $x$,
    будем обозначать $\pts{x} \subseteq AbstractObjects$.

    Основным свойством абстрактных объектов является то, что два различных
    абстрактных объекта символизируют разные объекты в памяти при исполнении
    программы.
    Это позволяет определять возможность синонимичности двух
    выражений ссылочного типа $x$ и $y$ с совместимыми типами: они могут быть
    синонимами тогда и только тогда, когда $\pts{x} \cap \pts{y} \ne
    \emptyset$.

    Источниками абстрактных объектов служат операции создания новых объектов:
    каждой из таких операций сопоставляется заведомо уникальный абстрактный
    объект.
    Объекты, приходящие в метод извне (формальные параметры, результат вызова и
    др.), представляются с помощью одного специального абстрактного объекта
    $\AOGlobal$. Таким образом консервативно полагается, что все значения,
    приходящие извне анализируемого метода могут быть синонимами.

    Каждый абстрактный объект имеет точный тип (класс или массив). Тип
    абстрактного объекта, соответствующего операции создания нового объекта,
    определяется типом операции. Тип абстрактного объекта $\AOGlobal$ равен
    искусственному типу, который совместим по присваиванию с любым другим
    ссылочным типом (это необходимо для того, чтобы этот абстрактный объект мог
    быть целью выражения, имеющего произвольный формальный тип).

    Теперь рассмотрим более сложную \emph{\Ms"=структуру}, которая служит для
    выражения состояния памяти, значения \M"=переменной.
    Эта структура является кортежем из трех множеств:
    \[ \Ms = (\Mfield{fields}, \Mfield{statics}, \Mfield{shared}). \]
    Опишем каждое из этих множеств.

    Во-первых, \Ms"=структура содержит информацию о множестве целей полей
    абстрактных объектов:
    \[
      \Ms.\Mfield{fields} \subseteq
        (AbstractObjects \times InstanceFields) \times
        \powerset{AbstractObjects},
    \]
    где $InstanceFields$~--- это множество идентификаторов полей объектов,
    присутствующих в анализируемой программе.
    Аналогично хранится информация о множестве целей статических полей:
    \[
      \Ms.\Mfield{statics} \subseteq
        StaticFields \times \powerset{AbstractObjects},
    \]
    где $StaticFields$~--- это множество идентификаторов статических полей,
    присутствующих в анализируемой программе.
    Заметим, что эти множества можно рассматривать как
    отображения:
    \begin{gather*}
      \Ms.\Mfield{fields} \colon
        (AbstractObjects \times InstanceFields) \to
        \powerset{AbstractObjects}, \\
      \Ms.\Mfield{statics} \colon
        StaticFields \to \powerset{AbstractObjects}.
    \end{gather*}

    Во-вторых, \Ms"=структура содержит информацию о разделяемых объектах,
    то есть объектах, которые утекли \engdef{escaped} из анализируемого метода
    и могут быть прочитаны из произвольной разделяемой памяти. Множество
    разделяемых объектов есть подмножество множества абстрактных объектов:
    \[ \Ms.\Mfield{shared} \subseteq AbstractObjects. \]

    Для решения задачи анализа потока данных зададим полурешетку
    свойств\footnote{
      Полурешетки и их свойства подробно описаны в монографии
      Мучника~\cite{muchnick}.
    }
    \todo{что-нибудь более конкретное чем Мучник? Лично я читал Ахо
    <<Компиляторы>>, но это вроде как учебник, поэтому ссылаюсь на Мучника,
    хоть в нем и менее подробно.}
    операций, порождающих значение ссылочного типа:
    $\Lattice^{AO} = (\powerset{AbstractObjects}, \meet^{AO})$.
    Оператор $\meet^{AO}$ определим следующим образом
    \[
      \forall x \subseteq AbstractObjects, \forall y \subseteq AbstractObjects
      \colon
      x \meet^{AO} y = x \cup y,
    \]
    тогда отношения $\leq^{AO}$ и $<^{AO}$ имеют вид:
    \begin{align*}
      x \leq^{AO} y &\Leftrightarrow y \subseteq x, \\
      x <^{AO} y &\Leftrightarrow y \subset x.
    \end{align*}
    Соответственно нижний элемент $\bot^{AO} = AbstractObjects$
    и верхний элемент $\top^{AO} = \emptyset$.

    Заметим, что мощность множества абстрактных объектов для любого
    метода конечна и равна $M + 1$,
    где $M$~--- количество операций создания новых объектов, которое ограничено
    размером анализируемого метода.

    Из этого следует конечность множества значений свойств полурешетки
    $\Lattice^{AO}$, что дает конечную высоту полурешетки и гарантирует
    обрывание всех строго убывающих цепей.

    Заметим, что множества $InstanceFields$ и $StaticFields$ фиксированы и
    конечны в рамках одного метод.
    Тогда \Ms"=структуру можно представить как конечный кортеж подмножеств
    множества абстрактных объектов.
    Это позволяет определить полурешетку свойств операций, порождающих
    \M"=переменную, как конечное произведение полурешеток $\Lattice^{AO}$:
    \[\Lattice^M = (MemStructs, \meet^M) =
      \Lattice^{AO} \times \ldots \times \Lattice^{AO},\]
    где $MemStructs$~--- множество всех \Ms"=структур.

    Теперь можно определить общую полурешетку свойств для всех операций
    внутреннего представления:
    \[ \Lattice = (L, \meet) = \Lattice^{AO} \times \Lattice^M. \]

    Из конечной высоты полурешетки $\Lattice^{AO}$
    и обрывания в ней всех строго убывающих цепей следуют аналогичные свойства
    для решетки $\Lattice^M$ и, соответственно, для решетки $\Lattice$.

  \subsection{Анализ потока данных}

    Сформулируем понятие задачи анализа потока данных на графе зависимостей по
    данным.

    \emph{Граф зависимостей по данным}~--- это ориентированный граф
    $G = (V, E)$, где
    \begin{itemize}
      \item $V$~--- это множество операций программы, каждая из которых имеет
            результат и в качестве аргументов имеет результаты других операций
            из $V$,
      \item $E \subseteq V^2$~--- это множество, представляющее связи между
            операциями: $(u, v) \in E$ тогда и только тогда, когда операция $v$
            имеет своим аргументом результат операции $u$.
    \end{itemize}

    Выделим в этом графе множество \emph{входных} вершин,
    \[ V_{entry} = \{ v | v \in V, \lnot \exists u\colon (u, v) \in E \}. \]
    То есть это множество образуют операции, которые не зависят от других по
    данным.

    Далее рассматриваем некоторую полурешетку свойств $\Lattice = (L, \meet)$.

    \emph{Монотонной потоковой функцией} назовем функцию $f^N \colon L^N \to L$
    такую, что
    \begin{gather*}
      \forall i\colon 1 \leq i \leq N,
      \forall x_1, \ldots, x_{i-1}, x_{i+1}, \ldots, x_N, y, z \in L \colon
        y \leq z \Rightarrow \\
        \Rightarrow
        f(x_1, \ldots, x_{i-1}, y, x_{i+1}, \ldots, x_N) \leq
        f(x_1, \ldots, x_{i-1}, z, x_{i+1}, \ldots, x_N).
    \end{gather*}
    Также монотонность можно определить и следующим эквивалентным образом:
    \todo{точно не уверен, нужно ли это. Убрать?}
    \begin{gather*}
      \forall i\colon 1 \leq i \leq N,
      \forall x_1, \ldots, x_{i-1}, x_{i+1}, \ldots, x_N, y, z \in L \colon \\
        f(x_1, \ldots, x_{i-1}, y \meet z, x_{i+1}, \ldots, x_N) \leq \\
        \leq
        f(x_1, \ldots, x_{i-1}, y,         x_{i+1}, \ldots, x_N) \meet
        f(x_1, \ldots, x_{i-1}, z,         x_{i+1}, \ldots, x_N).
    \end{gather*}

    \emph{Задачей анализа потока данных} назовем кортеж $(G, \Lattice,
    \mathcal{F}, I, F)$ где
    \begin{itemize}
      \item $G = (V, E)$~--- граф зависимостей по данным с выделенным
            множеством входных вершин $V_{entry} \subseteq V$,
      \item $\Lattice = (L, \meet)$~--- полурешетка потоковых свойств конечной
            высоты с обрывающимися строго убывающими цепями,
      \item $\mathcal{F}$~--- множество монотонных потоковых функций,
      \item $I\colon V_{entry} \to L$~--- начальные значения потоковых свойств
            на входных вершинах,
      \item $F\colon (V \setminus V_{entry}) \to \mathcal{F}$~--- отображение
            вершин в монотонные потоковые функции.
    \end{itemize}

    Такая постановка задачи несколько отличается от классической постановки
    анализа потока данных~\cite{muchnick, nielson}, но может быть сведена к
    таковой введением более сложной полурешетки свойств.
    Соответственно итеративный алгоритм с небольшими модификациями подходит для
    решения этой задачи анализа, будет давать корректные результаты и
    гарантированно сходиться. Алгоритм приведен в разделе~\todoref.

    Теперь задачу анализа указателей можно сформулировать в терминах задачи
    анализа потока данных.

    Рассмотрим еще раз граф, введенный в разделе~\ref{section:dfg}.
    Необходимо заметить, что после введения \M"=переменной, все операции имеют
    некоторый результат: либо значение ссылочного типа, либо \M"=переменную.
    Таким образом этот граф является нужным графом зависимостей по данным $G$.
    Входными вершинами является множество вершин с операциями без аргументов
    ($\op{null}$, $\op{new}$, $\op{initialmemory}$).

    Полурешетка свойств для анализа указателей определена в
    разделе~\ref{section:ao_lattices}.

    Начальные значения потоковых свойств и потоковые функции описаны
    в разделе~\ref{section:flow_functions}.

  \subsection{Семантика операций}
    \label{section:flow_functions}

    \todo{это надо переписать}

    Ключевыми понятиями анализа являются абстрактные объекты и их множества.
    Абстрактные объекты будем обозначать буквой $O$; множество целей, на
    которые может указывать переменная $x$, будем обозначать $\pts{x}$.

    $AbstractObjects$~--- это множество всех абстрактных объектов. Оно
    состоит из уникальных объектов, соответствующих операциям создания
    объекта, и одного специального объекта $\AOGlobal$, который олицетворяет
    все объекты, созданные вне анализируемого метода.

    Для хранения результатов анализа вспомогательное внутреннее представление
    содержит информацию о множестве целей всех переменных ссылочного
    типа и информацию о состояниях памяти в виде структур, соответствующих
    версиям \M"=переменной.

    Опишем такую структуру, соответствующую \M"=переменной. Во-первых, она
    содержит информацию о множестве целей полей объектов:
    \[ \M.\Mfield{fields}\colon
      AbstractObjects \times InstanceFields \to
      \powerset{AbstractObjects},
    \]
    где $InstanceFields$~--- это множество идентификаторов полей
    объектов. Аналогично хранится информация о множестве целей статических
    полей:
    \[ \M.\Mfield{statics}\colon
      StaticFields \to \powerset{AbstractObjects},
    \]
    где $StaticFields$~--- это множество идентификаторов
    статических полей.

    Заметим, что, во-первых, эти отображения можно рассматривать как
    множества.  А во-вторых, эти отображения будут иметь умолчательное
    значение: если у нас не определено отображение для некоторого значения,
    то образ этого значения есть пустое множество.\todo{Мысль понятна, как
    переформулировать?}

    Во-вторых, \M"=переменная должна содержать информацию о разделяемых
    объектах и об объектах, которые утекут \engdef{escape} из метода и станут
    разделяемыми. Для представления этой информации хранится два множества
    объектов: объекты (\eng{shared}), которые утекли из метода и уже являются
    разделяемыми (консервативно предполагается, что эти объекты могут быть
    прочитаны из любой разделяемой памяти), и объекты (\eng{escaped}),
    которые утекли, но еще не являются разделяемыми.
    \[ \M.\Mfield{shared} \in \powerset{AbstractObjects}; \]
    \[ \M.\Mfield{escaped} \in \powerset{AbstractObjects}. \]

    Теперь опишем все операции, которые используются во вспомогательном
    внутреннем представлении.

    Исходное значение \M"=переменной  содержит пустые множества
    \Mfield{fields} и \Mfield{statics}, множество \Mfield{escaped} изначально
    также является пустым. Однако множество \Mfield{shared} содержит
    специальный объект
    $\AOGlobal$.
    \[\M \gets \op{initialmemory }\Rightarrow \]
    \[\begin{split}
      \M = \{ &\Mfield{fields} = \emptyset, \Mfield{statics} = \emptyset, \\
      &\Mfield{escaped} = \emptyset,
      \Mfield{shared} = \{\AOGlobal\}
    \}.
    \end{split}\]

    Утекание объектов моделируется операцией, которая добавляет данные
    объекты в множество \Mfield{escaped}, причем при добавлении в множество
    \Mfield{escaped} какого-либо объекта, добавляются в множество еще и все
    объекты, доступные через поля этого объекта.
    \[ \M' \gets \op{escape}(\M, a_1, \ldots, a_N) \Rightarrow \]
    \[\begin{split}
      \M' = \M, \text{кроме } \M'.\Mfield{escaped} =
        \M.\Mfield{escaped} \cup
        \mathcal{TC}_\M(\pts{a_1} \cup \ldots \cup \pts{a_N}),
    \end{split}\]
    где $\mathcal{TC}_\M(set)$~--- это транзитивное замыкание множества
    объектов и множеств целей их полей \engdef{transitive closure}.
    $\mathcal{TC}_\M(set)$ может быть вычислено следующим образом:
    \[\left\{\begin{aligned}
      &\mathcal{TC}_\M^0(set) = set; \\
      &\mathcal{TC}_\M^{i+1}(set) = \mathcal{TC}_\M^i(set) \cup
        \smashoperator{\bigcup_{\substack{O \in \mathcal{TC}_\M^i(set)\\
                           f \in InstanceFields}}}
          \M.\Mfield{fields}(O, f); \\
      &\mathcal{TC}_\M(set) =
        \bigcup_{i \in \mathbb{N}} \mathcal{TC}_\M^i(set).
    \end{aligned}\right.\]

    Специальное значение null соответствует пустому множеству целей
    переменной ссылочного типа:
    \[ x \gets \op{null }\Rightarrow
       \pts{x} = \emptyset. \]

    Создание нового объекта порождает уникальный абстрактный объект:
    \[ x \gets \op{new}(\type{T}) \Rightarrow
       \pts{x} = \{O_i\}. \]

    Чтение разделяемого объекта использует множество разделяемых объектов из
    \M"=переменной:
    \[ x \gets \op{shared}(\M) \Rightarrow
       \pts{x} = \M.\Mfield{shared}. \]

    Чтение статического поля возвращает множество всех разделяемых объектов в
    объединении с объектами, записанными непосредственно в это поле:
    \[ x \gets \op{getstatic}(\M, \sfield{T}{f}) \Rightarrow \]
    \[
      \pts{x} = \M.\Mfield{shared} \cup \M.\Mfield{statics}(\sfield{T}{f}).
    \]

    Запись в статическое поле $\sfield{T}{f}$ имеет более сложную семантику.
    Помимо изменения значения $\Mfield{statics}(\sfield{T}{f})$, записываемые
    объекты утекают, то есть добавляются в множество
    $\Mfield{escaped}$:
    \[ \M' \gets \op{putstatic}(\M, \sfield{T}{f}, x) \Rightarrow \]
    \[\begin{split}
      \M' = \M, \text{кроме }
        &\M'.\Mfield{statics}(\sfield{T}{f}) = \pts{x}, \\
        &\M'.\Mfield{escaped} = \M.\Mfield{escaped} \cup
        \mathcal{TC}_\M(\pts{x}).
    \end{split}\]
    Заметим, что в этом случае мы выполняем строгое присваивание, то есть мы
    не расширяем множество $\Mfield{statics}(\sfield{T}{f})$, а именно
    заменяем его новым множеством целей.

    Чтение поля из переменной $a$ возвращает множество объектов, записанных
    непосредственно в это поле. Однако, если переменная $a$ может указывать
    хоть на один разделяемый объект, то возвращаемое множество расширяется
    всеми разделяемыми объектами:
    \[ x \gets \op{getfield}(\M, a, \field{f}) \Rightarrow \]
    \[
      \pts{x} = \left( \bigcup_{O \in \pts{a}} \M.\Mfield{fields}(O,
      \field{f}) \right) \cup
      \begin{cases}
        \M.\Mfield{shared}, & \text{если } \pts{a} \cap
          \M.\Mfield{shared} \ne \emptyset; \\
        \emptyset, & \text{иначе}.
      \end{cases}
    \]

    Запись в поле $\field{f}$ переменной $a$ модифицирует значение памяти,
    расширяя множество целей $\Mfield{fields}(O, \field{f})$ для всех $O \in
    \pts{a}$, и если переменная $a$ может указывать хоть на один разделяемый
    объект, то записываемые объекты утекают. В этом случае мы не имеем права
    безусловно замещать множество целей $\Mfield{fields}(O, \field{f})$ для
    всех $O$, так как при исполнении программы реальная запись поля случится
    только для одного из объектов, но не для всех. Однако, последнее
    высказывание может подтолкнуть на мысль о том, что если множество целей
    $\pts{a} = \{O_i\}$, то есть содержит только один абстрактный объект,
    отличный от $\AOGlobal$, то мы можем установить множество
    $\Mfield{fields}(O_i, \field{f})$ равным $\pts{x}$.
    \[ \M' \gets \op{putfield}(\M, a, \field{f}, x) \Rightarrow \]
    \[\begin{split}
      \M' = \M,\ &\text{кроме} \\
        &\begin{split}
          \text{для всех } &O \in \pts{a}\colon
            \M'.\Mfield{fields}(O, \field{f}) =
            \pts{x}\ \cup \\
            &\cup
            \begin{cases}
              \M.\Mfield{fields}(O, \field{f}), & \text{если }
                |\pts{a}| > 1 \vee \pts{a} = \{\AOGlobal\};\\
              \emptyset, & \text{иначе},
            \end{cases}
        \end{split} \\
        &\begin{split}
          \M'.&\Mfield{escaped} = \M.\Mfield{escaped}\ \cup \\
          &\cup
            \begin{cases}
              \mathcal{TC}_\M(\pts{x}), & \text{если }
                \pts{a} \cap (\M.\Mfield{shared} \cup
                  \M.\Mfield{escaped}) \ne \emptyset;\\
              \emptyset, & \text{иначе}.
            \end{cases}
        \end{split}
    \end{split}\]

    В результате перевода программы в SSA-форму могут появиться \phi"=функции
    от переменных ссылочного типа и от \M"=переменных. Оба вида функций
    обладают довольно простой семантикой:
    \[ x \gets \op{phi}(a_1, \ldots, a_N) \Rightarrow
       \pts{x} = \bigcup_{i = 1}^N \pts{a_i}; \]
    \[ \M' \gets \op{phi}(\M_1, \ldots, \M_N) \Rightarrow \]
    \[\begin{split}
      \M' = \{
      &\Mfield{fields}(O, f) = \bigcup_{i = 1}^N \M_i.\Mfield{fields}(O, f), \\
      &\Mfield{statics}(f) = \bigcup_{i = 1}^N \M_i.\Mfield{statics}(f), \\
      &\Mfield{escaped} = \bigcup_{i = 1}^N \M_i.\Mfield{escaped}, \\
      &\Mfield{shared} = \bigcup_{i = 1}^N \M_i.\Mfield{shared}
      \}.
    \end{split}\]


  \subsection{Операции языка \texorpdfstring{\java}{Java}}

    При анализе указателей достаточно рассматривать далеко не все операции.
    Благодаря этому мы можем построить вспомогательное внутреннее
    представление только с необходимой и достаточной информацией о потоках
    данных и зависимостями по памяти.

    Приведем список всех рассматриваемых в рамках анализа указателей операций
    и их интерпретацию во вспомогательном внутреннем представлении.

    Не зависят от памяти две операции. Создание нового объекта типа
    $\type{T}$:
    \[ x \gets \op{new}(\type{T}), \]
    и присваивание специального значения null:
    \[ x \gets \op{null}. \]

    Изначальное состояние памяти (\M"=переменная) получается специальным
    образом:
    \[ \M_0 \gets \op{initialmemory}. \]
    Формальный параметр $p$ консервативно берется из разделяемой памяти
    \[ p \gets \op{shared}(\M_0). \]

    Чтение обычного поля $\field{f}$ из переменной $a$ использует
    \M"=переменную:
    \[ x \gets \op{getfield}(\M_i, a, \field{f}), \]
    аналогично имеем чтение статического поля $\sfield{T}{f}$:
    \[ x \gets \op{getstatic}(\M_i, \sfield{T}{f}). \]
    Запись переменной $x$ в обычное поле $\field{f}$ переменной $a$ порождает
    \M"=переменную:
    \[ \M_j \gets \op{putfield}(\M_i, a, \field{f}, x), \]
    аналогично порождает \M"=переменную запись в статическое поле
    $\sfield{T}{f}$:
    \[ \M_j \gets \op{putstatic}(\M_i, \sfield{T}{f}, x). \]

    Чтение и запись $i$-го элемента массива консервативно преобразуется в
    работу с синтетическим полем $\field{elements}$, которое добавляется всем
    типам"=массивам.

    Вызов функции с параметрами $p_0, \ldots, p_n$ и возвращаемым значением,
    которое записывается в переменную $x$, консервативно представляется
    следующим образом:
    \[\begin{aligned}
      \M_j &\gets \op{escape}(\M_i, p_0, \ldots, p_n); \\
      x    &\gets \op{shared}(\M_j).
    \end{aligned}\]
    Заметим, что в случае отсутствия возвращаемого значения, последнюю строку
    необходимо убрать.

    \todo{Привести пример как простенькая программа выглядит в такой
    терминологии}

  \section{Оптимизация удаления чтений полей}

    \todo{Описать проведение консервативного анализа.}

    \todo{Потом удаление чтений с учетом операций, приводящих к перечитыванию
    полей.}

    \todo{Потом можно повторять проведение анализа.}

    \todo{Привести пример, когда хитрое проведение анализа некорректно (разделение
    shared и escaped).}

  \sectionwithoutnumber{Заключение}

    Целью данной работы являлась разработка алгоритма анализа указателей и
    синонимов для языка \java, учитывающего особенности языка и его модели
    памяти.

    В ходе работы было сделано следующее:
    \begin{itemize}
      \item Проведен анализ существующих алгоритмов анализа указателей и
            синонимов, выделены их основные отличительные характеристики.
      \item Разработана схема выражения зависимостей между операциями
            работающими с памятью: все операции языка \java, работающие с
            памятью, были выражены через набор примитивных операций, работающих
            с \M"=переменной. Семантика этих операций подробно описана и
            согласована с моделью памяти языка.
      \item Разработан внутрипроцедурный, нечувствительный к потоку управления
            алгоритм анализа указателей, использующий \M"=переменную для
            выражения зависимостей по данным.
      \item Реализован алгоритма анализа указателей в рамках проекта
            \eng{Excelsior RVM} и оптимизация удаления избыточных чтений полей
            объектов, использующая результаты анализа.
    \end{itemize}

  \sectionwithoutnumber{Дальнейшая работа}

    В дальнейшем планируется реализовать представленный алгоритм анализа
    указателей в промышленном статическом компиляторе языка \java в
    рамках проекта \eng{Excelsior JET}. Потребуется проведение более
    тщательного комплексного тестирования и поддержки некоторых дополнительных
    возможностей компилятора, которые не вошли в данную работу.

    Также планируется дальнейшее усовершенствование алгоритма для
    проведения межпроцедурного анализа указателей.


  \newpage
  \bibliographystyle{../../common/gost71u2003}
  \bibliography{../../common/biblio}

\end{document}

