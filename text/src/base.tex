\documentclass[14pt,titlepage,draft]{extarticle}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PACKAGES
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage[pdftex,unicode,hidelinks,final]{hyperref}
\usepackage{ucs}
\usepackage[utf8x]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{indentfirst}

\usepackage{geometry}

\usepackage[usenames,dvipsnames]{color}

\usepackage{ifdraft}

\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{mathtools} % some extensions over amsmath

\usepackage{xspace} % for \xspace
\usepackage{hyphenat} % for \hyp
\usepackage{pbox}

\usepackage{footmisc}
\renewcommand{\footnotelayout}{\small}

\usepackage{etoolbox}
\apptocmd{\sloppy}{\hbadness 10000\relax}{}{}

\usepackage[obeyDraft, textwidth=2.5cm, textsize=footnotesize,
  backgroundcolor=orange!50, linecolor=black!50]{todonotes}

\usepackage{algorithm}
\usepackage{algpseudocode}
\floatname{algorithm}{Пример}
\newcommand{\algorithmictitle}[1]{\hspace{8mm}\textbf{#1}}

\usepackage{multicol}

\usepackage{cypokcommon}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% DOCUMENT-SPECIFIC COMMANDS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\input{../../gitinfo.tex}

\newcommand{\java}{\eng{Java}\xspace}

\newcommand{\M}{\mathbb{M}}
\newcommand{\Mhyp}{$\M$\hyp}
\newcommand{\Mfield}[1]{\ensuremath{\mathrm{#1}}}

\newcommand{\phihyp}{$\phi$\hyp}

\newcommand{\type}[1]{\mathrm{#1}}
\newcommand{\field}[1]{\mathrm{#1}}
\newcommand{\sfield}[2]{\type{#1}.\field{#2}}

\newcommand{\op}[1]{\mathbf{#1}}

\newcommand{\pts}[1]{\widebar{#1}}

\newcommand{\subsetbased}{\eng{subset\hyp{}based}\xspace}
\newcommand{\equalitybased}{\eng{equality\hyp{}based}\xspace}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% TEXT FORMAT
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\geometry{top=2cm,bottom=2cm,bindingoffset=0cm}
\ifdraft{
  \geometry{left=1cm,right=4cm}
}{
  \geometry{left=3cm,right=2cm}
}
\linespread{1.3}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% BODY
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{
  Применение анализа указателей и синонимов
  для оптимизации многопоточных программ
}
\author{
  Владимир Парфиненко
}

\begin{document}

  \thispagestyle{empty}
  \begin{center}
    \ifdraft{
      \
      \vspace{3cm}

      {\Large \scshape Черновик}

      \vspace{2cm}

      Курсовая работа

      \vspace{0.2cm}

      {\large Парфиненко Владимир Владимирович}

      \vspace{1.5cm}

      {\large \scshape \bfseries
        Применение анализа указателей и синонимов\\
        для оптимизации многопоточных программ
      }

      \vfill

      Git info

      \begin{table}[!htb]
        \centering
        \begin{tabular}{rp{0.5\textwidth}}
          sha1: & \texttt{\GitAbbrHash} \\
          title:& \GitSubject \\
          date: & \GitDate
        \end{tabular}
      \end{table}
    }{
      Министерство образования и науки\\
      Российской Федерации

      \vspace{0.7cm}

      Государственное образовательное учреждение\\
      высшего профессионального образования\\
      <<Новосибирский национальный исследовательский\\
      государственный университет>> (НГУ)

      \vspace{0.7cm}

      Механико\hyp{}математический факультет

      \vspace{0.2cm}

      Кафедра программирования

      \vspace{1.2cm}

      Курсовая работа

      \vspace{0.5cm}

      {\large Парфиненко Владимир Владимирович}

      \vspace{1.1cm}

      {\large \scshape \bfseries
        Применение анализа указателей и синонимов\\
        для оптимизации многопоточных программ
      }

      \vspace{2.5cm}


      \hfill\pbox{\textwidth}{
        Научные руководители:\\
        м.\,н.\,с.~ИСИ~СО~РАН, Павлов\,П.\,Е.\\
        зав.\,лаб.~ИСИ~СО~РАН, к.\,т.\,н.~Шелехов\,В.\,И.
      }

      \vfill

      Новосибирск 2012
    }
  \end{center}

  \listoftodos

  \tableofcontents

  \section{Анализ указателей и синонимов}

    Анализ указателей~--- это один из видов статического анализа, который
    позволяет определить, на какие объекты в памяти могут указывать выражения
    ссылочного типа в программе (такие объекты называются целями выражения
    ссылочного типа). Анализ синонимов похож на анализ указателей: его целью
    является определение, могут ли два разных выражения ссылаться на одно и
    то же место в памяти (такие выражения называют синонимами)~\cite{andersen}.

    \subsection{Классификация алгоритмов анализа указателей}
    \label{section:analysis_classification}

      Разные алгоритмы анализа указателей отличаются по точности, по скорости
      работы, по количеству памяти, необходимой для проведения анализа.
      Далее будут рассмотрены основные параметры алгоритмов, влияющие на эти
      характеристики.

      Для сравнения точности алгоритмов анализа указателей необходимо ввести
      некую меру точности. В качестве простой меры точности алгоритма часто
      используется усредненное количество синонимов для всех переменных
      ссылочного типа, появляющихся в
      программе~\cite[раздел~3.2]{hind_pointer_analysis_not_solved_yet}
      (также существуют и более изощренные
      меры~\cite{hind_pointer_analysis_not_solved_yet,diwan_tbaa}).

      Понятно, что для «идеального» алгоритма анализа это число будет
      минимальным, а для самого консервативного алгоритма максимальным.

      \subsubsection{Чувствительные к потоку данных алгоритмы}
        \label{section:analysis_classification_data_flow}

        Примером алгоритма, не учитывающего потоки данных в программе, может
        служить алгоритм анализа синонимов, основанный на типах, применимый
        для языков со строгой типизацией.
        \todo{подробнее про строгую систему типов?}
        Простейшая реализация такого алгоритма дает следующий результат:
        независимо от контекста и потоков данных в программе, два выражения
        могут быть синонимами, если они имеют совместимые формальные
        типы~\cite[раздел~2.2]{diwan_tbaa}.
        Такой алгоритм работает за константное время, но обладает очень низкой
        точностью.

        Большей точностью обладают алгоритмы анализа, которые учитывают потоки
        данных в программе.
        Например, если существует только одно присваивание переменной $v$ вида
        $v \gets \op{new}~\type{T}$, то можно гарантировать, что переменная $v$
        может указывать только на объект, созданный этим оператором \eng{new}.
        С присваиванием вида $v_1 \gets v_2$ ситуация сложнее. Рассмотрим
        пример~\ref{code:data_flow}.

        \begin{algorithm}
          \caption{Сравнение алгоритмов \subsetbased и
                                        \equalitybased типов}
          \label{code:data_flow}
          \begin{algorithmic}[1]
            \State $b \gets \op{new}~\type{T}$
            \State $c \gets \op{new}~\type{T}$
            \State $a \gets b$
            \State $a \gets c$
          \end{algorithmic}
        \end{algorithm}

        Цели указателя, то есть множество объектов, на которые может указывать
        переменная $p$ (или любое другое выражение ссылочного типа), для
        удобства обозначим как $\pts{p}$.
        Учитывая строки 1 и 2, для переменных $b$ и $c$ мы можем точно
        определить множество объектов, на которые они указывают:
        \[\pts{b} = \{O_1\},\ \pts{c} = \{O_2\},\]
        где $O_1$ и $O_2$~--- уникальные объекты в куче, соответствующие
        операторам \eng{new} в строках 1 и 2.  То есть мы учли поток данных от
        оператора \eng{new}, создавшего новый объект, в переменную.

        Интерпретировать присваивание $a \gets b$ можно двумя способами,
        и алгоритмы анализа разбиваются на два типа по этому признаку:
        \begin{itemize}
          \item алгоритмы первого типа накладывают ограничение
                $\pts{a} \supset \pts{b}$
                (\subsetbased алгоритмы)~\cite{andersen}
          \item алгоритмы второго типа накладывают ограничение
                $\pts{a} = \pts{b}$
                (\equalitybased алгоритмы)~\cite{steensgaard}
        \end{itemize}
        В нашем примере \subsetbased алгоритм получит, что
        \[\pts{a} = \{O_1, O_2\},\ \pts{b} = \{O_1\},\ \pts{c} = \{O_2\},\]
        а \equalitybased
        \[\pts{a} = \pts{b} = \pts{c} = \{O_1, O_2\}.\]
        Первый тип алгоритмов более точен, хотя его время работы в худшем
        случае кубически зависит от размера анализируемой программы.
        Второй тип алгоритмов работает за практически линейное время\footnote{
          Временная сложность \equalitybased алгоритма
          $O(N \alpha(N))$~\cite{steensgaard}, где $\alpha(N)$~--- обратная
          функция Аккермана. Она является очень медленно растущей, и при
          анализе асимптотики алгоритмов можно принять ее за константу.
        },
        предоставляя менее точные результаты.
        Каждый из этих алгоритмов имеет свою область применения, например,
        \subsetbased алгоритм имеет смысл использовать при анализе
        отдельного метода программы, в то время как \equalitybased лучше
        подходит для анализа всей программы целиком.


      \subsubsection{Чувствительные к потоку управления алгоритмы}
        \label{section:analysis_classification_control_flow}

        Также для повышения точности алгоритм анализа указателей может
        учитывать поток управления в программе.
        Рассмотрим пример~\ref{code:control_flow}.

        \begin{algorithm}
          \caption{Сравнение чувствительного и нечувствительного к потоку
                   управления алгоритмов}
          \label{code:control_flow}
          \begin{algorithmic}[1]
            \State $a \gets \op{new}~\type{T}$
            \State $b \gets \op{new}~\type{T}$
            \State $c \gets \op{new}~\type{T}$ \label{code:control_flow:before_gets}
            \State $a \gets b$ \label{code:control_flow:after_gets}
            \State $b \gets c$
            \State $c \gets a$ \label{code:control_flow:end}
          \end{algorithmic}
        \end{algorithm}

        Нечувствительный к потоку управления алгоритм анализа воспринимает
        программу как неупорядоченный набор операций.
        Для указанного примера такой алгоритм получит следующее
        \[\pts{a} = \pts{b} = \pts{c} = \{O_a, O_b, O_c\}.\]
        Этот результат не является особо точным, но зато он верен
        для любой точки программы.

        Чувствительный к потоку управления алгоритм получит следующие данные
        после строки~\ref{code:control_flow:before_gets}:
        \[\pts{a} = \{O_a\},\ \pts{b} = \{O_b\},\ \pts{c} = \{O_c\}.\]
        Далее, при анализе строки~\ref{code:control_flow:after_gets},
        присваивание будет интерпретировано как строгое присваивание%
        \footnote{Строгое присваивание \engdef{strong update}, по возможности,
        заменяет текущий набор целей указателей на новый, а не просто расширяет
        его.}%
        , то есть присваивание нового значения в переменную уничтожит
        информацию о том, что $a$ может указывать на $O_a$, и в итоге
        получится, что $\pts{a} = \{O_b\}$.
        Продолжая подобные рассуждения, алгоритм получит следующие результаты
        после строки~\ref{code:control_flow:end}:
        \[\pts{a} = \{O_b\},\ \pts{b} = \{O_c\},\ \pts{c} = \{O_b\}.\]
        Хотя такой алгоритм дает более точный результат, приходится хранить
        информацию о целях каждого указателя для каждой точки программы
        отдельно, что значительно увеличивает суммарный объем памяти,
        занимаемый результатами анализа.

      \subsubsection{Межпроцедурные алгоритмы}

        Алгоритм анализа может учитывать потоки данных не только внутри
        единственной анализируемой функции, но и между отдельными функциями,
        которые могут быть вызваны из анализируемой.
        Рассмотрим пример~\ref{code:interprocedural}.

        \begin{algorithm}
          \caption{Демонстрация работы межпроцедурного алгоритма}
          \label{code:interprocedural}
          \begin{algorithmic}[1]
            \Function{Some}{$x$, $y$}
              \State \Return $x$
            \EndFunction
            \Statex
            \State $b \gets \op{new}~\type{T}$
            \State $c \gets \op{new}~\type{T}$
            \State $a \gets$ \Call{Some}{$b$, $c$}
          \end{algorithmic}
        \end{algorithm}

        Наша задача понять, чему равно $\pts{a}$.
        Алгоритмы анализа можно разделить на две категории, в зависимости от
        того, как они обрабатывают вызовы функций:
        \begin{itemize}
          \item межпроцедурные алгоритмы анализа могут сначала проанализировать
                тело вызываемой функции, и затем учесть результат при обработке
                вызова,
          \item внутрипроцедурные алгоритмы рассматривают вызов функции в
                наиболее консервативном предположении: может быть возвращен
                либо один из параметров, либо один из глобальных объектов.
        \end{itemize}
        Понятно, что первый тип алгоритмов дает более точные результаты,
        а второй потребляет меньше памяти и работает
        быстрее~\cite[с.~117]{andersen}.
        В нашем примере межпроцедурный алгоритм анализа, проанализировав
        функцию \eng{Some}, запоминает, что для нее выполнено следующее условие
        на возвращаемое значение
        \[\pts{retval} = \pts{x},\]
        и тогда может сделать вывод, что \[\pts{a} = \pts{b} = \{O_1\}.\]
        В такой же ситуации внутрипроцедурный алгоритм анализа обязан сделать
        консервативное предположение
        \[\pts{a} = \pts{b} \cup \pts{c} = \{O_1, O_2\}.\]

  \section{Анализ многопоточных программ}
    \label{section:intro_to_multithreading}

    Компьютеры, в которых несколько процессоров взаимодействуют с
    использованием разделяемой памяти, разрабатываются с 1960-х годов, а
    сейчас они уже распространены повсеместно.

    С одной стороны, изначально доступ к общей памяти был строго
    последовательным для всех потоков, исполнявшихся на разных процессорах.
    Это приводило к тому, что два последовательных чтения в одном потоке из
    одного и того же места памяти могли давать разные результаты, так как в
    параллельном потоке могла быть совершена запись в эту же самую память в
    момент времени между последовательными чтениями в первом потоке.

    С другой стороны, со временем появились весьма изощренные техники
    повышения производительности работы с общей памятью: многоуровневые кэши,
    внеочередное исполнение \engdef{out-of-order execution} и другие.
    Это приводит к тому, что запись в память, произведенная одним потоком,
    может быть не видна другим. Или наоборот: запись может произойти раньше
    либо позже по сравнению со строго последовательным порядком исполнения.

    Рассмотрим пример~\ref{code:out_of_order_exec}, исполнение которого на
    современном процессоре может привести к неожиданному результату.
    Если изначально $obj.x = obj.y = 0$, то по окончанию работы примера
    значения переменных $x$ и $y$ могут равняться также нулю. Это связано с
    тем, что процессор при исполнении первого потока мог сначала выполнить
    вторую операцию, так как она не зависит от первой, аналогично при
    исполнении второго потока.

    \begin{algorithm}
      \caption{Нарушение логики программы при внеочередном исполнении}
      \label{code:out_of_order_exec}
      \begin{multicols}{2}
        \algorithmictitle{Поток 1}
        \begin{algorithmic}[1]
          \State $obj.x \gets 1$
          \State $y \gets obj.y$
        \end{algorithmic}
        \columnbreak
        \algorithmictitle{Поток 2}
        \begin{algorithmic}[1]
          \State $obj.y \gets 1$
          \State $x \gets obj.x$
        \end{algorithmic}
      \end{multicols}
    \end{algorithm}

    Получается, что если нет четкой семантики, определяющей, какие значения
    могут быть получены при чтении переменных из памяти, анализ указателей
    для них получится очень неточным\footnote{
      В такой ситуации алгоритму анализа придется делать очень консервативное
      предположение: считать, что все указатели, прочитанные из памяти, могут
      указывать на одни и те же данные и могут быть синонимами.
    } и не будет давать хоть сколько-нибудь полезной информации, что приведет
    к невозможности проведения большого количества оптимизирующих
    преобразований программы.

    На самом деле в большинстве систем есть определенные правила,
    регулирующие работу с памятью. Такие правила есть на уровне процессора,
    виртуальной машины и языка. Эти правила называют моделью памяти.
    Модель памяти для многопоточной системы определяет в каком
    порядке могут происходить доступы к памяти в программе и, как следствие,
    какие значения может возвращать конкретное чтение памяти. Соответственно,
    наличие четко определенной модели памяти позволяет разработать алгоритм
    анализа, пригодный для анализа многопоточных программ.

  \section{Предыдущие наработки}
    
    В рамках предыдущей работы на соискание степени
    бакалавра~\cite{my_bachelor} был разработан алгоритм анализа, целью
    которого был эффективный анализ многопоточных \java программ.
    Разработанный алгоритм являлся внутрипроцедурным, нечувствительным к
    потоку управления алгоритмом анализа указателей \subsetbased типа,
    работающим с программой в SSA-форме.

    Хотя алгоритм и был адаптирован для анализа многопоточных программ, в
    некоторых случаях его точность была неудовлетворительна. Рассмотрим
    некоторые примеры, когда алгоритм давал чересчур консервативные
    результаты.

    \subsection{Чувствительность алгоритма к потоку управления}

      Напомним, что точность чувствительного к потоку алгоритма во многом
      обусловлена эффектом строгих присваиваний. Для переменных верхнего уровня
      схожий эффект был достигнут благодаря переводу программы в SSA-форму, а
      для полей объектов анализ был полностью нечувствителен к потоку. То есть
      алгоритм интерпретировал все операции доступа к полям объектов как
      неупорядоченный набор, что приводило к низкой точности при работе с ними.
      Пример~\ref{code:bad_flow_sensitivity_1} демонстрирует это.

      \begin{algorithm}
        \caption{Отсутствие чувствительности к потоку управления при работе с
          полями объектов}
        \label{code:bad_flow_sensitivity_1}
        \begin{algorithmic}[1]
          \State $x \gets \op{new}~\type{T}$
          \State $x.f \gets \op{new}~\type{Object}$
          \State $a \gets x.f$
          \State $x.f \gets \op{new}~\type{Object}$
          \State $b \gets x.f$
        \end{algorithmic}
      \end{algorithm}

      В данном примере легко увидеть, что $a$ и $b$ ссылаются на заведомо
      разные объекты и не могут быть синонимами. Однако разработанный алгоритм
      получал консервативный результат:
      \[ \pts{x} = \{O_1\},\ \pts{a} = \pts{b} = \pts{x.f} = \{O_2, O_3\}. \]

      Пример~\ref{code:bad_flow_sensitivity_2} показывает другой случай, когда
      нечуствительность к потоку приводит к консервативному результату.

      \begin{algorithm}
        \caption{Отсутствие чувствительности к потоку управления при работе с
          разделяемой памятью}
        \label{code:bad_flow_sensitivity_2}
        \begin{algorithmic}[1]
          \State $a \gets \op{new}~\type{Object}$
          \State $b \gets$ \Call{GetFromShared}{}
          \State \Call{EscapeToShared}{$a$}
            \label{code:bad_flow_sensitivity_2:escape}
        \end{algorithmic}
      \end{algorithm}

      В данном примере значение $b$ получается до того, как созданный объект
      утекает через вызов в строке~\ref{code:bad_flow_sensitivity_2:escape}.
      Однако разработанный алгоритм опять же поведет себя максимально
      консервативным образом из-за того, что он не обладает информацией, что
      случилось раньше: получение значения для $b$ из разделяемой памяти или
      утекание переменной $a$.

    \subsection{Анализ многопоточных программ}
      
      В рамках изучения модели памяти \java было получено, что существует
      класс операций, приводящих к перечитыванию полей всех разделяемых
      объектов~\cite[раздел~5.3.1]{my_bachelor}. Эти операции обладают
      следующей семантикой: если мы дважды читаем одно и то же поле объекта и
      между этими чтениями нет операций, приводящих к перечитыванию полей всех
      разделяемых объектов, и нет операций записи в это поле, то модель памяти
      позволяет не считывать повторно значение из памяти, а использовать
      значение, полученное при первом чтении. Такими операциями являются
      чтение \eng{volatile} поля, вход в блок синхронизации и вызов метода.

      Разработанный алгоритм в случае наличия хотя бы одной такой операции при
      чтении поля любого разделяемого объекта выдавал информацию о том, что это
      поле может указывать на любой из разделяемых объектов. Такой подход
      является зачастую чересчур консервативным, особенно в случае, если
      перечитывание полей объектов случается в самом конце анализируемого
      метода. Рассмотрим пример~\ref{code:bad_multithreading}, демонстрирующий
      эту проблему.
      \todo{описать, в чем консерватизм}
      
      \begin{algorithm}
        \caption{Консерватизм при чтении полей разделяемых объектов}
        \label{code:bad_multithreading}
        \begin{algorithmic}[1]
          \State $x \gets \op{new}~\type{T}$
          \State $x.f \gets \op{new}~\type{Object}$
          \State $\type{T}.sfield \gets x$
            \Comment утекание $x$ в статическое поле класса
          \State $a \gets x.f$
          \State \Call{ReloadFields}{}
          \State $b \gets x.f$
        \end{algorithmic}
      \end{algorithm}


  \section{Постановка задачи}

    \ldots

  \section{Внутренее представление}

    Вспомогательное внутреннее представление содержит информацию только о
    переменных ссылочного типа и информацию о состоянии памяти в виде
    \Mhyp переменной.

    Ключевыми понятиями анализа являются абстрактные объекты и их множества.
    Абстрактные объекты будем обозначать буквой $O$; множество целей, на
    которые может указывать переменная $x$, будем обозначать $\pts{x}$.

    $AbstractObjects$~--- это множество всех абстрактных объектов. Оно
    состоит из уникальных объектов, соответствующих операциям создания объекта,
    и одного специального объекта $O_{global}$, который олицетворяет все
    объекты, созданные вне анализируемого метода.

    Опишем структуру \Mhyp{}переменной. Во\hyp{}первых, она содержит информацию о
    множестве целей полей объектов:
    \[ \M.\Mfield{fields}\colon
      AbstractObjects \times InstanceFieldDescs \to
      \powerset{AbstractObjects},
    \]
    где $InstanceFieldDescs$~--- это множество идентификаторов полей объектов.
    Аналогично хранится информация о множестве целей статических полей:
    \[ \M.\Mfield{statics}\colon
      StaticFieldDescs \to \powerset{AbstractObjects},
    \]
    где $StaticFieldDescs$~--- это множество идентификаторов
    статических полей.

    Заметим, что, во-первых, эти отображения можно рассматривать как множества.
    А во-вторых, эти отображения будут иметь умолчательное значение: если у нас
    не определено отображение для некоторого значения, то образ этого значения
    есть пустое множество.\todo{Мысль понятна, как переформулировать?}

    Во-вторых, \Mhyp переменная должна содержать информацию о разделяемых
    объектах и об объектах, которые утекут \engdef{escape} из метода и станут
    разделяемыми. Для представления этой информации хранится два множества
    объектов: объекты (\eng{shared}), которые утекли из метода и уже являются
    разделяемыми (консервативно предполагается, что эти объекты могут быть
    прочитаны из любой разделяемой памяти), и объекты (\eng{escaped}), которые
    утекли, но еще не являются разделяемыми.
    \[ \M.\Mfield{shared} \in \powerset{AbstractObjects}; \]
    \[ \M.\Mfield{escaped} \in \powerset{AbstractObjects}. \]

    Исходное значение \Mhyp переменной порождается с помощью операции
    $\op{initialmemory}$ и содержит пустые множества \Mfield{fields} и
    \Mfield{statics}, множество \Mfield{escaped} изначально также является
    пустым. Однако множество \Mfield{shared} содержит специальный объект
    $O_{global}$.
    \[\M \gets \op{initialmemory }\Rightarrow \]
    \[\begin{split}
      \M = \{ &\Mfield{fields} = \emptyset, \Mfield{statics} = \emptyset, \\
      &\Mfield{escaped} = \emptyset,
      \Mfield{shared} = \{O_{global}\}
    \}.
    \end{split}\]

    Утекание объектов моделируется операцией, которая добавляет данные объекты
    в множество \Mfield{escaped}, причем при добавлении в множество
    \Mfield{escaped} какого-либо объекта, добавляются в множество еще и все
    объекты, доступные через поля этого объекта.
    \[ \M' \gets \op{escape}(\M, a_1, \ldots, a_N) \Rightarrow \]
    \[\begin{split}
      \M' = \M, \text{кроме } \M'.\Mfield{escaped} =
        \M.\Mfield{escaped} \cup
        \mathcal{TC}_\M(\pts{a_1} \cup \ldots \cup \pts{a_N}),
    \end{split}\]
    где $\mathcal{TC}_\M(set)$~--- это транзитивное замыкание множества
    объектов и множеств целей их полей \engdef{transitive closure}.
    $\mathcal{TC}_\M(set)$ может быть вычислено следующим образом:
    \[\left\{\begin{aligned}
      &\mathcal{TC}_\M^0(set) = set; \\
      &\mathcal{TC}_\M^{i+1}(set) = \mathcal{TC}_\M^i(set) \cup
        \smashoperator{\bigcup_{\substack{O \in \mathcal{TC}_\M^i(set)\\
                           f \in InstanceFieldDescs}}}
          \M.\Mfield{fields}(O, f); \\
      &\mathcal{TC}_\M(set) =
        \bigcup_{i \in \mathbb{N}} \mathcal{TC}_\M^i(set).
    \end{aligned}\right.\]

    В соответствии с моделью памяти \java есть операции, которые приводят к
    перечитыванию памяти \todocite. При этом все утекшие объекты становятся
    разделяемыми.
    \[ \M' \gets \op{reload}(\M) \Rightarrow \]
    \[\begin{split}
      \M' = \M, \text{кроме }
        &\M'.\Mfield{shared} = \M.\Mfield{shared} \cup \M.\Mfield{escaped}, \\
        &\M'.\Mfield{escaped} = \emptyset.
    \end{split}\]

    Специальное значение null соответствует пустому множеству целей переменной
    ссылочного типа:
    \[ x \gets \op{null }\Rightarrow
       \pts{x} = \emptyset. \]

    Создание нового объекта порождает уникальный абстрактный объект:
    \[ x \gets \op{new}(\type{T}) \Rightarrow
       \pts{x} = \{O_i\}. \]

    Чтение разделяемого объекта использует множество разделяемых объектов из
    \Mhyp переменной:
    \[ x \gets \op{shared}(\M) \Rightarrow
       \pts{x} = \M.\Mfield{shared}. \]

    Чтение статического поля возвращает множество всех разделяемых объектов в
    объединении с объектами, записанными непосредственно в это поле:
    \[ x \gets \op{getstatic}(\M, \sfield{T}{f}) \Rightarrow \]
    \[
      \pts{x} = \M.\Mfield{shared} \cup \M.\Mfield{statics}(\sfield{T}{f}).
    \]

    Запись в статическое поле $\sfield{T}{f}$ имеет более сложную семантику.
    По-мимо изменения значения $\Mfield{statics}(\sfield{T}{f})$, записываемые
    объекты утекают, то есть добавляются в множество
    $\Mfield{escaped}$:
    \[ \M' \gets \op{putstatic}(\M, \sfield{T}{f}, x) \Rightarrow \]
    \[\begin{split}
      \M' = \M, \text{кроме }
        &\M'.\Mfield{statics}(\sfield{T}{f}) = \pts{x}, \\
        &\M'.\Mfield{escaped} = \M.\Mfield{escaped} \cup
        \mathcal{TC}_\M(\pts{x}).
    \end{split}\]
    Заметим, что в этом случае мы выполняем строгое присваивание, то есть мы не
    расширяем множество $\Mfield{statics}(\sfield{T}{f})$, а именно заменяем
    его новым множеством целей.

    Чтение поля из переменной $a$ возвращает множество объектов, записанных
    непосредственно в это поле. Однако, если переменная $a$ может указывать хоть
    на один раздеяляемый объект, то возвращаемое множество расширяется всеми
    разделяемыми объектами:
    \[ x \gets \op{getfield}(\M, a, \field{f}) \Rightarrow \]
    \[
      \pts{x} = \left( \bigcup_{O \in \pts{a}} \M.\Mfield{fields}(O,
      \field{f}) \right) \cup
      \begin{cases}
        \M.\Mfield{shared}, & \text{если } \pts{a} \cap \M.\Mfield{shared} \ne \emptyset;\\
        \emptyset, & \text{иначе}.
      \end{cases}
    \]

    Запись в поле $\field{f}$ переменной $a$ модифицирует значение памяти,
    расширяя множество целей $\Mfield{fields}(O, \field{f})$ для всех $O \in
    \pts{a}$, и если переменная $a$ может указывать хоть на один разделяемый
    объект, то записываемые объекты утекают. В этом случае мы не имеем права
    безусловно замещать множество целей $\Mfield{fields}(O, \field{f})$ для
    всех $O$, так как при исполнении программы реальная запись поля случится
    только для одного из объектов, но не для всех. Однако, последнее
    высказывание может подтолкнуть на мысль о том, что если множество целей
    $\pts{a} = \{O_i\}$, то есть содержит только один абстрактный объект,
    отличный от $O_{global}$, то мы можем установить множество
    $\Mfield{fields}(O_i, \field{f})$ равным $\pts{x}$.
    \[ \M' \gets \op{putfield}(\M, a, \field{f}, x) \Rightarrow \]
    \[\begin{split}
      \M' = \M,\ &\text{кроме} \\
        &\begin{split}
          \text{для всех } &O \in \pts{a}\colon
            \M'.\Mfield{fields}(O, \field{f}) =
            \pts{x}\ \cup \\
            &\cup
            \begin{cases}
              \M.\Mfield{fields}(O, \field{f}), & \text{если }
                |\pts{a}| > 1 \vee \pts{a} = \{O_{global}\};\\
              \emptyset, & \text{иначе},
            \end{cases}
        \end{split} \\
        &\begin{split}
          \M'.&\Mfield{escaped} = \M.\Mfield{escaped}\ \cup \\
          &\cup
            \begin{cases}
              \mathcal{TC}_\M(\pts{x}), & \text{если }
                \pts{a} \cap (\M.\Mfield{shared} \cup \M.\Mfield{escaped}) \ne \emptyset;\\
              \emptyset, & \text{иначе}.
            \end{cases}
        \end{split}
    \end{split}\]

    В результате перевода программы в SSA-форму могут появиться \phihyp функции
    от переменных ссылочного типа и от \Mhyp переменных. Оба вида функций
    обладают довольно простой семантикой:
    \[ x \gets \op{phi}(a_1, \ldots, a_N) \Rightarrow
       \pts{x} = \bigcup_{i = 1}^N \pts{a_i}; \]
    \[ \M' \gets \op{phi}(\M_1, \ldots, \M_N) \Rightarrow \]
    \[\begin{split}
      \M' = \{
      &\Mfield{fields}(O, f) = \bigcup_{i = 1}^N \M_i.\Mfield{fields}(O, f), \\
      &\Mfield{statics}(f) = \bigcup_{i = 1}^N \M_i.\Mfield{statics}(f), \\
      &\Mfield{escaped} = \bigcup_{i = 1}^N \M_i.\Mfield{escaped}, \\
      &\Mfield{shared} = \bigcup_{i = 1}^N \M_i.\Mfield{shared}
      \}.
    \end{split}\]


  \section{Операции языка Java}

    При анализе указателей достаточно рассматривать далеко не все операции.
    Благодаря этому мы можем построить вспомогательное внутреннее представление
    только с необходимой и достаточной информацией о потоках данных и
    зависимостями по памяти.

    Приведем список всех рассматриваемых в рамках анализа указателей операций и
    их интерпретацию в вспомогательном внутреннем представлении.

    Не зависят от памяти две операции. Создание нового объекта типа $\type{T}$:
    \[ x \gets \op{new}(\type{T}), \]
    и присваивание специального значения null:
    \[ x \gets \op{null}. \]

    Изначальное состояние памяти (\Mhyp переменная) получается специальным
    образом:
    \[ \M_0 \gets \op{initialmemory}. \]
    Формальный параметр $p$ консервативно берется из разделяемой памяти
    \[ p \gets \op{shared}(\M_0). \]

    Чтение обычного поля $\field{f}$ из переменной $a$ использует
    \Mhyp переменную:
    \[ x \gets \op{getfield}(\M_i, a, \field{f}), \]
    аналогично имеем чтение статического поля $\sfield{T}{f}$:
    \[ x \gets \op{getstatic}(\M_i, \sfield{T}{f}). \]
    Запись переменной $x$ в обычное поле $\field{f}$ переменной $a$ порождает
    \Mhyp переменную:
    \[ \M_j \gets \op{putfield}(\M_i, a, \field{f}, x), \]
    аналогично порождает \Mhyp переменную запись в статическое поле
    $\sfield{T}{f}$:
    \[ \M_j \gets \op{putstatic}(\M_i, \sfield{T}{f}, x). \]

    Чтение и запись $i$-го элемента массива консервативно преобразуется в
    работу с синтетическим полем $\field{elements}$, которое добавляется всем
    типам\hyp{}массивам.

    Вызов функции с параметрами $p_0, \ldots, p_n$ и возвращаемым значением,
    которое записывается в переменную $x$, консервативно представляется
    следующим образом:
    \[\begin{aligned}
      \M_j &\gets \op{escape}(\M_i, p_0, \ldots, p_n); \\
      \M_k &\gets \op{reload}(\M_j); \\
      x  &\gets \op{shared}(\M_k).
    \end{aligned}\]
    Заметим, что в случае отсутствия возращаемого значения, последнюю строку
    необходимо убрать.

    В соответствии с моделью памяти языка \java, необходимо перечитывать
    значения полей объектов перед чтением \eng{volatile} полей и при входе в
    блок синхронизации:
    \[ \M_j \gets \op{reload}(\M_i). \]

    \todo{Привести пример как простенькая программа выглядит в такой
    терминологии}

  \newpage
  \bibliography{../../biblio}

\end{document}

