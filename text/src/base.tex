\documentclass[14pt,titlepage,draft]{extarticle}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PACKAGES
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage[pdftex,unicode,hidelinks]{hyperref}
\usepackage{ucs}
\usepackage[utf8x]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{indentfirst}
\usepackage[usenames,dvipsnames]{color}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{multicol}
\usepackage{rotating}
\usepackage{array}
\usepackage{multirow}
\usepackage{xspace}
\usepackage{subfig}
\usepackage{amsthm}
\usepackage{hyphenat} % for \hyp
\usepackage{ifdraft}

% gnuplot & lua should be installed,
% this *.sty file is generated by `lua %GNUPLOT%/lua/gnuplot-tikz.lua style`
\usepackage{gnuplot-lua-tikz}

\ifdraft{
  \usepackage[left=1cm,right=4cm,top=2cm,bottom=2cm,bindingoffset=0cm]{geometry}
}{
  \usepackage[left=3cm,right=2cm,top=2cm,bottom=2cm,bindingoffset=0cm]{geometry}
}
\linespread{1.3}

\usepackage{numprint}
\newcommand{\num}[1]{\numprint{#1}}
  \npthousandsep{\,}
  \npthousandthpartsep{}
  \npdecimalsign{,}

\usepackage{tikz}
\usetikzlibrary{positioning,arrows,shapes}

\usepackage{footmisc}
\renewcommand{\footnotelayout}{\small}

\usepackage{etoolbox}
\apptocmd{\sloppy}{\hbadness 10000\relax}{}{}

\usepackage{datetime} % used by bibliography

\usepackage[obeyDraft, textwidth=2.5cm, textsize=footnotesize,
  backgroundcolor=orange!50, linecolor=black!50]{todonotes}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% MY COMMANDS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% bibliography style:
\newcommand{\usedate}[3]{({\Russian дата обращения: \formatdate{#1}{#2}{#3}})}
\bibliographystyle{gost71u2003} % can be found in the root of repo

% widebar
% from mathabx.sty and mathabx.dcl
\DeclareFontFamily{U}{mathx}{\hyphenchar\font45}
\DeclareFontShape{U}{mathx}{m}{n}{
      <5> <6> <7> <8> <9> <10>
      <10.95> <12> <14.4> <17.28> <20.74> <24.88>
      mathx10
      }{}
\DeclareSymbolFont{mathx}{U}{mathx}{m}{n}
\DeclareFontSubstitution{U}{mathx}{m}{n}
\DeclareMathAccent{\widebar}{0}{mathx}{"73}

%\setcounter{tocdepth}{2} % глубина оглавления

\newcommand{\M}{\ensuremath{\mathbb{M}}}
\newcommand{\Mfield}[1]{\textrm{#1}}
\newcommand{\Mhyp}{$\mathbb{M}$\hyp}

\newcommand{\NEW}{\textbf{new}}
\newcommand{\NULL}{\textbf{null}}
\newcommand{\INITIALMEMORY}{\textbf{initialmemory}}
\newcommand{\GETFIELD}{\textbf{getfield}}
\newcommand{\PUTFIELD}{\textbf{putfield}}
\newcommand{\GETSTATIC}{\textbf{getstatic}}
\newcommand{\PUTSTATIC}{\textbf{putstatic}}
\newcommand{\ESCAPE}{\textbf{escape}}
\newcommand{\SHARED}{\textbf{shared}}
\newcommand{\RELOAD}{\textbf{reload}}
\newcommand{\PHI}{\textbf{phi}}

\newcommand{\pts}[1]{\widebar{#1}}

\newcommand{\Type}[1]{\textrm{Type}(#1)}
\newcommand{\IsAssignable}[2]{\textrm{IsAssignable}(#1, #2)}
\newcommand{\Pts}[1]{\textrm{Pts}(#1)}
\newcommand{\OFPts}[2]{\overline{#1.#2}}
\newcommand{\Shared}{\overline{shared}}
\newcommand{\Filter}[2]{\textrm{Filter}_{#1}(#2)}
\newcommand{\cupe}{\,\cup\!\!=}

\let\oldphi\phi
\renewcommand{\phi}{\ensuremath{\oldphi}}

\renewcommand{\emptyset}{\varnothing}
\newcommand{\powerset}[1]{\mathcal{P}(#1)}

\renewcommand{\leq}{\leqslant}
\renewcommand{\geq}{\geqslant}
\newcommand{\incomp}{\not\lessgtr}

\newcommand\Set[2]{\left\{ #1 \mid #2 \right\}}

%\let\oldtodo\todo
%\renewcommand{\todo}[2][]{\oldtodo[#1]{TODO: #2}}%
\newcommand{\todocite}[1]{%
  \todo[backgroundcolor=blue!20]{citation?}}

\newcommand{\eng}[1]{{\English#1}}
\newcommand{\engdef}[1]{(англ.~\eng{#1})}

\addto\captionsrussian{
  \let\oldrefname\refname
  \renewcommand\refname{\addcontentsline{toc}{section}{\oldrefname}\oldrefname}
}

% русские нумераторы
\renewcommand{\theenumii}{(\asbuk{enumii})}
\renewcommand{\labelenumii}{\asbuk{enumii})}
\renewcommand{\thesubfigure}{\asbuk{subfigure}}


% обёртка с моими настройками поверх figure:
% \begin{myfigure}{подпись}{label} ... \end{myfigure}
\newenvironment{myfigure}[2]%
  {\pushQED{\caption{#1} \label{#2}} % push caption & label
   \begin{figure}[!htb]\centering } %
  {  \popQED % pop caption & label
   \end{figure}}
\newenvironment{myplot}[2]%
  {\pushQED{\caption{#1} \label{#2}} % push caption & label
   \begin{figure}[p]\centering\small } %
  {  \popQED % pop caption & label
   \end{figure}}

%\newcommand{\inputplot}[1]{\input{#1}}
\newcommand{\inputplot}[1]{Here would be plot}

\let\oldsection\section
\renewcommand{\section}{\newpage\oldsection}

\newcommand{\sectionwithoutnumber}[1]{
  \section*{#1}
  \addcontentsline{toc}{section}{#1}
}

\newcommand{\java}{\eng{Java}\xspace}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% BODY
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{
  Применение анализа указателей и синонимов
  для оптимизации многопоточных программ
}
\author{
  Владимир Парфиненко
}

\begin{document}

  \thispagestyle{empty}
  \begin{center}
    \ifdraft{
      \
      \vspace{6cm}

      Курсовая работа

      \vspace{0.2cm}

      Парфиненко Владимир Владимирович

      \vspace{1.5cm}

      \textbf{
        ПРИМЕНЕНИЕ АНАЛИЗА УКАЗАТЕЛЕЙ И СИНОНИМОВ\\
        ДЛЯ ОПТИМИЗАЦИИ МНОГОПОТОЧНЫХ ПРОГРАММ
      }

      \vspace{3.5cm}

      Черновик от \today

      Git: \input{../../gitinfo.txt}
    }{
      Министерство образования и науки\\
      Российской Федерации

      \vspace{0.7cm}

      Государственное образовательное учреждение\\
      высшего профессионального образования\\
      <<Новосибирский национальный исследовательский\\
      государственный университет>> (НГУ)

      \vspace{0.7cm}

      Механико-математический факультет

      \vspace{0.2cm}

      Кафедра программирования

      \vspace{1.2cm}

      Курсовая работа

      \vspace{0.2cm}

      ПАРФИНЕНКО Владимир Владимирович

      \vspace{1.5cm}

      \textbf{
        ПРИМЕНЕНИЕ АНАЛИЗА УКАЗАТЕЛЕЙ И СИНОНИМОВ\\
        ДЛЯ ОПТИМИЗАЦИИ МНОГОПОТОЧНЫХ ПРОГРАММ
      }

      \vspace{2.5cm}

      \begin{flushright}

        Научные руководители

        м.\,н.\,с.~ИСИ~СО~РАН, Павлов\,П.\,Е.\\
        зав.\,лаб.~ИСИ~СО~РАН, к.\,т.\,н.~Шелехов\,В.\,И.

      \end{flushright}

      \vspace {4cm}

      Новосибирск 2012
    }
  \end{center}

  \listoftodos

  \tableofcontents

  \sectionwithoutnumber{Внутренее представление}

    Вспомогательное внутреннее представление содержит информацию только о
    переменных ссылочного типа и информацию о состоянии памяти в виде
    \Mhyp переменной.

    Ключевыми понятиями анализа являются абстрактные объекты и их множества.
    Абстрактные объекты будем обозначать буквой $O$; множество целей, на
    которые может указывать переменная $x$, будем обозначать $\pts{x}$.

    \textrm{AbstractObjects}~--- это множество всех абстрактных объектов. Оно
    состоит из уникальных объектов, соответствующих операциям создания объекта,
    и одного специального объекта $O_{global}$, который олицетворяет все
    объекты, созданные вне анализируемого метода.

    Опишем структуру \Mhyp переменной. Во-первых, она содержит информацию о
    множестве целей полей объектов:
    \[ \M.\Mfield{fields}\colon
      \textrm{AbstractObjects} \times \textrm{InstanceFieldDescs} \to
      \powerset{\textrm{AbstractObjects}},
    \]
    где $\textrm{InstanceFieldDescs}$~--- это множество идентификаторов полей
    объектов.
    Аналогично хранится информация о множестве целей статических полей:
    \[ \M.\Mfield{statics}\colon
      \textrm{StaticFieldDescs} \to
      \powerset{\textrm{AbstractObjects}},
    \]
    где $\textrm{StaticFieldDescs}$~--- это множество идентификаторов
    статических полей.

    Заметим, что, во-первых, эти отображения можно рассматривать как множества.
    А во-вторых, эти отображения будут иметь умолчательное значение: если у нас
    не определено отображение для некоторого значения, то образ этого значения
    есть пустое множество.\todo{Мысль понятна, как переформулировать?}

    Во-вторых, \Mhyp переменная должна содержать информацию о разделяемых
    объектах и об объектах, которые утекут \engdef{escape} из метода и станут
    разделяемыми. Для представления этой информации хранится два множества
    объектов: объекты (\eng{shared}), которые утекли из метода и уже являются
    разделяемыми (то есть могут быть прочитаны из статических полей, возвращены
    из вызванного метода и так далее), и объекты (\eng{escaped}), которые
    утекли, но которые еще не являеются разделяемыми (то есть не могут быть
    прочитаны из статических полей и так далее).
    \[\begin{aligned}
      &\M.\Mfield{shared} \in \powerset{\textrm{AbstractObjects}}; \\
      &\M.\Mfield{escaped} \in \powerset{\textrm{AbstractObjects}}.
    \end{aligned}\]

    Исходное значение \Mhyp переменной порождается с помощью операции
    $\INITIALMEMORY$ и содержит пустые множества \Mfield{fields} и
    \Mfield{statics}, множество \Mfield{escaped} изначально также является
    пустым. Однако множество \Mfield{shared} содержит специальный объект
    $O_{global}$.
    \[\M \leftarrow \INITIALMEMORY \Rightarrow \]
    \[\begin{split}
      \M = \{ &\Mfield{fields} = \emptyset, \Mfield{statics} = \emptyset, \\
      &\Mfield{escaped} = \emptyset,
      \Mfield{shared} = \{O_{global}\}
    \}.
    \end{split}\]

    Утекание объектов моделируется операцией, которая просто добавляет объекты
    в множество \Mfield{escaped}:
    \[ \M' \leftarrow \ESCAPE(\M, a_1, \ldots, a_N) \Rightarrow \]
    \[\begin{split}
      \M' = \M, \text{кроме } \M'.\Mfield{escaped} =
        \M.\Mfield{escaped} \cup
        \mathcal{TC}_\M(\pts{a_1} \cup \ldots \cup \pts{a_N}),
    \end{split}\]
    где $\mathcal{TC}_\M(set)$~--- это транзитивное замыкание множества
    объектов и множеств целей их полей \engdef{transitive closure}.
    $\mathcal{TC}_\M(set)$ может быть вычислено следующим образом:
    \[\left\{\begin{aligned}
      &\mathcal{TC}_\M^0(set) = set; \\
      &\mathcal{TC}_\M^{i+1}(set) = \mathcal{TC}_\M^i(set) \cup
       \left(
        \bigcup_{\substack{O \in \mathcal{TC}_\M^i(set)\\
                           f \in \textrm{InstanceFieldDesc}}}
          \M.\Mfield{fields}(O, f)
       \right); \\
      &\mathcal{TC}_\M(set) =
        \bigcup_{i \in \mathbb{N}} \mathcal{TC}_\M^i(set).
    \end{aligned}\right.\]

    В соответствии с моделью памяти \java есть операции, которые приводят к
    перечитыванию памяти \todocite. При этом все утекшие объекты становятся
    разделяемыми.  И более того, все объекты, которые доступны через поля
    разделяемых объектов, также становятся разделяемыми.
    \[ \M' \leftarrow \RELOAD(\M) \Rightarrow \]
    \[\begin{split}
      \M' = \M, \text{кроме }
        &\M'.\Mfield{shared} = \M.\Mfield{shared} \cup \M.\Mfield{escaped}, \\
        &\M'.\Mfield{escaped} = \emptyset.
    \end{split}\]

    Специальное значение null соответствует пустому множеству целей переменной
    ссылочного типа:
    \[ x \leftarrow \NULL \Rightarrow
       \pts{x} = \emptyset. \]

    Создание нового объекта порождает уникальный абстрактный объект:
    \[ x \leftarrow \NEW(\textrm{T}) \Rightarrow
       \pts{x} = \{O_i\}. \]

    Чтение разделяемого объекта использует множество разделяемых объектов из
    \Mhyp переменной:
    \[ x \leftarrow \SHARED(\M) \Rightarrow
       \pts{x} = \M.\Mfield{shared}. \]

    Чтение статического поля возвращает множеством всех разделяемых объектов в
    объединении с объектами, записанными непосредственно в это поле:
    \[ x \leftarrow \GETSTATIC(\M, \textrm{T.f}) \Rightarrow \]
    \[
      \pts{x} = \M.\Mfield{shared} \cup \M.\Mfield{statics}(\textrm{T.f}).
    \]

    Запись в статическое поле \textrm{T.f} имеет более сложную семантику.
    По-мимо изменения значения $\Mfield{statics}(\textrm{T.f})$, записываемые
    объекты утекают, то есть добавляются в множество $\Mfield{escaped}$:
    \[ \M' \leftarrow \PUTSTATIC(\M, \textrm{T.f}, x) \Rightarrow \]
    \[\begin{split}
      \M' = \M, \text{кроме }
        &\M'.\Mfield{statics}(\textrm{T.f}) = \pts{x}, \\
        &\M'.\Mfield{escaped} = \M.\Mfield{escaped} \cup
        \mathcal{TC}_\M(\pts{x}).
    \end{split}\]
    Заметим, что в этом случае мы выполняем, так называемый, \eng{strong
    update}, то есть мы не расширяем множество $\Mfield{statics}(\textrm{T.f})$,
    а именно заменяем его новым множеством целей.

    Чтение поля из переменной $a$ возвращает множеством объектов, записанных
    непосредственно в это поле. Однако, если переменная $a$ может указывать хоть
    на один раздеяляемый объект, то возвращаемое множество расширяется всеми
    разделяемыми объектами:
    \[ x \leftarrow \GETFIELD(\M, a, \textrm{f}) \Rightarrow \]
    \[
      \pts{x} = \left( \bigcup_{O \in \pts{a}} \M.\Mfield{fields}(O,
      \textrm{f}) \right) \cup
      \begin{cases}
        \M.\Mfield{shared}, & \text{если } \pts{a} \cap \M.\Mfield{shared} \ne \emptyset;\\
        \emptyset, & \text{иначе}.
      \end{cases}
    \]

    Запись в поле $\textrm{f}$ переменной $a$ модифицирует значение памяти,
    расширяя множество целей $\Mfield{fields}(O, \textrm{f})$ для всех $O \in
    \pts{a}$, и если переменная $a$ может указывать хоть на один разделяемый
    объект, то записываемые объекты утекают. В этом случае мы не имеем права
    безусловно замещать множество целей $\Mfield{fields}(O, \textrm{f})$ для
    всех $O$, так как при исполнении программы реальная запись поля случится
    только для одного из объектов, но не для всех. Однако, последнее
    высказывание может подтолкнуть на мысль о том, что если множество целей
    $\pts{a} = \{O_i\}$, то есть содержит только один абстрактный объект,
    отличный от $O_{global}$, то мы можем установить множество
    $\Mfield{fields}(O_i, \textrm{f})$ равным $\pts{x}$.
    \[ \M' \leftarrow \PUTFIELD(\M, a, \textrm{f}, x) \Rightarrow \]
    \[\begin{split}
      \M' = \M,\ &\text{кроме} \\
        &\begin{split}
          \text{для всех } &O \in \pts{a}\colon
            \M'.\Mfield{fields}(O, \textrm{f}) =
            \pts{x}\ \cup \\
            &\cup
            \begin{cases}
              \M.\Mfield{fields}(O, \textrm{f}), & \text{если }
                |\pts{a}| > 1 \vee \pts{a} = \{O_{global}\};\\
              \emptyset, & \text{иначе},
            \end{cases}
        \end{split} \\
        &\begin{split}
          \M'.&\Mfield{escaped} = \M.\Mfield{escaped}\ \cup \\
          &\cup
            \begin{cases}
              \mathcal{TC}_\M(\pts{x}), & \text{если }
                \pts{a} \cap (\M.\Mfield{shared} \cup \M.\Mfield{escaped}) \ne \emptyset;\\
              \emptyset, & \text{иначе}.
            \end{cases}
        \end{split}
    \end{split}\]

    В результате перевода программы в SSA-форму могут появиться \phi-функции от
    переменных ссылочного типа и от \Mhyp переменных. Оба вида функций обладают
    довольно простой семантикой:
    \[ x \leftarrow \PHI(a_1, \ldots, a_N) \Rightarrow
       \pts{x} = \bigcup_{i = 1}^N \pts{a_i}; \]
    \[ \M' \leftarrow \PHI(\M_1, \ldots, \M_N) \Rightarrow \]
    \[\begin{split}
      \M' = \{
      &\Mfield{fields}(O, f) = \bigcup_{i = 1}^N \M_i.\Mfield{fields}(O, f), \\
      &\Mfield{statics}(f) = \bigcup_{i = 1}^N \M_i.\Mfield{statics}(f), \\
      &\Mfield{escaped} = \bigcup_{i = 1}^N \M_i.\Mfield{escaped}, \\
      &\Mfield{shared} = \bigcup_{i = 1}^N \M_i.\Mfield{shared}
      \}.
    \end{split}\]


  \sectionwithoutnumber{Операции языка Java}

    При анализе указателей достаточно рассматривать далеко не все операции.
    Тогда мы можем построить вспомогательное внутреннее представление только с
    необходимой и достаточной информацией о потоках данных и зависимостями по
    памяти.

    Приведем список всех рассматриваемых в рамках анализа указателей операций и
    их интерпретацию в вспомогательном внутреннем представлении.

    Не зависят от памяти две операции. Создание нового объекта типа
    $\textrm{T}$:
    \[ x \leftarrow \NEW(\textrm{T}), \]
    и присваивание специального значения null:
    \[ x \leftarrow \NULL. \]

    Изначальное состояние памяти (\Mhyp переменная) получается специальным
    образом:
    \[ \M_0 \leftarrow \INITIALMEMORY. \]
    Формальный параметр $p$ консервативно берется из разделяемой памяти
    \[ p \leftarrow \SHARED(\M_0). \]

    Чтение обычного поля $\textrm{f}$ из переменной $a$ использует
    \Mhyp переменную:
    \[ x \leftarrow \GETFIELD(\M_i, a, \textrm{f}), \]
    аналогично имеем чтение статического поля $\textrm{T.f}$:
    \[ x \leftarrow \GETSTATIC(\M_i, \textrm{T.f}). \]
    Запись переменной $x$ в обычное поле $\textrm{f}$ переменной $a$ порождает
    \Mhyp переменную:
    \[ \M_j \leftarrow \PUTFIELD(\M_i, a, \textrm{f}, x), \]
    аналогично порождает \Mhyp переменную запись в статическое поле $\textrm{T.f}$:
    \[ \M_j \leftarrow \PUTSTATIC(\M_i, \textrm{T.f}, x). \]

    Чтение и запись $i$-го элемента массива консервативно преобразуется в
    работу с синтетическим полем $\textrm{elements}$, которое добавляется всем
    типам-массивам.

    Вызов функции с параметрами $p_0, \ldots, p_n$ и возвращаемым значением,
    которое записывается в переменную $x$, консервативно представляется
    следующим образом:
    \[\begin{aligned}
      \M_j &\leftarrow \ESCAPE(\M_i, p_0, \ldots, p_n); \\
      \M_k &\leftarrow \RELOAD(\M_j); \\
      x  &\leftarrow \SHARED(\M_k).
    \end{aligned}\]
    Заметим, что в случае отсутствия возращаемого значения, последнюю строку
    необходимо убрать.

    В соответствии с моделью памяти языка \java, необходимо перечитывать
    значения полей объектов перед чтением \eng{volatile} полей и при входе в
    блок синхронизации:
    \[ \M_j \leftarrow \RELOAD(\M_i). \]

  \newpage
  \bibliography{../../biblio}

\end{document}

