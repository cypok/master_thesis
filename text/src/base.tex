\documentclass[14pt,titlepage,draft]{extarticle}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PACKAGES
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage[pdftex,unicode,hidelinks,final]{hyperref}
\usepackage{ucs}
\usepackage[utf8x]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{indentfirst}

\usepackage{geometry}

\usepackage[usenames,dvipsnames]{color}

\usepackage{ifdraft}

\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{mathtools} % some extensions over amsmath

\usepackage{xspace} % for \xspace
\usepackage{pbox}

\usepackage{footmisc}
\renewcommand{\footnotelayout}{\small}

% prevent underfull boxes in bibliography
\usepackage{etoolbox}
\apptocmd{\sloppy}{\hbadness 10000\relax}{}{}

\usepackage[obeyDraft, textwidth=3cm, textsize=footnotesize,
  backgroundcolor=orange!50, linecolor=black!50]{todonotes}

\usepackage{algorithm}
\usepackage{algpseudocode}
\floatname{algorithm}{Пример}
\newcommand{\algorithmictitle}[1]{\hspace{8mm}\textbf{#1}}

\usepackage{multicol}

\usepackage{../../common/cypokcommon}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% DOCUMENT-SPECIFIC COMMANDS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\input{../../common/gitinfo}

\newcommand{\java}{\eng{Java}\xspace}

\newcommand{\M}{\ensuremath{\mathbb{M}}}
\newcommand{\Mfield}[1]{\ensuremath{\mathrm{#1}}}

\let\mathphi\phi
\renewcommand{\phi}{\ensuremath{\mathphi}}

\newcommand{\type}[1]{\mathrm{#1}}
\newcommand{\field}[1]{\mathrm{#1}}
\newcommand{\sfield}[2]{\type{#1}.\field{#2}}

\newcommand{\op}[1]{\mathbf{#1}}

\newcommand{\pts}[1]{\widebar{#1}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% TEXT FORMAT
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\geometry{a4paper,top=2cm,bottom=2cm,bindingoffset=0cm}
\ifdraft{
  % <leftmargin> | <marginpar> | <sep> | <text> | <rightmargin>
  %    0.5cm     |     3cm     | 0.5cm |  16cm  |     1cm
  \geometry{reversemp=true,includemp=true,
            marginparwidth=3cm,marginparsep=0.5cm,
            left=0.5cm,textwidth=16cm}
}{
  % <leftmargin> | <text> | <rightmargin>
  %     3cm      |  16cm  |     2cm
  \geometry{left=3cm,textwidth=16cm}
}
\linespread{1.3}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% BODY
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{
  Применение анализа указателей и синонимов
  для оптимизации многопоточных программ
}
\author{
  Владимир Парфиненко
}

\begin{document}

  \thispagestyle{empty}
  \begin{center}
    \ifdraft{
      \
      \vspace{3cm}

      {\Large \scshape Черновик}

      \vspace{2cm}

      Работа на соискание степени магистра

      \vspace{0.2cm}

      {\large Парфиненко Владимир Владимирович}

      \vspace{1.5cm}

      {\large \scshape \bfseries
        Применение анализа указателей и синонимов\\
        для оптимизации многопоточных программ
      }

      \vfill

      Git info

      \begin{table}[!htb]
        \centering
        \begin{tabular}{rp{0.5\textwidth}}
          sha1: & \texttt{\GitAbbrHash} \\
          title:& \GitSubject \\
          date: & \GitDate
        \end{tabular}
      \end{table}
    }{
      Министерство образования и науки\\
      Российской Федерации

      \vspace{0.7cm}

      Государственное образовательное учреждение\\
      высшего профессионального образования\\
      <<Новосибирский национальный исследовательский\\
      государственный университет>> (НГУ)

      \vspace{0.7cm}

      Механико"=математический факультет

      \vspace{0.2cm}

      Кафедра программирования

      \vspace{1.2cm}

      Квалификационная работа на соискание\\
      степени магистра

      \vspace{0.5cm}

      {\large Парфиненко Владимир Владимирович}

      \vspace{1.1cm}

      {\large \scshape \bfseries
        Применение анализа указателей и синонимов\\
        для оптимизации многопоточных программ
      }

      \vspace{2.5cm}


      \hfill\pbox{\textwidth}{
        Научные руководители:\\
        м.\,н.\,с.~ИСИ~СО~РАН, Павлов\,П.\,Е.\\
        зав.\,лаб.~ИСИ~СО~РАН, к.\,т.\,н.~Шелехов\,В.\,И.
      }

      \vfill

      Новосибирск 2013
    }
  \end{center}

  \listoftodos

  \tableofcontents

  \sectionwithoutnumber{Введение}

    Статический анализ программ активно применяется в оптимизирующих
    компиляторах. Одним из видов статического анализа является анализ
    указателей и синонимов. Результаты такого анализа могут быть использованы
    для усиления других видов анализа, проводимых оптимизирующим компилятором,
    и, как следствие, для повышения качества оптимизирующих преобразований.
    Таким образом может быть усилен достаточно обширный класс анализов и
    оптимизаций, как классических (таких например, как удаление общих
    подвыражений, чистка циклов, протяжка констант и присваиваний, удаление
    проверок времени исполнения), так и объектно"=ориентированных
    (девиртуализация, удаление избыточной синхронизации, \eng{escape}"=анализ,
    аллокация объектов на стеке, открытая подстановка объектов).

    Для программ, исполняемых в управляемых средах \engdef{managed
    environments}, таких, как JVM\footnote{\eng{JVM, Java Virtual Machine}~---
    виртуальная машина \java, основная часть исполняющей системы \java.}, или
    CLR\footnote{\eng{CLR, Common Language Runtime}~--- виртуальная машина,
    интерпретирующая и исполняющая код на языке CIL, в который компилируются
    программы, написанные, в частности, на .NET"=совместимых языках
    программирования.}, значение анализа указателей и синонимов для
    качественной оптимизации кода существенно возрастает. Это связано с двумя
    основными причинами. Во-первых, в управляемых средах затруднен или вообще
    отсутствует доступ программиста к низкоуровневым, небезопасным средствам
    (таким, например, как адресная арифметика и ручное управление памятью), что
    затрудняет ручную оптимизацию и вынуждает оптимизирующий компилятор
    (виртуальную машину) проводить более глубокий анализ и более аггрессивные
    оптимизации программы для достижения приемлемого уровня производительности.

    Во-вторых, любая программа в управляемой среде является многопоточной, а
    сама среда обеспечивает поддержку средств многопоточного программирования,
    таких, как потоки исполнения \engdef{threads}, атомарные операции,
    примитивы синхронизации. Более того, семантика любого участка кода
    программы (например, отдельной процедуры) более не может считаться
    независимой от многопоточной среды~--- семантика всех взаимодействий кода с
    разделяемой памятью описывается так называемой моделью памяти данного
    языка/среды, которая описывает влияние различных потоков исполнения друг на
    друга через разделяемую память и тем самым определяет корректность тех или
    иных преобразований программы~\cite{manson_jmm}. На практике это означает,
    что не всякие оптимизирующие преобразования однопоточной программы будут
    являться корректными, если рассматривать ту же программу в многопоточной
    среде. Корректное и при этом не чрезмерно препятствующее оптимизациям
    определение зависимостей и связей в программе возможно только при
    проведении нетривиального анализа указателей и синономов.

    Данная работа посвящена разработке алгоритма анализа указатлей и синонимов
    для языка \java, учитывающего вышеприведенные соображения.

  \section{Постановка задачи}

    Целью данной работы является разработка алгоритма анализа указателей и
    синонимов для языка \java, учитывающего особенности языка и его модели
    памяти.

    Для достижения поставленной цели необходимо провести сравнительный анализ
    существующих алгоритмов, обосновать их сравнительную пригодность (включая
    результативность и производительность) для использования в оптимизирующем
    компиляторе и разработать усовершенствованный алгоритм, выбрав за основу
    один из существующих. Алгоритм должен полностью соответствовать модели
    памяти языка \java.

    Особое внимание необходимо уделить способу выражения зависимостей по
    данным между операциями работающими с памятью, что критично влияет на
    точность алгоритма. Необходимо изучить существующие способы, а затем
    выбрать и возможно доработать схему выражения таких зависимостей, чтобы она
    корректно отражала семантику работы с разделяемой памятью.

    Также в рамках данной работы планируется реализовать прототип алгоритма
    анализа на базе системы \eng{Excelsior Research Virtual Machine},
    включающей статический компилятор и среду исполнения для платформы
    \eng{Java~SE}.

  \section{Анализ указателей и синонимов}

    Анализ указателей~--- это один из видов статического анализа, который
    позволяет определить, на какие объекты в памяти могут указывать выражения
    ссылочного типа в программе (такие объекты называются целями выражения
    ссылочного типа). Анализ синонимов похож на анализ указателей: его целью
    является определение, могут ли два разных выражения ссылаться на одно и
    то же место в памяти (такие выражения называют синонимами)~\cite{andersen}.

    \subsection{Классификация алгоритмов анализа указателей}
    \label{section:analysis_classification}

      Разные алгоритмы анализа указателей отличаются по точности, по скорости
      работы, по количеству памяти, необходимой для проведения анализа.
      Далее будут рассмотрены основные параметры алгоритмов, влияющие на эти
      характеристики.

      Для сравнения точности алгоритмов анализа указателей необходимо ввести
      некую меру точности. В качестве простой меры точности алгоритма часто
      используется усредненное количество синонимов для всех переменных
      ссылочного типа, появляющихся в
      программе~\cite[раздел~3.2]{hind_pointer_analysis_not_solved_yet}
      (также существуют и более изощренные
      меры~\cite{hind_pointer_analysis_not_solved_yet,diwan_tbaa}).

      Понятно, что для «идеального» алгоритма анализа это число будет
      минимальным, а для самого консервативного алгоритма~--- максимальным.

      \subsubsection{Чувствительные к потоку данных алгоритмы}
        \label{section:analysis_classification_data_flow}

        Примером алгоритма, не учитывающего потоки данных в программе, может
        служить алгоритм анализа синонимов, основанный на типах, применимый
        для языков со строгой типизацией.
        \todo{подробнее про строгую систему типов?}
        Простейшая реализация такого алгоритма дает следующий результат:
        независимо от контекста и потоков данных в программе, два выражения
        могут быть синонимами, если они имеют совместимые формальные
        типы~\cite[раздел~2.2]{diwan_tbaa}.
        Такой алгоритм работает за константное время, но обладает очень низкой
        точностью.

        Большей точностью обладают алгоритмы анализа, которые учитывают потоки
        данных в программе.
        Например, если существует только одно присваивание переменной $v$ вида
        $v \gets \op{new}~\type{T}$, то можно гарантировать, что переменная $v$
        может указывать только на объект, созданный этим оператором \eng{new}.
        С присваиванием вида $v_1 \gets v_2$ ситуация сложнее. Рассмотрим
        пример~\ref{code:data_flow}.

        \begin{algorithm}
          \caption{Сравнение алгоритмов \eng{subset"=based} и
                                        \eng{equality"=based} типов}
          \label{code:data_flow}
          \begin{algorithmic}[1]
            \State $b \gets \op{new}~\type{T}$
            \State $c \gets \op{new}~\type{T}$
            \State $a \gets b$
            \State $a \gets c$
          \end{algorithmic}
        \end{algorithm}

        Цели указателя, то есть множество объектов, на которые может указывать
        переменная $p$ (или любое другое выражение ссылочного типа), для
        удобства обозначим как $\pts{p}$.
        Учитывая строки 1 и 2, для переменных $b$ и $c$ мы можем точно
        определить множество объектов, на которые они указывают:
        \[\pts{b} = \{O_1\},\ \pts{c} = \{O_2\},\]
        где $O_1$ и $O_2$~--- уникальные объекты в куче, соответствующие
        операторам \eng{new} в строках 1 и 2. То есть мы учли поток данных от
        оператора \eng{new}, создавшего новый объект, в переменную.

        Интерпретировать присваивание $a \gets b$ можно двумя способами,
        и алгоритмы анализа разбиваются на два типа по этому признаку:
        \begin{itemize}
          \item алгоритмы первого типа накладывают ограничение
                $\pts{a} \supset \pts{b}$
                (\eng{subset"=based} алгоритмы)~\cite{andersen};
          \item алгоритмы второго типа накладывают ограничение
                $\pts{a} = \pts{b}$
                (\eng{equality"=based} алгоритмы)~\cite{steensgaard}.
        \end{itemize}
        В нашем примере \eng{subset"=based} алгоритм получит, что
        \[\pts{a} = \{O_1, O_2\},\ \pts{b} = \{O_1\},\ \pts{c} = \{O_2\},\]
        а \eng{equality"=based}
        \[\pts{a} = \pts{b} = \pts{c} = \{O_1, O_2\}.\]
        Первый тип алгоритмов более точен, хотя его время работы в худшем
        случае кубически зависит от размера анализируемой программы.
        Второй тип алгоритмов работает за практически линейное время\footnote{
          Временная сложность \eng{equality"=based} алгоритма
          $O(N \alpha(N))$~\cite{steensgaard}, где $\alpha(N)$~--- обратная
          функция Аккермана. Она является очень медленно растущей, и при
          анализе асимптотики алгоритмов можно принять ее за константу.
        },
        предоставляя менее точные результаты.
        Каждый из этих алгоритмов имеет свою область применения, например,
        \eng{subset"=based} алгоритм имеет смысл использовать при анализе
        отдельного метода программы, в то время как \eng{equality"=based} лучше
        подходит для анализа всей программы целиком.


      \subsubsection{Чувствительные к потоку управления алгоритмы}
        \label{section:analysis_classification_control_flow}

        Также для повышения точности алгоритм анализа указателей может
        учитывать поток управления в программе.
        Рассмотрим пример~\ref{code:control_flow}.

        \begin{algorithm}
          \caption{Сравнение чувствительного и нечувствительного к потоку
                   управления алгоритмов}
          \label{code:control_flow}
          \begin{algorithmic}[1]
            \State $a \gets \op{new}~\type{T}$
            \State $b \gets \op{new}~\type{T}$
            \State $c \gets \op{new}~\type{T}$ \label{code:control_flow:before_gets}
            \State $a \gets b$ \label{code:control_flow:after_gets}
            \State $b \gets c$
            \State $c \gets a$ \label{code:control_flow:end}
          \end{algorithmic}
        \end{algorithm}

        Нечувствительный к потоку управления алгоритм анализа воспринимает
        программу как неупорядоченный набор операций.
        Для указанного примера такой алгоритм получит следующее
        \[\pts{a} = \pts{b} = \pts{c} = \{O_a, O_b, O_c\}.\]
        Этот результат не является особо точным, но зато он верен
        для любой точки программы.

        Чувствительный к потоку управления алгоритм получит следующие данные
        после строки~\ref{code:control_flow:before_gets}:
        \[\pts{a} = \{O_a\},\ \pts{b} = \{O_b\},\ \pts{c} = \{O_c\}.\]
        Далее, при анализе строки~\ref{code:control_flow:after_gets},
        присваивание будет интерпретировано как строгое присваивание%
        \footnote{Строгое присваивание \engdef{strong update}, по возможности,
        заменяет текущий набор целей указателей на новый, а не просто расширяет
        его.}%
        , то есть присваивание нового значения в переменную уничтожит
        информацию о том, что $a$ может указывать на $O_a$, и в итоге
        получится, что $\pts{a} = \{O_b\}$.
        Продолжая подобные рассуждения, алгоритм получит следующие результаты
        после строки~\ref{code:control_flow:end}:
        \[\pts{a} = \{O_b\},\ \pts{b} = \{O_c\},\ \pts{c} = \{O_b\}.\]
        Хотя такой алгоритм дает более точный результат, приходится хранить
        информацию о целях каждого указателя для каждой точки программы
        отдельно, что значительно увеличивает суммарный объем памяти,
        занимаемый результатами анализа.

      \subsubsection{Межпроцедурные алгоритмы}

        Алгоритм анализа может учитывать потоки данных не только внутри
        единственной анализируемой функции, но и между отдельными функциями,
        которые могут быть вызваны из анализируемой.
        Рассмотрим пример~\ref{code:interprocedural}.

        \begin{algorithm}
          \caption{Демонстрация работы межпроцедурного алгоритма}
          \label{code:interprocedural}
          \begin{algorithmic}[1]
            \Function{Some}{$x$, $y$}
              \State \Return $x$
            \EndFunction
            \Statex
            \State $b \gets \op{new}~\type{T}$
            \State $c \gets \op{new}~\type{T}$
            \State $a \gets$ \Call{Some}{$b$, $c$}
          \end{algorithmic}
        \end{algorithm}

        Наша задача понять, чему равно $\pts{a}$.
        Алгоритмы анализа можно разделить на две категории, в зависимости от
        того, как они обрабатывают вызовы функций:
        \begin{itemize}
          \item межпроцедурные алгоритмы анализа могут сначала проанализировать
                тело вызываемой функции, и затем учесть результат при обработке
                вызова,
          \item внутрипроцедурные алгоритмы рассматривают вызов функции в
                наиболее консервативном предположении: может быть возвращен
                либо один из параметров, либо один из глобальных объектов.
        \end{itemize}
        Понятно, что первый тип алгоритмов дает более точные результаты,
        а второй потребляет меньше памяти и работает
        быстрее~\cite[с.~117]{andersen}.
        В нашем примере межпроцедурный алгоритм анализа, проанализировав
        функцию \eng{Some}, запоминает, что для нее выполнено следующее условие
        на возвращаемое значение
        \[\pts{retval} = \pts{x},\]
        и тогда может сделать вывод, что \[\pts{a} = \pts{b} = \{O_1\}.\]
        В такой же ситуации внутрипроцедурный алгоритм анализа обязан сделать
        консервативное предположение
        \[\pts{a} = \pts{b} \cup \pts{c} = \{O_1, O_2\}.\]

  \section{Анализ многопоточных программ}
    \label{section:intro_to_multithreading}

    Компьютеры, в которых несколько процессоров взаимодействуют с
    использованием разделяемой памяти, разрабатываются с 1960-х годов, а
    сейчас они уже распространены повсеместно.

    С одной стороны, изначально доступ к общей памяти был строго
    последовательным для всех потоков, исполнявшихся на разных процессорах.
    Это приводило к тому, что два последовательных чтения в одном потоке из
    одного и того же места памяти могли давать разные результаты, так как в
    параллельном потоке могла быть совершена запись в эту же самую память в
    момент времени между последовательными чтениями в первом потоке.

    С другой стороны, со временем появились весьма изощренные техники
    повышения производительности работы с общей памятью: многоуровневые кэши,
    внеочередное исполнение \engdef{out-of-order execution} и другие.
    Это приводит к тому, что запись в память, произведенная одним потоком,
    может быть не видна другим. Или наоборот: запись может произойти раньше
    либо позже по сравнению со строго последовательным порядком исполнения.

    Рассмотрим пример~\ref{code:out_of_order_exec}, исполнение которого на
    современном процессоре может привести к неожиданному результату.
    Если изначально $obj.x = obj.y = 0$, то по окончанию работы примера
    значения переменных $x$ и $y$ могут равняться также нулю. Это связано с
    тем, что процессор при исполнении первого потока мог сначала выполнить
    вторую операцию, так как она не зависит от первой, аналогично при
    исполнении второго потока.

    \begin{algorithm}
      \caption{Нарушение логики программы при внеочередном исполнении}
      \label{code:out_of_order_exec}
      \begin{multicols}{2}
        \algorithmictitle{Поток 1}
        \begin{algorithmic}[1]
          \State $obj.x \gets 1$
          \State $y \gets obj.y$
        \end{algorithmic}
        \columnbreak
        \algorithmictitle{Поток 2}
        \begin{algorithmic}[1]
          \State $obj.y \gets 1$
          \State $x \gets obj.x$
        \end{algorithmic}
      \end{multicols}
    \end{algorithm}

    Получается, что если нет четкой семантики, определяющей, какие значения
    могут быть получены при чтении переменных из памяти, анализ указателей
    для них получится очень неточным\footnote{
      В такой ситуации алгоритму анализа придется делать очень консервативное
      предположение: считать, что все указатели, прочитанные из памяти, могут
      указывать на одни и те же данные и могут быть синонимами.
    } и не будет давать хоть сколько-нибудь полезной информации, что приведет
    к невозможности проведения большого количества оптимизирующих
    преобразований программы.

    На самом деле в большинстве систем есть определенные правила,
    регулирующие работу с памятью. Такие правила есть на уровне процессора,
    виртуальной машины и языка. Эти правила называют моделью памяти.
    Модель памяти для многопоточной системы определяет в каком
    порядке могут происходить доступы к памяти в программе и, как следствие,
    какие значения может возвращать конкретное чтение памяти. Соответственно,
    наличие четко определенной модели памяти позволяет разработать алгоритм
    анализа, пригодный для анализа многопоточных программ.

  \section{Внутреннее представление и SSA-форма}

    \todo{Я оперирую понятиями <<внутреннее представление>> и SSA-форма. Нужен
    ли этот раздел, или это и так все знают?}

    В данном разделе будут введены понятия внутреннего представления программы
    и SSA-формы программы, которые понадобятся в дальнейшем при описании
    алгоритма анализа указателей.

    В процессе компиляции программа на исходном языке программирования
    переводится в так называемое внутреннее представление
    \engdef{internal representation, IR}, c которым работают
    алгоритмы анализа и над котором проводятся оптимизации.
    Рассмотрим внутреннее представление тела функции, заданное в виде
    управляющего графа \engdef{control flow graph, CFG}, именно это
    внутреннее представление используется для проведения большинства
    оптимизаций в современных компиляторах~\cite{muchnick}.
    CFG~--- это ориентированный граф, в котором вершинам соответствуют
    последовательности операторов программы, а дугам~--- переходы из конца
    одной последовательности операторов в начало другой. Такие
    последовательности операторов, являющиеся вершинами, назовем линейными
    участками. В конце каждого линейного участка присутствует оператор
    перехода, который передает управление по одной из дуг, выходящих из
    данной вершины CFG.

    Будем говорить, что программа находится в SSA-форме (\eng{Static Single
    Assignment}), если существует не более одного присваивания в любую из
    переменных~\cite{ssa}.
    Для представления программ в SSA-форме переменные версионируются и
    вводится дополнительная операция слияния значений переменных, так
    называемая \phi"=функция.

    Версии вводятся для переменных, которые имеют более одного присваивания.
    Участок программы вида
    \[ v \gets 1; \op{use}(v); v \gets 2; \op{use}(v); \]
    после версионирования будет выглядеть следующим образом
    \[ v_1 \gets 1; \op{use}(v_1); v_2 \gets 2; \op{use}(v_2). \]

    \phi"=функции вводятся для слияния версий переменных, определяемых
    на разных путях исполнения. Пусть в CFG программы существует
    вершина $N$, такая что в нее входят дуги из вершин $N_1, \ldots, N_k$, в
    которых использовались версии $v_1, \ldots, v_k$ переменной $v$. Тогда в
    $N$ будет располагаться \phi"=функция
    \[ v_x \gets \op{phi}(v_1, \ldots, v_k). \]
    Семантика данной операции заключается в присваивании переменной $v_x$
    значения переменной $v_i$, соответствующего вершине $N_i$, из которой
    управление пришло в $N$. В случае программы, приведенной в
    примере~\ref{code:ssa_with_phi}, переменной $a_3$ будет присвоено значение
    5 или 7, в зависимости от того, из какой ветки условного блока придет
    исполнение.

    \begin{algorithm}
      \caption{Пример перевода программы в SSA-форму с \phi"=функцией}
      \label{code:ssa_with_phi}
      \begin{multicols}{2}
        \begin{algorithmic}[1]
          \If{\ldots}
            \State $a \gets 5$
          \Else
            \State $a \gets 7$
          \EndIf
          \State $\op{use}(a)$
        \end{algorithmic}
        \columnbreak
        \begin{algorithmic}[1]
          \If{\ldots}
            \State $a_1 \gets 5$
          \Else
            \State $a_2 \gets 7$
          \EndIf
          \State $a_3 \gets \op{phi}(a_1, a_2)$
          \State $\op{use}(a_3)$
        \end{algorithmic}
      \end{multicols}
    \end{algorithm}

    Любую программу можно перевести в SSA-форму посредством
    версионирования переменных и расстановки \phi"=функций~\cite{ssa}.
    Для перевода в SSA-форму и вывода из нее существуют эффективные
    алгоритмы~\cite{bilardi_ssa, briggs_ssa}.

  \section{Предыдущие наработки}
    \label{section:previous_work}

    В рамках предыдущей работы на соискание степени
    бакалавра~\cite{my_bachelor} был разработан алгоритм анализа, целью
    которого был эффективный анализ многопоточных \java программ.
    Разработанный алгоритм являлся внутрипроцедурным, нечувствительным к
    потоку управления алгоритмом анализа указателей \eng{subset"=based} типа,
    работающим с программой в SSA-форме.

    Хотя алгоритм и был адаптирован для анализа многопоточных программ, в
    некоторых случаях его точность была неудовлетворительна. Рассмотрим
    некоторые примеры, когда алгоритм давал чересчур консервативные
    результаты.

    \subsection{Чувствительность алгоритма к потоку управления}

      Напомним, что точность чувствительного к потоку алгоритма во многом
      обусловлена эффектом строгих присваиваний. Для переменных верхнего уровня
      схожий эффект был достигнут благодаря переводу программы в SSA-форму, а
      для полей объектов анализ был полностью нечувствителен к потоку. То есть
      алгоритм интерпретировал все операции доступа к полям объектов как
      неупорядоченный набор, что приводило к низкой точности при работе с ними.
      Пример~\ref{code:bad_flow_sensitivity_1} демонстрирует это.

      \begin{algorithm}
        \caption{Отсутствие чувствительности к потоку управления при работе с
          полями объектов}
        \label{code:bad_flow_sensitivity_1}
        \begin{algorithmic}[1]
          \State $x \gets \op{new}~\type{T}$
          \State $x.f \gets \op{new}~\type{Object}$
          \State $a \gets x.f$
          \State $x.f \gets \op{new}~\type{Object}$
          \State $b \gets x.f$
        \end{algorithmic}
      \end{algorithm}

      В данном примере легко увидеть, что $a$ и $b$ ссылаются на заведомо
      разные объекты и не могут быть синонимами. Однако разработанный алгоритм
      получал консервативный результат:
      \[ \pts{x} = \{O_1\},\ \pts{a} = \pts{b} = \pts{x.f} = \{O_2, O_3\}. \]

      Пример~\ref{code:bad_flow_sensitivity_2} показывает другой случай, когда
      нечувствительность к потоку приводит к консервативному результату.

      \begin{algorithm}
        \caption{Отсутствие чувствительности к потоку управления при работе с
          разделяемой памятью}
        \label{code:bad_flow_sensitivity_2}
        \begin{algorithmic}[1]
          \State $a \gets \op{new}~\type{Object}$
          \State $b \gets$ \Call{GetFromShared}{}
            \Comment получение объекта из разделяемой памяти
          \State \Call{EscapeToShared}{$a$}
            \label{code:bad_flow_sensitivity_2:escape}
            \Comment утекание объекта в разделяемую память
        \end{algorithmic}
      \end{algorithm}

      В данном примере значение $b$ получается до того, как созданный объект
      утекает через вызов в строке~\ref{code:bad_flow_sensitivity_2:escape}.
      Однако разработанный алгоритм опять же поведет себя максимально
      консервативным образом из-за того, что он не обладает информацией, что
      случилось раньше: получение значения для $b$ из разделяемой памяти или
      утекание переменной $a$.

    \subsection{Анализ многопоточных программ}

      В рамках изучения модели памяти языка \java было получено, что существует
      класс операций, приводящих к перечитыванию полей всех разделяемых
      объектов~\cite[раздел~5.3.1]{my_bachelor}. Эти операции обладают
      следующей семантикой: если мы дважды читаем одно и то же поле объекта и
      между этими чтениями нет операций, приводящих к перечитыванию полей всех
      разделяемых объектов, и нет операций записи в это поле, то модель памяти
      позволяет не считывать повторно значение из памяти, а использовать
      значение, полученное при первом чтении. Такими операциями являются
      чтение \eng{volatile} поля, вход в блок синхронизации и вызов метода.

      Разработанный алгоритм в случае наличия хотя бы одной такой операции при
      чтении поля любого разделяемого объекта выдавал информацию о том, что это
      поле может указывать на любой из разделяемых объектов. Такой подход
      является зачастую чересчур консервативным, особенно в случае, если
      перечитывание полей объектов случается в самом конце анализируемого
      метода. Рассмотрим пример~\ref{code:bad_multithreading}, демонстрирующий
      эту проблему.

      \begin{algorithm}
        \caption{Консерватизм при чтении полей разделяемых объектов}
        \label{code:bad_multithreading}
        \begin{algorithmic}[1]
          \State $x \gets \op{new}~\type{T}$
          \State $x.f \gets \op{new}~\type{Object}$
            \label{code:bad_multithreading:obj_creation}
          \State $\type{T}.sfield \gets x$
            \Comment утекание $x$ в статическое поле класса
          \State $a \gets x.f$
          \State \Call{ReloadFields}{}
            \Comment операция, приводящая к перечитыванию полей
          \State $b \gets x.f$
        \end{algorithmic}
      \end{algorithm}

      В данном примере видно, что переменная $a$ может указывать на
      единственный объект, создаваемый в
      строке~\ref{code:bad_multithreading:obj_creation}. Однако переменная $b$,
      значение которой также получается из поля $x.f$, может указывать не
      только на этот объект, но и на любой другой разделяемый объект. Это
      происходит из-за наличия операции, приводящей к перечитыванию полей
      разделяемых объектов, коим $x$ и является. Разработанный в предыдущей
      работе алгоритм опять же поведет себя весьма консервативно: так как $x$
      утекает и есть операция, приводящая к перечитыванию полей объектов, то
      в результате алгоритм получит, что все значения прочитанные из полей
      переменной $x$ могут указывать на любой из разделяемых объектов.

    \subsection{Выводы}

      Анализируя проблемы ранее разработанного алгоритма, можно видеть, что они
      связанны с отсутствием чувствительности к неявному потоку данных между
      операциями чтения и записи полей. То есть у нас нету зависимости по
      данным между этими операциями, в отличии от явно выраженной зависимости
      между переменными верхнего уровня благодаря SSA-форме. \todo{бред?}

  \section{Выражение зависимости по памяти}

    Одним из способов выражения зависимостей по памяти является введение
    явной переменной, олицетворяющей образ всей памяти. Значение этой
    переменной может использоваться в качестве аргумента в операциях, читающих
    память, и порождаться в операциях, пишущих в память.

    \subsection{\texorpdfstring{\M}{M}"=переменная}

      Введем специальную переменную, \M"=переменную. Значение \M"=переменной
      есть образ памяти, который, в частности, может использоваться операциями
      чтения полей объектов и может модифицироваться операциями записи в поля
      объектов. Для наглядности рассмотрим простой пример~\ref{code:m_var}
      программы, которая использует \M"=переменную\footnote{
        Здесь и далее будем использовать следующую структуру инструкций
        псевдокода: $var \gets \op{operation}(arg_1, \ldots, arg_N)$, где
        $var$~--- некоторая переменная, $arg_i$~--- либо переменная, либо
        идентификатор типа, либо идентификатор поля.}.

      \begin{algorithm}
        \caption{Пример использования \M"=переменной}
        \label{code:m_var}
        \begin{algorithmic}[1]
          \If{\ldots}
            \State $\M \gets \op{putfield}(\M, a, \field{f}, x)$
          \Else
            \State $\M \gets \op{putfield}(\M, a, \field{f}, y)$
          \EndIf
          \State $z \gets \op{getfield}(\M, a, \field{f})$
        \end{algorithmic}
      \end{algorithm}

      В этом примере для чтения и записи поля $\field{f}$ переменной $a$
      используются специально введенные операции getfield и putfield. Операция
      getfield в качестве аргументов имеет \M"=переменную, ссылку на объект и
      идентификатор поля и возвращает значение поля объекта из данного
      образа памяти. Операция putfield имеет те же первые аргументы и один
      дополнительный аргумент: значение, которое записывается в поле объекта;
      эта операция возвращает \M"=переменную, которая соответствует образу
      памяти с измененным значением поля.

      Заметим, что программу с введенной \M"=переменной можно перевести в
      SSA-форму, трактуя ее как обычную переменную. Пример~\ref{code:m_var_ssa}
      является примером~\ref{code:m_var}, переведенным в SSA-форму.

      \begin{algorithm}
        \caption{Пример SSA-формы программы с \M"=переменной}
        \label{code:m_var_ssa}
        \begin{algorithmic}[1]
          \If{\ldots}
            \State $\M_1 \gets \op{putfield}(\M_0, a, \field{f}, x)$
          \Else
            \State $\M_2 \gets \op{putfield}(\M_0, a, \field{f}, y)$
          \EndIf
          \State $\M_3 \gets \op{phi}(\M_1, \M_2)$
          \State $z \gets \op{getfield}(\M_3, a, \field{f})$
        \end{algorithmic}
      \end{algorithm}

      После перевода в SSA-форму естественным образом появляется \phi"=функция
      от \M"=переменных, семантика которой эквивалентна семантике \phi"=функции
      от обычных переменных.

      Важно понимать, что на самом деле \M"=переменная является некоторой
      абстракцией памяти. Она не присутствует в явном виде в исходном коде
      программы и должна быть специально введена на некотором этапе компиляции
      программы. Аналогично, эта переменная не имеет никакого физического
      воплощения в машинном коде и должна быть удалена при кодогенерации.

    \subsection{Анализ указателей с \texorpdfstring{\M}{M}"=переменной}

      В этой секции покажем, как введение \M"=переменной и перевод программы в
      SSA-форму позволяют повысить точность анализа указателей. Для этого еще
      раз рассмотрим примеры, приведенные в
      разделе~\ref{section:previous_work}, используя в них \M"=переменную.

      В примерах помимо операций getfield и putfield, которые были введены
      ранее, понадобятся и другие операции, такие как putstatic, escape, reload
      и другие; их семантика подробно описана в
      разделе~\ref{section:ops_semantic}.

      Рассмотрим пример~\ref{code:m_var_flow_sensitivity_1}. Теперь видно, что
      на самом деле чтение поля в переменную $a$ отличается от чтения в
      переменную $b$, операции getfield используют разные версий
      \M"=переменной, читают из разного состояния памяти. Поэтому в данном
      случае при оптимальной интерпретации \M"=переменной алгоритм сможет
      понять, что $a$ и $b$ и вовсе не могут быть синонимами.

      \begin{algorithm}
        \caption{Чувствительность к потоку управления при работе с
          полями объектов}
        \label{code:m_var_flow_sensitivity_1}
        \begin{algorithmic}[1]
          \State $x \gets \op{new}(\type{T})$
          \State $t_0 \gets \op{new}(\type{Object})$
          \State $\M_1 \gets \op{putfield}(\M_0, x, \field{f}, t_0)$
          \State $a \gets \op{getfield}(\M_1, x, \field{f})$
          \State $t_1 \gets \op{new}(\type{Object})$
          \State $\M_2 \gets \op{putfield}(\M_1, x, \field{f}, t_1)$
          \State $b \gets \op{getfield}(\M_2, x, \field{f})$
        \end{algorithmic}
      \end{algorithm}

      Теперь рассмотрим пример~\ref{code:m_var_flow_sensitivity_2}.
      Получается, что сделав \M"=переменную аргументом операций shared и
      escape, алгоритм может давать более точные результаты. В данном случае
      можно получить, что $a$ и $b$ не являются синонимами, хотя значение
      переменной $b$ получается из разделяемой памяти, а переменная $a$
      является утекшей. Благодаря \M"=переменной мы можем понять, что данные
      действия выполнялись именно в таком порядке, и на момент получения
      значения из разделяемой памяти $a$ не являлась утекшей переменной.

      \todo{в конце примера~\ref{code:m_var_flow_sensitivity_2} должен быть
        $\op{reload}$, пока это не важно}
      \begin{algorithm}
        \caption{Чувствительность к потоку управления при работе с
          разделяемой памятью}
        \label{code:m_var_flow_sensitivity_2}
        \begin{algorithmic}[1]
          \State $a \gets \op{new}(\type{Object})$
          \State $b \gets \op{shared}(\M_0)$
            \Comment получение объекта из разделяемой памяти
          \State $\M_1 \gets \op{escape}(\M_0, a)$
            \Comment утекание объекта в разделяемую память
        \end{algorithmic}
      \end{algorithm}

      Рассмотрим пример~\ref{code:m_var_multithreading}, который на самом деле
      является более изощренной версией
      примера~\ref{code:m_var_flow_sensitivity_2}. В нем происходит утекание
      $x$ в строке~\ref{code:m_var_multithreading:escaping}, однако важно
      понимать, что из-за особенностей модели памяти языка \java, объект
      утекает, но значения его полей мы имеем право не перечитывать вплоть до
      выполнения одной из операций, приводящих к перечитыванию полей
      разделяемых объектов. В данном случае такая операция есть в
      строке~\ref{code:m_var_multithreading:reload}, и за счет того, что
      значения переменных $a$ и $b$ получаются из версий памяти до и после
      операции перечитывания полей, в первом случае $\pts{a}$ будет
      совпадать с $\pts{t_0}$, однако $\pts{b}$ будет равен $\pts{t_0}$ в
      объединении с множеством всех разделяемых объектов. Заметим, что
      нечувствительный к потоку управления алгоритм анализа сможет получить
      такой результат при оптимальной интерпретации операций с \M"=переменной.

      \begin{algorithm}
        \caption{Отсутствие консерватизма при чтении полей разделяемых
          объектов}
        \label{code:m_var_multithreading}
        \begin{algorithmic}[1]
          \State $x \gets \op{new}(\type{T})$
          \State $t_0 \gets \op{new}(\type{Object})$
          \State $\M_1 \gets \op{putfield}(\M_0, x, \field{f}, t_0)$
          \State $\M_2 \gets \op{putstatic}(\M_1, \sfield{T}{f}, x)$
            \Comment утекание $x$ в статическое поле класса
            \label{code:m_var_multithreading:escaping}
          \State $a \gets \op{getfield}(\M_2, x, \field{f})$
          \State $\M_3 \gets \op{reload}(\M_2)$
            \Comment операция, приводящая к перечитыванию полей
            \label{code:m_var_multithreading:reload}
          \State $b \gets \op{getfield}(\M_3, x, \field{f})$
        \end{algorithmic}
      \end{algorithm}

      Однако не стоит полагать, что нечувствительный к потоку управления
      алгоритм анализа, работающий с SSA-формой и \M"=переменной, сможет
      заменить чувствительный к потоку управления анализ. Существуют примеры,
      когда алгоритму нужно больше информации о программе, чем дает
      \M"=переменная.

      \todo{Примеры, когда даже \M"=переменная не помогает}

  \section{Алгоритм анализа указателей}

    Алгоритм анализа указателей работает со вспомогательным внутренним
    представлением, которое позволяет эффективно проводить анализ и хранить его
    результаты.

    Вспомогательное внутреннее представление содержит неупорядоченное множество
    операций вида
    \[ var \gets \op{operation}(arg_1, \ldots, arg_N), \]
    где $var$~--- некоторая переменная, $arg_i$~--- либо переменная, либо
    идентификатор типа, либо идентификатор поля, а $\op{operation}$~--- одна из
    операций, описанных далее в разделе~\ref{section:ops_semantic}.

    Множество таких операций строится по множеству всех операций
    анализируемого метода в соответствии с тем, как это описано далее в
    разделе~\ref{section:java_ops}.

    Алгоритм проводит потоковый анализ: имея изначально пустные
    множества целей переменных ссылочного типа, происходят итерации по
    множеству операций вспомогательного внутреннго представления, во время
    которых каждая операция интерпретируется в соответствии с ее семантикой,
    описанной далее в разделе~\ref{section:ops_semantic}. Алгоритм проводит
    итерации пока множества целей переменных и полей объектов изменяются и
    прекращает свою работу, когда результаты достигают неподвижной точки.
    Доказательство сходимости и корректности данного алгоритма анализа в данной
    работе не приводится.


    \subsection{Семантика операций}
      \label{section:ops_semantic}

      Ключевыми понятиями анализа являются абстрактные объекты и их множества.
      Абстрактные объекты будем обозначать буквой $O$; множество целей, на
      которые может указывать переменная $x$, будем обозначать $\pts{x}$.

      $AbstractObjects$~--- это множество всех абстрактных объектов. Оно
      состоит из уникальных объектов, соответствующих операциям создания
      объекта, и одного специального объекта $O_{global}$, который олицетворяет
      все объекты, созданные вне анализируемого метода.

      Для хранения результатов анализа вспомогательное внутреннее представление
      содержит информацию о множестве целей всех переменных ссылочного
      типа и информацию о состояниях памяти в виде структур, соответствующих
      версиям \M"=переменной.

      Опишем такую структуру, соответствующую \M"=переменной. Во-первых, она
      содержит информацию о множестве целей полей объектов:
      \[ \M.\Mfield{fields}\colon
        AbstractObjects \times InstanceFieldDescs \to
        \powerset{AbstractObjects},
      \]
      где $InstanceFieldDescs$~--- это множество идентификаторов полей
      объектов.  Аналогично хранится информация о множестве целей статических
      полей:
      \[ \M.\Mfield{statics}\colon
        StaticFieldDescs \to \powerset{AbstractObjects},
      \]
      где $StaticFieldDescs$~--- это множество идентификаторов
      статических полей.

      Заметим, что, во-первых, эти отображения можно рассматривать как
      множества.  А во-вторых, эти отображения будут иметь умолчательное
      значение: если у нас не определено отображение для некоторого значения,
      то образ этого значения есть пустое множество.\todo{Мысль понятна, как
      переформулировать?}

      Во-вторых, \M"=переменная должна содержать информацию о разделяемых
      объектах и об объектах, которые утекут \engdef{escape} из метода и станут
      разделяемыми. Для представления этой информации хранится два множества
      объектов: объекты (\eng{shared}), которые утекли из метода и уже являются
      разделяемыми (консервативно предполагается, что эти объекты могут быть
      прочитаны из любой разделяемой памяти), и объекты (\eng{escaped}),
      которые утекли, но еще не являются разделяемыми.
      \[ \M.\Mfield{shared} \in \powerset{AbstractObjects}; \]
      \[ \M.\Mfield{escaped} \in \powerset{AbstractObjects}. \]

      Теперь опишем все операции, которые используются во вспомогательном
      внутреннем представлении.

      Исходное значение \M"=переменной  содержит пустые множества
      \Mfield{fields} и \Mfield{statics}, множество \Mfield{escaped} изначально
      также является пустым. Однако множество \Mfield{shared} содержит
      специальный объект
      $O_{global}$.
      \[\M \gets \op{initialmemory }\Rightarrow \]
      \[\begin{split}
        \M = \{ &\Mfield{fields} = \emptyset, \Mfield{statics} = \emptyset, \\
        &\Mfield{escaped} = \emptyset,
        \Mfield{shared} = \{O_{global}\}
      \}.
      \end{split}\]

      Утекание объектов моделируется операцией, которая добавляет данные
      объекты в множество \Mfield{escaped}, причем при добавлении в множество
      \Mfield{escaped} какого-либо объекта, добавляются в множество еще и все
      объекты, доступные через поля этого объекта.
      \[ \M' \gets \op{escape}(\M, a_1, \ldots, a_N) \Rightarrow \]
      \[\begin{split}
        \M' = \M, \text{кроме } \M'.\Mfield{escaped} =
          \M.\Mfield{escaped} \cup
          \mathcal{TC}_\M(\pts{a_1} \cup \ldots \cup \pts{a_N}),
      \end{split}\]
      где $\mathcal{TC}_\M(set)$~--- это транзитивное замыкание множества
      объектов и множеств целей их полей \engdef{transitive closure}.
      $\mathcal{TC}_\M(set)$ может быть вычислено следующим образом:
      \[\left\{\begin{aligned}
        &\mathcal{TC}_\M^0(set) = set; \\
        &\mathcal{TC}_\M^{i+1}(set) = \mathcal{TC}_\M^i(set) \cup
          \smashoperator{\bigcup_{\substack{O \in \mathcal{TC}_\M^i(set)\\
                             f \in InstanceFieldDescs}}}
            \M.\Mfield{fields}(O, f); \\
        &\mathcal{TC}_\M(set) =
          \bigcup_{i \in \mathbb{N}} \mathcal{TC}_\M^i(set).
      \end{aligned}\right.\]

      В соответствии с моделью памяти \java есть операции, которые приводят к
      перечитыванию памяти. При этом все утекшие объекты становятся
      разделяемыми.
      \[ \M' \gets \op{reload}(\M) \Rightarrow \]
      \[\begin{split}
        \M' = \M, \text{кроме }
          &\M'.\Mfield{shared} = \M.\Mfield{shared} \cup
            \M.\Mfield{escaped}, \\
          &\M'.\Mfield{escaped} = \emptyset.
      \end{split}\]

      Специальное значение null соответствует пустому множеству целей
      переменной ссылочного типа:
      \[ x \gets \op{null }\Rightarrow
         \pts{x} = \emptyset. \]

      Создание нового объекта порождает уникальный абстрактный объект:
      \[ x \gets \op{new}(\type{T}) \Rightarrow
         \pts{x} = \{O_i\}. \]

      Чтение разделяемого объекта использует множество разделяемых объектов из
      \M"=переменной:
      \[ x \gets \op{shared}(\M) \Rightarrow
         \pts{x} = \M.\Mfield{shared}. \]

      Чтение статического поля возвращает множество всех разделяемых объектов в
      объединении с объектами, записанными непосредственно в это поле:
      \[ x \gets \op{getstatic}(\M, \sfield{T}{f}) \Rightarrow \]
      \[
        \pts{x} = \M.\Mfield{shared} \cup \M.\Mfield{statics}(\sfield{T}{f}).
      \]

      Запись в статическое поле $\sfield{T}{f}$ имеет более сложную семантику.
      Помимо изменения значения $\Mfield{statics}(\sfield{T}{f})$, записываемые
      объекты утекают, то есть добавляются в множество
      $\Mfield{escaped}$:
      \[ \M' \gets \op{putstatic}(\M, \sfield{T}{f}, x) \Rightarrow \]
      \[\begin{split}
        \M' = \M, \text{кроме }
          &\M'.\Mfield{statics}(\sfield{T}{f}) = \pts{x}, \\
          &\M'.\Mfield{escaped} = \M.\Mfield{escaped} \cup
          \mathcal{TC}_\M(\pts{x}).
      \end{split}\]
      Заметим, что в этом случае мы выполняем строгое присваивание, то есть мы
      не расширяем множество $\Mfield{statics}(\sfield{T}{f})$, а именно
      заменяем его новым множеством целей.

      Чтение поля из переменной $a$ возвращает множество объектов, записанных
      непосредственно в это поле. Однако, если переменная $a$ может указывать
      хоть на один разделяемый объект, то возвращаемое множество расширяется
      всеми разделяемыми объектами:
      \[ x \gets \op{getfield}(\M, a, \field{f}) \Rightarrow \]
      \[
        \pts{x} = \left( \bigcup_{O \in \pts{a}} \M.\Mfield{fields}(O,
        \field{f}) \right) \cup
        \begin{cases}
          \M.\Mfield{shared}, & \text{если } \pts{a} \cap
            \M.\Mfield{shared} \ne \emptyset; \\
          \emptyset, & \text{иначе}.
        \end{cases}
      \]

      Запись в поле $\field{f}$ переменной $a$ модифицирует значение памяти,
      расширяя множество целей $\Mfield{fields}(O, \field{f})$ для всех $O \in
      \pts{a}$, и если переменная $a$ может указывать хоть на один разделяемый
      объект, то записываемые объекты утекают. В этом случае мы не имеем права
      безусловно замещать множество целей $\Mfield{fields}(O, \field{f})$ для
      всех $O$, так как при исполнении программы реальная запись поля случится
      только для одного из объектов, но не для всех. Однако, последнее
      высказывание может подтолкнуть на мысль о том, что если множество целей
      $\pts{a} = \{O_i\}$, то есть содержит только один абстрактный объект,
      отличный от $O_{global}$, то мы можем установить множество
      $\Mfield{fields}(O_i, \field{f})$ равным $\pts{x}$.
      \[ \M' \gets \op{putfield}(\M, a, \field{f}, x) \Rightarrow \]
      \[\begin{split}
        \M' = \M,\ &\text{кроме} \\
          &\begin{split}
            \text{для всех } &O \in \pts{a}\colon
              \M'.\Mfield{fields}(O, \field{f}) =
              \pts{x}\ \cup \\
              &\cup
              \begin{cases}
                \M.\Mfield{fields}(O, \field{f}), & \text{если }
                  |\pts{a}| > 1 \vee \pts{a} = \{O_{global}\};\\
                \emptyset, & \text{иначе},
              \end{cases}
          \end{split} \\
          &\begin{split}
            \M'.&\Mfield{escaped} = \M.\Mfield{escaped}\ \cup \\
            &\cup
              \begin{cases}
                \mathcal{TC}_\M(\pts{x}), & \text{если }
                  \pts{a} \cap (\M.\Mfield{shared} \cup
                    \M.\Mfield{escaped}) \ne \emptyset;\\
                \emptyset, & \text{иначе}.
              \end{cases}
          \end{split}
      \end{split}\]

      В результате перевода программы в SSA-форму могут появиться \phi"=функции
      от переменных ссылочного типа и от \M"=переменных. Оба вида функций
      обладают довольно простой семантикой:
      \[ x \gets \op{phi}(a_1, \ldots, a_N) \Rightarrow
         \pts{x} = \bigcup_{i = 1}^N \pts{a_i}; \]
      \[ \M' \gets \op{phi}(\M_1, \ldots, \M_N) \Rightarrow \]
      \[\begin{split}
        \M' = \{
        &\Mfield{fields}(O, f) = \bigcup_{i = 1}^N \M_i.\Mfield{fields}(O, f), \\
        &\Mfield{statics}(f) = \bigcup_{i = 1}^N \M_i.\Mfield{statics}(f), \\
        &\Mfield{escaped} = \bigcup_{i = 1}^N \M_i.\Mfield{escaped}, \\
        &\Mfield{shared} = \bigcup_{i = 1}^N \M_i.\Mfield{shared}
        \}.
      \end{split}\]


    \subsection{Операции языка \texorpdfstring{\java}{Java}}
      \label{section:java_ops}

      При анализе указателей достаточно рассматривать далеко не все операции.
      Благодаря этому мы можем построить вспомогательное внутреннее
      представление только с необходимой и достаточной информацией о потоках
      данных и зависимостями по памяти.

      Приведем список всех рассматриваемых в рамках анализа указателей операций
      и их интерпретацию во вспомогательном внутреннем представлении.

      Не зависят от памяти две операции. Создание нового объекта типа
      $\type{T}$:
      \[ x \gets \op{new}(\type{T}), \]
      и присваивание специального значения null:
      \[ x \gets \op{null}. \]

      Изначальное состояние памяти (\M"=переменная) получается специальным
      образом:
      \[ \M_0 \gets \op{initialmemory}. \]
      Формальный параметр $p$ консервативно берется из разделяемой памяти
      \[ p \gets \op{shared}(\M_0). \]

      Чтение обычного поля $\field{f}$ из переменной $a$ использует
      \M"=переменную:
      \[ x \gets \op{getfield}(\M_i, a, \field{f}), \]
      аналогично имеем чтение статического поля $\sfield{T}{f}$:
      \[ x \gets \op{getstatic}(\M_i, \sfield{T}{f}). \]
      Запись переменной $x$ в обычное поле $\field{f}$ переменной $a$ порождает
      \M"=переменную:
      \[ \M_j \gets \op{putfield}(\M_i, a, \field{f}, x), \]
      аналогично порождает \M"=переменную запись в статическое поле
      $\sfield{T}{f}$:
      \[ \M_j \gets \op{putstatic}(\M_i, \sfield{T}{f}, x). \]

      Чтение и запись $i$-го элемента массива консервативно преобразуется в
      работу с синтетическим полем $\field{elements}$, которое добавляется всем
      типам"=массивам.

      Вызов функции с параметрами $p_0, \ldots, p_n$ и возвращаемым значением,
      которое записывается в переменную $x$, консервативно представляется
      следующим образом:
      \[\begin{aligned}
        \M_j &\gets \op{escape}(\M_i, p_0, \ldots, p_n); \\
        \M_k &\gets \op{reload}(\M_j); \\
        x    &\gets \op{shared}(\M_k).
      \end{aligned}\]
      Заметим, что в случае отсутствия возвращаемого значения, последнюю строку
      необходимо убрать.

      В соответствии с моделью памяти языка \java, необходимо перечитывать
      значения полей объектов перед чтением \eng{volatile} полей и при входе в
      блок синхронизации:
      \[ \M_j \gets \op{reload}(\M_i). \]

      \todo{Привести пример как простенькая программа выглядит в такой
      терминологии}

  \sectionwithoutnumber{Заключение}

    Целью данной работы являлась разработка алгоритма анализа указателей и
    синонимов для языка \java, учитывающего особенности языка и его модели
    памяти.

    В ходе работы было сделано следующее:
    \begin{itemize}
      \item Проведен анализ существующих алгоритмов анализа указателей и
            синонимов, выделены их основные отличительные характеристики.
      \item Разработана схема выражения зависимостей между операциями
            работающими с памятью: все операции языка \java, работающие с
            памятью, были выражены через набор примитивных операций, работающих
            с \M"=переменной. Семантика этих операций подробно описана и
            согласована с моделью памяти языка.
      \item Разработан внутрипроцедурный алгоритм анализа указателей,
            использующий \M"=переменную для выражения зависимостей по данным.
      \item Реализован прототип алгоритма анализа указателей в рамках проекта
            \eng{Excelsior RVM}, успешно работающий на программах без циклов.
    \end{itemize}

  \sectionwithoutnumber{Дальнейшая работа}

    В дальнейшем, в рамках магистерской работы планируется тщательно
    проработать внутреннее представление, которое будет использоваться для
    работы алгоритма анализа и хранения его результатов. От этого зависит как
    емкостная сложность алгоритма, так и временная. Данная задача становится
    особенно актуальной, так как в примитивном случае после введения
    \M"=переменных требуется хранить всю информацию о полях объектов для каждой
    такой переменной, что неприемлимо для использования в промышленном
    компиляторе.

    Не менее важно провести доказательство сходимости и корректности
    разработанного алгоритма, дать оценки его временной и емкостной сложности.

    Также планируется реализовать полнофункциональный алгоритм анализа
    указателей в рамках проекта \eng{Excelsior RVM} и провести набор
    экспериментов с целью получения практических оценок его эффективности и
    точности.


  \newpage
  \bibliographystyle{../../common/gost71u2003}
  \bibliography{../../common/biblio}

\end{document}

