\documentclass[14pt,titlepage,draft]{extarticle}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PACKAGES
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{ucs}
\usepackage[utf8x]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{indentfirst}

\usepackage{geometry}

\usepackage[usenames,dvipsnames]{color}

\usepackage{ifdraft}

\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{mathtools} % some extensions over amsmath

\usepackage{xspace} % for \xspace
\usepackage{pbox}

\usepackage{footmisc}
\renewcommand{\footnotelayout}{\small}

% prevent underfull boxes in bibliography
\usepackage{etoolbox}
\apptocmd{\sloppy}{\hbadness 10000\relax}{}{}

\usepackage[obeyDraft, textwidth=3cm, textsize=footnotesize,
  backgroundcolor=orange!50, linecolor=black!50]{todonotes}

\usepackage{float}
\newfloat{algorithm}{!htb}{loa}

% should be loaded after float and before algorithm
% to correctly link algorithms
\usepackage[pdftex,unicode,hidelinks,final]{hyperref}

\usepackage{algorithm}
\usepackage{algpseudocode}
\floatname{algorithm}{Пример}
\newcommand{\algorithmictitle}[1]{\hspace{8mm}\textbf{#1}}
\algrenewcommand{\algorithmiccomment}[1]{\hfill \textit{#1}}

\usepackage{multicol}

% should be loaded after hyperref & ams*
\usepackage[norefs,nocites,msgs]{refcheck}

\usepackage{../../common/cypokcommon}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% DOCUMENT-SPECIFIC COMMANDS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\input{../../common/gitinfo}

\newcommand{\java}{\eng{Java}\xspace}

\newcommand{\M}{\ensuremath{\mathbb{M}}}
\newcommand{\Mfield}[1]{\ensuremath{\mathrm{#1}}}

\let\mathphi\phi
\renewcommand{\phi}{\ensuremath{\mathphi}}

\newcommand{\type}[1]{\mathrm{#1}}
\newcommand{\field}[1]{\mathrm{#1}}
\newcommand{\sfield}[2]{\type{#1}.\field{#2}}
\newcommand{\method}[1]{\mathrm{#1}}
\newcommand{\smethod}[2]{\type{#1}.\method{#2}}

\newcommand{\op}[1]{\mathbf{#1}}

\newcommand{\pts}[1]{\widebar{#1}}

\newcommand{\AO}[1]{O_{#1}}
\newcommand{\AOGlobal}{\AO{global}}

\newcommand{\Lattice}{\mathcal{L}}
\newcommand{\meet}{\wedge}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% TEXT FORMAT
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\geometry{a4paper,top=2cm,bottom=2cm,bindingoffset=0cm}
\ifdraft{
  % <leftmargin> | <marginpar> | <sep> | <text> | <rightmargin>
  %    0.5cm     |     3cm     | 0.5cm |  16cm  |     1cm
  \geometry{reversemp=true,includemp=true,
            marginparwidth=3cm,marginparsep=0.5cm,
            left=0.5cm,textwidth=16cm}
}{
  % <leftmargin> | <text> | <rightmargin>
  %     3cm      |  16cm  |     2cm
  \geometry{left=3cm,textwidth=16cm}
}
\linespread{1.3}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% BODY
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{
  Применение анализа указателей и синонимов
  для оптимизации многопоточных программ
}
\author{
  Владимир Парфиненко
}

\begin{document}

  \thispagestyle{empty}
  \begin{center}
    \ifdraft{
      \
      \vspace{3cm}

      {\Large \scshape Черновик}

      \vspace{2cm}

      Работа на соискание степени магистра

      \vspace{0.2cm}

      {\large Парфиненко Владимир Владимирович}

      \vspace{1.5cm}

      {\large \scshape \bfseries
        Применение анализа указателей и синонимов\\
        для оптимизации многопоточных программ
      }

      \vfill

      Git info

      \begin{table}[!htb]
        \centering
        \begin{tabular}{rp{0.5\textwidth}}
          sha1: & \texttt{\GitAbbrHash} \\
          title:& \GitSubject \\
          date: & \GitDate
        \end{tabular}
      \end{table}
    }{
      Министерство образования и науки\\
      Российской Федерации

      \vspace{0.7cm}

      Государственное образовательное учреждение\\
      высшего профессионального образования\\
      <<Новосибирский национальный исследовательский\\
      государственный университет>> (НГУ)

      \vspace{0.7cm}

      Механико"=математический факультет

      \vspace{0.2cm}

      Кафедра программирования

      \vspace{1.2cm}

      Квалификационная работа на соискание\\
      степени магистра

      \vspace{0.5cm}

      {\large Парфиненко Владимир Владимирович}

      \vspace{1.1cm}

      {\large \scshape \bfseries
        Применение анализа указателей и синонимов\\
        для оптимизации многопоточных программ
      }

      \vspace{2.5cm}


      \hfill\pbox{\textwidth}{
        Научные руководители:\\
        м.\,н.\,с.~ИСИ~СО~РАН, Павлов~П.\,Е.,\\
        зав.\,лаб.~ИСИ~СО~РАН, к.\,т.\,н.~Шелехов~В.\,И.
      }

      \vfill

      Новосибирск 2013
    }
  \end{center}

  \listoftodos

  \tableofcontents

  \sectionwithoutnumber{Введение}

    Статический анализ программ активно применяется в оптимизирующих
    компиляторах. Одним из видов статического анализа является анализ
    указателей и синонимов. Результаты такого анализа могут быть использованы
    для усиления других видов анализа, проводимых оптимизирующим компилятором,
    и, как следствие, для повышения качества оптимизирующих преобразований.
    Таким образом может быть усилен достаточно обширный класс анализов и
    оптимизаций, как классических (таких например, как удаление общих
    подвыражений, чистка циклов, протяжка констант и присваиваний, удаление
    проверок времени исполнения), так и объектно"=ориентированных
    (девиртуализация, удаление избыточной синхронизации, \eng{escape}"=анализ,
    аллокация объектов на стеке, открытая подстановка объектов).

    Для программ, исполняемых в управляемых средах \engdef{managed
    environments}, таких, как JVM\footnote{\eng{JVM, Java Virtual Machine}~---
    виртуальная машина \java, основная часть исполняющей системы \java.}, или
    CLR\footnote{\eng{CLR, Common Language Runtime}~--- виртуальная машина,
    интерпретирующая и исполняющая код на языке CIL, в который компилируются
    программы, написанные, в частности, на .NET"=совместимых языках
    программирования.}, значение анализа указателей и синонимов для
    качественной оптимизации кода существенно возрастает. Это связано с двумя
    основными причинами. Во-первых, в управляемых средах затруднен или вообще
    отсутствует доступ программиста к низкоуровневым, небезопасным средствам
    (таким, например, как адресная арифметика и ручное управление памятью), что
    затрудняет ручную оптимизацию и вынуждает оптимизирующий компилятор
    (виртуальную машину) проводить более глубокий анализ и более аггрессивные
    оптимизации программы для достижения приемлемого уровня производительности.

    Во-вторых, любая программа в управляемой среде является многопоточной, а
    сама среда обеспечивает поддержку средств многопоточного программирования,
    таких, как потоки исполнения \engdef{threads}, атомарные операции,
    примитивы синхронизации. Более того, семантика любого участка кода
    программы (например, отдельной процедуры) более не может считаться
    независимой от многопоточной среды~--- семантика всех взаимодействий кода с
    разделяемой памятью описывается так называемой моделью памяти данного
    языка/среды, которая описывает влияние различных потоков исполнения друг на
    друга через разделяемую память и тем самым определяет корректность тех или
    иных преобразований программы~\cite{manson_jmm}. На практике это означает,
    что не всякие оптимизирующие преобразования однопоточной программы будут
    являться корректными, если рассматривать ту же программу в многопоточной
    среде. Корректное и при этом не чрезмерно препятствующее оптимизациям
    определение зависимостей и связей в программе возможно только при
    проведении нетривиального анализа указателей и синономов.

    Данная работа посвящена разработке алгоритма анализа указателей и синонимов
    для языка \java, учитывающего вышеприведенные соображения.

  \section{Постановка задачи}

    Целью данной работы является разработка алгоритма анализа указателей и
    синонимов для языка \java, учитывающего особенности языка и его модели
    памяти.

    Для достижения поставленной цели необходимо провести сравнительный анализ
    существующих алгоритмов, обосновать их сравнительную пригодность (включая
    результативность и производительность) для использования в оптимизирующем
    компиляторе. Используя эти данные, нужно разработать новый алгоритм анализа
    указателей, учитывающий особенности управляемых языков программирования.

    Разработанный алгоритм требуется реализовать на базе системы \eng{Excelsior
    Research Virtual Machine}, включающей статический компилятор и среду
    исполнения для платформы \eng{Java~SE}. В качестве пользователя анализа
    также требуется реализовать некоторую оптимизацию и провести замеры ее
    эффективности.
    \todo{про <<некоторые оптимизации>> вообще нужно? в теме-то есть слово
    <<применение>>}

  \section{Существующие алгоритмы анализа указателей}

    \emph{Анализ указателей}~--- это один из видов статического анализа,
    который определяет, на какие объекты в памяти могут указывать выражения
    ссылочного типа в программе (такие объекты называются целями выражения
    ссылочного типа). \emph{Анализ синонимов} похож на анализ указателей: его
    целью является определение, могут ли два выражения быть синонимами, то есть
    ссылаться на одно и то же место в памяти~\cite{andersen}.

    Существует множество алгоритмов анализа указателей для разных языков
    программирования~\cite{hind_pointer_analysis_not_solved_yet}. Различаются
    они по точности получаемых результатов и временной/емкостной сложности.

    В настоящее время базовыми являются два алгоритма, которые отличаются
    представлением информации о целях указателей. И именно на двух этих
    алгоритмах основываются многие другие.
    Первый~--- это алгоритм Стинсгарда, который имеет
    практически линейную временную сложность\footnote{
      Временная сложность алгоритма Стинсгарда
      $O(N \alpha(N))$, где $N$~--- размер анализируемой программы,
      $\alpha$~--- обратная функция Аккермана. Она является очень медленно
      растущей, и при анализе асимптотики алгоритмов можно принять ее за
      константу.
    }~\cite{steensgaard}. Однако этот алгоритм предоставляет существенно менее
    точные результаты по сравнению со вторым алгоритмом, алгоритмом
    Андерсена. Хотя этот алгоритм и потребляет время, в худшем случае
    пропорциональное кубу от размера программы~\cite{andersen}, на практике оба
    алгоритма имеют сравнимую скорость работы при анализе небольших программ
    (до \num{3000} строк)~\cite{shapiro_fast_and_accurate}.

    Разработанный в данной работе алгоритм анализа основывается на идеях
    алгоритма Андерсена, так как точность алгоритма Стинсгарда не является
    достаточной для статического компилятора управляемого языка
    программирования.

    Для сравнения точности алгоритмов анализа указателей необходимо ввести
    некую меру точности. В качестве простой меры точности алгоритма часто
    используется усредненное количество синонимов для всех переменных
    ссылочного типа, появляющихся в
    программе~\cite[раздел~3.2]{hind_pointer_analysis_not_solved_yet}
    (также существуют и более изощренные
    меры~\cite{hind_pointer_analysis_not_solved_yet,diwan_tbaa}).
    Понятно, что для <<идеального>> алгоритма анализа это число будет
    минимальным, а для самого консервативного алгоритма~--- максимальным.

  \subsection{Чувствительные к потоку управления алгоритмы}

    Важной характеристикой алгоритмов анализа указателей является
    чувствительность к потоку управления в программе
    \engdef{flow"=sensitivity}.

    Алгоритм анализа, \emph{чувствительный к потоку управления}, работает с
    графом потока управления программы, и результирующая информация о целях
    выражений приписывается каждой отдельной операции. За счет этого анализ
    учитывает только те последовательности исполнения операций, которые
    действительно реализуемы.

    \emph{Нечувствительный к потоку управления} алгоритм анализа рассматривает
    программу как неупорядоченный набор операций. Такой алгоритм
    консервативно полагает, что операции могут идти в произвольном порядке и
    повторяться произвольное количество раз.

    Алгоритм анализа, чувствительный к потоку управления, дает более точные
    результаты, при этом потребляя значительно больше ресурсов, таких как
    память и время~\cite[раздел.~4.4]{hind_pointer_analysis_not_solved_yet}.
    Такое потребление ресурсов является достаточным для отказа от
    использования на практике подобных алгоритмов анализа в статическом
    компиляторе.

    Поэтому алгоритм, разработанный в рамках этой работы, является
    нечувствительным к потоку управления. Однако ухудшение точности при таком
    выборе может быть также неприемлимым.
    Для решения этой проблемы и получения сравнимой точности пришлось
    существенно модифицировать внутреннее представление программы, с которым
    будет работать алгоритм анализа указателей. Эти изменения описаны в
    разделе~\todoref.

  \subsection{Межпроцедурные алгоритмы}

    Не менее важной чертой алгоритмов анализа является то, как они
    обрабатывают вызовы подпрограмм.

    \emph{Внутрипроцедурные алгоритмы} при анализе отдельной процедуры не
    выходят за ее пределы и все вызовы обрабатывают консервативно: полагается,
    что может исполняться абсолютно произвольный набор операций, модифицирующий
    поля всех разделяемых объектов.

    \emph{Межпроцедурный алгоритм} анализа при обработке вызова может
    предварительно провести анализ вызываемой подпрограммы и как-либо учесть
    эту информацию.

    Понятно, что межпроцедурный алгоритм дает более точные результаты,
    а внутрипроцедурный потребляет существенно меньше времени и
    памяти~\cite[с.~117]{andersen}.

    Также нужно заметить, что при рассмотрении управляемых языков
    программирования, где большинство вызовов является виртуальными,
    межпроцедурный алгоритм анализа дополнительно усложняется. Поэтому в
    данной работе будет описан внутрипроцедурный алгоритм, хотя и реализация
    межпроцедурной его версии не исключается в будущих работах.

  \section{Алгоритм анализа указателей}

    В этой секции описан разработанный алгоритм анализа указателей. Он является
    внутрипроцедурным и нечувствительным к потоку управления. Основой алгоритма
    является проведение потокового анализа на графе потока данных программы.

  \subsection{Внутреннее представление}

    Сначала необходимо описать внутреннее представление, с которым работает
    алгоритм. Программа представляется неупорядоченным набором операций в
    SSA-форме\footnote{
      Будем говорить, что программа находится в SSA-форме (\eng{Static Single
      Assignment}), если существует не более одного присваивания в любую из
      переменных~\cite{ssa}.
      Любую программу можно перевести в SSA-форму посредством
      версионирования переменных и расстановки \phi-функций~\cite{ssa}.
      Для перевода в SSA-форму и вывода из нее существуют эффективные
      алгоритмы~\cite{bilardi_ssa, briggs_ssa}.
    }, которые в общем случае имеют вид:
    \[ var \gets \op{operation}[id_1, \ldots, id_M](arg_1, \ldots, arg_N), \]
    где
    $N \geq 0$~--- количество аргументов операции;
    $arg_i$~--- $i$-ый аргумент операции (переменная);
    $M \geq 0$~--- количество константных параметров операции;
    $id_i$~--- $i$-ый параметр (идентификатор типа, поля или метода);
    $var$~--- результат операции (переменная, может отсутствовать).
    Множество операций представлено в разделе~\ref{section:java_ops}.

    Изначально алгоритм строит ориентированный \emph{граф потока данных}
    $G = (V, E)$. Множество $V$~--- это множество всех операций внутреннего
    представления программы.
    Множество $E \subseteq V^2$ представляет связи между операциями:
    $(u, v) \in E$ тогда и только тогда, когда операция $v$ имеет своим
    аргументов результат операции $u$.

    На этом графе потока данных алгоритм будет проводить потоковый анализ.

  \subsection{Абстрактные объекты}

    Определим потоковое свойство, с которым будет работать потоковый анализ.

    Определим множество \emph{абстрактных объектов}, которые являются
    целями указателей при проведении анализа.
    Такие объекты будем обозначать как $\AO{idx} \in AbstractObjects$;
    множество целей, на которые может указывать переменная ссылочного типа $x$,
    будем обозначать $\pts{x} \subseteq AbstractObjects$.

    Основным свойством абстрактных объектов является то, что два различных
    абстрактных объекта символизируют разные объекты в памяти при исполнении
    программы. Это позволяет определять возможность синонимичности двух
    выражений ссылочного типа $x$ и $y$: они могут быть синонимыми тогда и
    только тогда, когда $\pts{x} \cap \pts{y} \ne \emptyset$.

    Источниками абстрактных объектов служат операции создания новых объектов:
    каждой из таких операций сопоставляется заведомо уникальный абстрактный
    объект.
    Объекты, приходящие в метод извне (формальные параметры, результат вызова и
    др.), представляются с помощью одного специального абстрактного объекта
    $\AOGlobal$. Таким образом консервативно полагается, что все значения,
    приходящие извне анализируемого метода могут быть синонимами.

    Для решения задачи потокового анализа зададим полурешетку свойств\footnote{
      Полурешетки и их свойства подробно описаны в~\cite{muchnick}.
    }
    $\Lattice_{AO} = (L, \meet)$, где $L = \powerset{AbstractObjects}$.
    Оператор $\meet$ определим следующим образом
    \[\forall x \in L, \forall y \in L \colon x \meet y = x \cup y,\]
    тогда отношения $\leq$ и $<$ имеют вид:
    \begin{align*}
    x \leq y &\Leftrightarrow y \subseteq x, \\
    x < y &\Leftrightarrow y \subset x.
    \end{align*}
    Соответственно нижний элемент $\bot = AbstractObjects$
    и верхний элемент $\top = \emptyset$.

    Заметим, что мощность множества абстрактных объектов для любого
    метода конечна и равна $M + 1$,
    где $M$~--- количество операций создания новых объектов, которое ограничено
    размером анализируемого метода.

    Из этого следует конечность множества значений свойств полурешетки,
    что дает конечную высоту полурешетки и гарантирует обрывание всех строго
    убывающих цепей.

  \subsection{Абстрактные объекты}

    \todo{section: Нечувствительный к потоку управления получит плохие результаты.}

    \todo{section: Учет JMM, появление reload'ов.}

  \subsection{Базовые операции языка \texorpdfstring{\java}{Java}}
    \label{section:java_ops}

    В таблице~\ref{tabular:basic_operations} приведен список базовых операций
    языка \java и их внутреннее представление для алгоритма анализа.
    Представление некоторых других операций будет дано в этом и последующих
    разделах, а семантика всех операций будет подробно описана в
    разделе~\todoref.

    \begin{table}[htb]
      \centering

      \begin{tabular}{|p{0.6\textwidth}|p{0.3\textwidth}|}\hline
        \textbf{\java операция} &
          \textbf{Внутреннее представление}\\ \hline

        получение формального параметра ссылочного типа
        & $a \gets \op{shared}$
        \\ \hline

        получение нулевого указателя
        & $a \gets \op{null}$
        \\ \hline

        \phi-функция ссылочного типа
        & $a \gets \op{phi}(b_1, \ldots, b_N)$
        \\ \hline

        создание нового объекта типа $\type{T}$
        & $a \gets \op{new}[\type{T}]$
        \\ \hline

        чтение поля ссылочного типа $\field{f}$ объекта $a$
        & $a \gets \op{getfield}[\field{f}](a)$
        \\ \hline

        чтение статического поля ссылочного типа $\sfield{T}{f}$
        & $a \gets \op{getstatic}[\sfield{T}{f}]$
        \\ \hline

        запись в поле $\field{f}$ объекта $a$ значения ссылочного типа $b$
        & $\op{putfield}[\field{f}](a, b)$
        \\ \hline

        запись в статическое поле $\sfield{T}{f}$ значения ссылочного типа $b$
        & $\op{putstatic}[\sfield{T}{f}](b)$
        \\ \hline

      \end{tabular}
      \caption{Базовые операции языка \java и их внутреннее представление}
      \label{tabular:basic_operations}
    \end{table}

    Заметим, что операция присваивания одной переменной в другую отсутствует.
    Это связано с тем, что для программы в SSA-форме все копии переменных
    тривиальным образом могут быть удалены~\cite{ssa}.

    Вызов метода с параметрами ссылочного типа $p_1, \ldots, p_N$, возращающего
    значение ссылочного типа $a$ (параметры и вовращаемое значение могут
    отсутствовать) интерпретируется как пара операций:
    \begin{gather}
      \op{escape}(p_1, \ldots, p_N), \\
      a \gets \op{shared}.
    \end{gather}

    Чтение и запись $i$-го элемента массива консервативно преобразуется в
    работу с синтетическим полем $\field{elements}$, которое добавляется всем
    типам"=массивам.

  \subsection{SSA-форма повышает точность}

  \subsection{\texorpdfstring{\M}{M}"=переменная}

  \subsection{Потоковый анализа со всей наукой}


  \section{Выражение зависимости по памяти}
    \label{section:m_variable}

    Одним из способов выражения зависимостей по памяти является введение
    явной переменной, олицетворяющей образ всей памяти. Значение этой
    переменной может использоваться в качестве аргумента в операциях, читающих
    память, и порождаться в операциях, пишущих в память.

  \subsection{\texorpdfstring{\M}{M}"=переменная}

    Введем специальную переменную, \M"=переменную. Значение \M"=переменной
    есть образ памяти, который, в частности, может использоваться операциями
    чтения полей объектов и может модифицироваться операциями записи в поля
    объектов. Для наглядности рассмотрим простой пример~\ref{code:m_var}
    программы, которая использует \M"=переменную\footnote{
      Здесь и далее будем использовать следующую структуру инструкций
      псевдокода: $var \gets \op{operation}(arg_1, \ldots, arg_N)$, где
      $var$~--- некоторая переменная, $arg_i$~--- либо переменная, либо
      идентификатор типа, либо идентификатор поля.}.

    \begin{algorithm}
      \caption{Пример использования \M"=переменной}
      \label{code:m_var}
      \begin{algorithmic}[1]
        \If{\ldots}
          \State $\M \gets \op{putfield}(\M, a, \field{f}, x)$
        \Else
          \State $\M \gets \op{putfield}(\M, a, \field{f}, y)$
        \EndIf
        \State $z \gets \op{getfield}(\M, a, \field{f})$
      \end{algorithmic}
    \end{algorithm}

    В этом примере для чтения и записи поля $\field{f}$ переменной $a$
    используются специально введенные операции getfield и putfield. Операция
    getfield в качестве аргументов имеет \M"=переменную, ссылку на объект и
    идентификатор поля и возвращает значение поля объекта из данного
    образа памяти. Операция putfield имеет те же первые аргументы и один
    дополнительный аргумент: значение, которое записывается в поле объекта;
    эта операция возвращает \M"=переменную, которая соответствует образу
    памяти с измененным значением поля.

    Заметим, что программу с введенной \M"=переменной можно перевести в
    SSA-форму, трактуя ее как обычную переменную. Пример~\ref{code:m_var_ssa}
    является примером~\ref{code:m_var}, переведенным в SSA-форму.

    \begin{algorithm}
      \caption{Пример SSA-формы программы с \M"=переменной}
      \label{code:m_var_ssa}
      \begin{algorithmic}[1]
        \If{\ldots}
          \State $\M_1 \gets \op{putfield}(\M_0, a, \field{f}, x)$
        \Else
          \State $\M_2 \gets \op{putfield}(\M_0, a, \field{f}, y)$
        \EndIf
        \State $\M_3 \gets \op{phi}(\M_1, \M_2)$
        \State $z \gets \op{getfield}(\M_3, a, \field{f})$
      \end{algorithmic}
    \end{algorithm}

    После перевода в SSA-форму естественным образом появляется \phi"=функция
    от \M"=переменных, семантика которой эквивалентна семантике \phi"=функции
    от обычных переменных.

    Важно понимать, что на самом деле \M"=переменная является некоторой
    абстракцией памяти. Она не присутствует в явном виде в исходном коде
    программы и должна быть специально введена на некотором этапе компиляции
    программы. Аналогично, эта переменная не имеет никакого физического
    воплощения в машинном коде и должна быть удалена при кодогенерации.

  \subsection{Анализ указателей с \texorpdfstring{\M}{M}"=переменной}

    В этой секции покажем, как введение \M"=переменной и перевод программы в
    SSA-форму позволяют повысить точность анализа указателей. Для этого еще
    раз рассмотрим примеры, приведенные в
    разделе~\ref{section:previous_work}, используя в них \M"=переменную.

    В примерах помимо операций getfield и putfield, которые были введены
    ранее, понадобятся и другие операции, такие как putstatic, escape, reload
    и другие; их семантика подробно описана в
    разделе~\ref{section:ops_semantic}.

    Рассмотрим пример~\ref{code:m_var_flow_sensitivity_1}. Теперь видно, что
    на самом деле чтение поля в переменную $a$ отличается от чтения в
    переменную $b$, операции getfield используют разные версий
    \M"=переменной, читают из разного состояния памяти. Поэтому в данном
    случае при оптимальной интерпретации \M"=переменной алгоритм сможет
    понять, что $a$ и $b$ и вовсе не могут быть синонимами.

    \begin{algorithm}
      \caption{Чувствительность к потоку управления при работе с
        полями объектов}
      \label{code:m_var_flow_sensitivity_1}
      \begin{algorithmic}[1]
        \State $x \gets \op{new}(\type{T})$
        \State $t_0 \gets \op{new}(\type{Object})$
        \State $\M_1 \gets \op{putfield}(\M_0, x, \field{f}, t_0)$
        \State $a \gets \op{getfield}(\M_1, x, \field{f})$
        \State $t_1 \gets \op{new}(\type{Object})$
        \State $\M_2 \gets \op{putfield}(\M_1, x, \field{f}, t_1)$
        \State $b \gets \op{getfield}(\M_2, x, \field{f})$
      \end{algorithmic}
    \end{algorithm}

    Теперь рассмотрим пример~\ref{code:m_var_flow_sensitivity_2}.
    Получается, что сделав \M"=переменную аргументом операций shared и
    escape, алгоритм может давать более точные результаты. В данном случае
    можно получить, что $a$ и $b$ не являются синонимами, хотя значение
    переменной $b$ получается из разделяемой памяти, а переменная $a$
    является утекшей. Благодаря \M"=переменной мы можем понять, что данные
    действия выполнялись именно в таком порядке, и на момент получения
    значения из разделяемой памяти $a$ не являлась утекшей переменной.

    \todo{в конце примера~\ref{code:m_var_flow_sensitivity_2} должен быть
      $\op{reload}$, пока это не важно}
    \begin{algorithm}
      \caption{Чувствительность к потоку управления при работе с
        разделяемой памятью}
      \label{code:m_var_flow_sensitivity_2}
      \begin{algorithmic}[1]
        \State $a \gets \op{new}(\type{Object})$
        \State $b \gets \op{shared}(\M_0)$
          \Comment{получение объекта из разделяемой памяти}
        \State $\M_1 \gets \op{escape}(\M_0, a)$
          \Comment{утекание объекта в разделяемую память}
      \end{algorithmic}
    \end{algorithm}

    Рассмотрим пример~\ref{code:m_var_multithreading}, который на самом деле
    является более изощренной версией
    примера~\ref{code:m_var_flow_sensitivity_2}. В нем происходит утекание
    $x$ в строке~\ref{code:m_var_multithreading:escaping}, однако важно
    понимать, что из-за особенностей модели памяти языка \java, объект
    утекает, но значения его полей мы имеем право не перечитывать вплоть до
    выполнения одной из операций, приводящих к перечитыванию полей
    разделяемых объектов. В данном случае такая операция есть в
    строке~\ref{code:m_var_multithreading:reload}, и за счет того, что
    значения переменных $a$ и $b$ получаются из версий памяти до и после
    операции перечитывания полей, в первом случае $\pts{a}$ будет
    совпадать с $\pts{t_0}$, однако $\pts{b}$ будет равен $\pts{t_0}$ в
    объединении с множеством всех разделяемых объектов. Заметим, что
    нечувствительный к потоку управления алгоритм анализа сможет получить
    такой результат при оптимальной интерпретации операций с \M"=переменной.

    \begin{algorithm}
      \caption{Отсутствие консерватизма при чтении полей разделяемых
        объектов}
      \label{code:m_var_multithreading}
      \begin{algorithmic}[1]
        \State $x \gets \op{new}(\type{T})$
        \State $t_0 \gets \op{new}(\type{Object})$
        \State $\M_1 \gets \op{putfield}(\M_0, x, \field{f}, t_0)$
        \State $\M_2 \gets \op{putstatic}(\M_1, \sfield{T}{f}, x)$
          \Comment{утекание $x$ в статическое поле класса}
          \label{code:m_var_multithreading:escaping}
        \State $a \gets \op{getfield}(\M_2, x, \field{f})$
        \State $\M_3 \gets \op{reload}(\M_2)$
          \Comment{операция, приводящая к перечитыванию полей}
          \label{code:m_var_multithreading:reload}
        \State $b \gets \op{getfield}(\M_3, x, \field{f})$
      \end{algorithmic}
    \end{algorithm}

    Однако не стоит полагать, что нечувствительный к потоку управления
    алгоритм анализа, работающий с SSA-формой и \M"=переменной, сможет
    заменить чувствительный к потоку управления анализ. Существуют примеры,
    когда алгоритму нужно больше информации о программе, чем дает
    \M"=переменная.

    \todo{Примеры, когда даже \M"=переменная не помогает}

  \section{Алгоритм анализа указателей}

    Алгоритм анализа указателей работает со вспомогательным внутренним
    представлением, которое позволяет эффективно проводить анализ и хранить его
    результаты.

    Вспомогательное внутреннее представление содержит неупорядоченное множество
    операций вида
    \[ var \gets \op{operation}(arg_1, \ldots, arg_N), \]
    где $var$~--- некоторая переменная, $arg_i$~--- либо переменная, либо
    идентификатор типа, либо идентификатор поля, а $\op{operation}$~--- одна из
    операций, описанных далее в разделе~\ref{section:ops_semantic}.

    Множество таких операций строится по множеству всех операций
    анализируемого метода в соответствии с тем, как это описано далее в
    разделе~\ref{section:java_ops}.

    Алгоритм проводит потоковый анализ: имея изначально пустные
    множества целей переменных ссылочного типа, происходят итерации по
    множеству операций вспомогательного внутреннго представления, во время
    которых каждая операция интерпретируется в соответствии с ее семантикой,
    описанной далее в разделе~\ref{section:ops_semantic}. Алгоритм проводит
    итерации пока множества целей переменных и полей объектов изменяются и
    прекращает свою работу, когда результаты достигают неподвижной точки.


  \subsection{Семантика операций}
    \label{section:ops_semantic}

    Ключевыми понятиями анализа являются абстрактные объекты и их множества.
    Абстрактные объекты будем обозначать буквой $O$; множество целей, на
    которые может указывать переменная $x$, будем обозначать $\pts{x}$.

    $AbstractObjects$~--- это множество всех абстрактных объектов. Оно
    состоит из уникальных объектов, соответствующих операциям создания
    объекта, и одного специального объекта $\AOGlobal$, который олицетворяет
    все объекты, созданные вне анализируемого метода.

    Для хранения результатов анализа вспомогательное внутреннее представление
    содержит информацию о множестве целей всех переменных ссылочного
    типа и информацию о состояниях памяти в виде структур, соответствующих
    версиям \M"=переменной.

    Опишем такую структуру, соответствующую \M"=переменной. Во-первых, она
    содержит информацию о множестве целей полей объектов:
    \[ \M.\Mfield{fields}\colon
      AbstractObjects \times InstanceFieldDescs \to
      \powerset{AbstractObjects},
    \]
    где $InstanceFieldDescs$~--- это множество идентификаторов полей
    объектов.  Аналогично хранится информация о множестве целей статических
    полей:
    \[ \M.\Mfield{statics}\colon
      StaticFieldDescs \to \powerset{AbstractObjects},
    \]
    где $StaticFieldDescs$~--- это множество идентификаторов
    статических полей.

    Заметим, что, во-первых, эти отображения можно рассматривать как
    множества.  А во-вторых, эти отображения будут иметь умолчательное
    значение: если у нас не определено отображение для некоторого значения,
    то образ этого значения есть пустое множество.\todo{Мысль понятна, как
    переформулировать?}

    Во-вторых, \M"=переменная должна содержать информацию о разделяемых
    объектах и об объектах, которые утекут \engdef{escape} из метода и станут
    разделяемыми. Для представления этой информации хранится два множества
    объектов: объекты (\eng{shared}), которые утекли из метода и уже являются
    разделяемыми (консервативно предполагается, что эти объекты могут быть
    прочитаны из любой разделяемой памяти), и объекты (\eng{escaped}),
    которые утекли, но еще не являются разделяемыми.
    \[ \M.\Mfield{shared} \in \powerset{AbstractObjects}; \]
    \[ \M.\Mfield{escaped} \in \powerset{AbstractObjects}. \]

    Теперь опишем все операции, которые используются во вспомогательном
    внутреннем представлении.

    Исходное значение \M"=переменной  содержит пустые множества
    \Mfield{fields} и \Mfield{statics}, множество \Mfield{escaped} изначально
    также является пустым. Однако множество \Mfield{shared} содержит
    специальный объект
    $\AOGlobal$.
    \[\M \gets \op{initialmemory }\Rightarrow \]
    \[\begin{split}
      \M = \{ &\Mfield{fields} = \emptyset, \Mfield{statics} = \emptyset, \\
      &\Mfield{escaped} = \emptyset,
      \Mfield{shared} = \{\AOGlobal\}
    \}.
    \end{split}\]

    Утекание объектов моделируется операцией, которая добавляет данные
    объекты в множество \Mfield{escaped}, причем при добавлении в множество
    \Mfield{escaped} какого-либо объекта, добавляются в множество еще и все
    объекты, доступные через поля этого объекта.
    \[ \M' \gets \op{escape}(\M, a_1, \ldots, a_N) \Rightarrow \]
    \[\begin{split}
      \M' = \M, \text{кроме } \M'.\Mfield{escaped} =
        \M.\Mfield{escaped} \cup
        \mathcal{TC}_\M(\pts{a_1} \cup \ldots \cup \pts{a_N}),
    \end{split}\]
    где $\mathcal{TC}_\M(set)$~--- это транзитивное замыкание множества
    объектов и множеств целей их полей \engdef{transitive closure}.
    $\mathcal{TC}_\M(set)$ может быть вычислено следующим образом:
    \[\left\{\begin{aligned}
      &\mathcal{TC}_\M^0(set) = set; \\
      &\mathcal{TC}_\M^{i+1}(set) = \mathcal{TC}_\M^i(set) \cup
        \smashoperator{\bigcup_{\substack{O \in \mathcal{TC}_\M^i(set)\\
                           f \in InstanceFieldDescs}}}
          \M.\Mfield{fields}(O, f); \\
      &\mathcal{TC}_\M(set) =
        \bigcup_{i \in \mathbb{N}} \mathcal{TC}_\M^i(set).
    \end{aligned}\right.\]

    В соответствии с моделью памяти \java есть операции, которые приводят к
    перечитыванию памяти. При этом все утекшие объекты становятся
    разделяемыми.
    \[ \M' \gets \op{reload}(\M) \Rightarrow \]
    \[\begin{split}
      \M' = \M, \text{кроме }
        &\M'.\Mfield{shared} = \M.\Mfield{shared} \cup
          \M.\Mfield{escaped}, \\
        &\M'.\Mfield{escaped} = \emptyset.
    \end{split}\]

    Специальное значение null соответствует пустому множеству целей
    переменной ссылочного типа:
    \[ x \gets \op{null }\Rightarrow
       \pts{x} = \emptyset. \]

    Создание нового объекта порождает уникальный абстрактный объект:
    \[ x \gets \op{new}(\type{T}) \Rightarrow
       \pts{x} = \{O_i\}. \]

    Чтение разделяемого объекта использует множество разделяемых объектов из
    \M"=переменной:
    \[ x \gets \op{shared}(\M) \Rightarrow
       \pts{x} = \M.\Mfield{shared}. \]

    Чтение статического поля возвращает множество всех разделяемых объектов в
    объединении с объектами, записанными непосредственно в это поле:
    \[ x \gets \op{getstatic}(\M, \sfield{T}{f}) \Rightarrow \]
    \[
      \pts{x} = \M.\Mfield{shared} \cup \M.\Mfield{statics}(\sfield{T}{f}).
    \]

    Запись в статическое поле $\sfield{T}{f}$ имеет более сложную семантику.
    Помимо изменения значения $\Mfield{statics}(\sfield{T}{f})$, записываемые
    объекты утекают, то есть добавляются в множество
    $\Mfield{escaped}$:
    \[ \M' \gets \op{putstatic}(\M, \sfield{T}{f}, x) \Rightarrow \]
    \[\begin{split}
      \M' = \M, \text{кроме }
        &\M'.\Mfield{statics}(\sfield{T}{f}) = \pts{x}, \\
        &\M'.\Mfield{escaped} = \M.\Mfield{escaped} \cup
        \mathcal{TC}_\M(\pts{x}).
    \end{split}\]
    Заметим, что в этом случае мы выполняем строгое присваивание, то есть мы
    не расширяем множество $\Mfield{statics}(\sfield{T}{f})$, а именно
    заменяем его новым множеством целей.

    Чтение поля из переменной $a$ возвращает множество объектов, записанных
    непосредственно в это поле. Однако, если переменная $a$ может указывать
    хоть на один разделяемый объект, то возвращаемое множество расширяется
    всеми разделяемыми объектами:
    \[ x \gets \op{getfield}(\M, a, \field{f}) \Rightarrow \]
    \[
      \pts{x} = \left( \bigcup_{O \in \pts{a}} \M.\Mfield{fields}(O,
      \field{f}) \right) \cup
      \begin{cases}
        \M.\Mfield{shared}, & \text{если } \pts{a} \cap
          \M.\Mfield{shared} \ne \emptyset; \\
        \emptyset, & \text{иначе}.
      \end{cases}
    \]

    Запись в поле $\field{f}$ переменной $a$ модифицирует значение памяти,
    расширяя множество целей $\Mfield{fields}(O, \field{f})$ для всех $O \in
    \pts{a}$, и если переменная $a$ может указывать хоть на один разделяемый
    объект, то записываемые объекты утекают. В этом случае мы не имеем права
    безусловно замещать множество целей $\Mfield{fields}(O, \field{f})$ для
    всех $O$, так как при исполнении программы реальная запись поля случится
    только для одного из объектов, но не для всех. Однако, последнее
    высказывание может подтолкнуть на мысль о том, что если множество целей
    $\pts{a} = \{O_i\}$, то есть содержит только один абстрактный объект,
    отличный от $\AOGlobal$, то мы можем установить множество
    $\Mfield{fields}(O_i, \field{f})$ равным $\pts{x}$.
    \[ \M' \gets \op{putfield}(\M, a, \field{f}, x) \Rightarrow \]
    \[\begin{split}
      \M' = \M,\ &\text{кроме} \\
        &\begin{split}
          \text{для всех } &O \in \pts{a}\colon
            \M'.\Mfield{fields}(O, \field{f}) =
            \pts{x}\ \cup \\
            &\cup
            \begin{cases}
              \M.\Mfield{fields}(O, \field{f}), & \text{если }
                |\pts{a}| > 1 \vee \pts{a} = \{\AOGlobal\};\\
              \emptyset, & \text{иначе},
            \end{cases}
        \end{split} \\
        &\begin{split}
          \M'.&\Mfield{escaped} = \M.\Mfield{escaped}\ \cup \\
          &\cup
            \begin{cases}
              \mathcal{TC}_\M(\pts{x}), & \text{если }
                \pts{a} \cap (\M.\Mfield{shared} \cup
                  \M.\Mfield{escaped}) \ne \emptyset;\\
              \emptyset, & \text{иначе}.
            \end{cases}
        \end{split}
    \end{split}\]

    В результате перевода программы в SSA-форму могут появиться \phi"=функции
    от переменных ссылочного типа и от \M"=переменных. Оба вида функций
    обладают довольно простой семантикой:
    \[ x \gets \op{phi}(a_1, \ldots, a_N) \Rightarrow
       \pts{x} = \bigcup_{i = 1}^N \pts{a_i}; \]
    \[ \M' \gets \op{phi}(\M_1, \ldots, \M_N) \Rightarrow \]
    \[\begin{split}
      \M' = \{
      &\Mfield{fields}(O, f) = \bigcup_{i = 1}^N \M_i.\Mfield{fields}(O, f), \\
      &\Mfield{statics}(f) = \bigcup_{i = 1}^N \M_i.\Mfield{statics}(f), \\
      &\Mfield{escaped} = \bigcup_{i = 1}^N \M_i.\Mfield{escaped}, \\
      &\Mfield{shared} = \bigcup_{i = 1}^N \M_i.\Mfield{shared}
      \}.
    \end{split}\]


  \subsection{Операции языка \texorpdfstring{\java}{Java}}

    При анализе указателей достаточно рассматривать далеко не все операции.
    Благодаря этому мы можем построить вспомогательное внутреннее
    представление только с необходимой и достаточной информацией о потоках
    данных и зависимостями по памяти.

    Приведем список всех рассматриваемых в рамках анализа указателей операций
    и их интерпретацию во вспомогательном внутреннем представлении.

    Не зависят от памяти две операции. Создание нового объекта типа
    $\type{T}$:
    \[ x \gets \op{new}(\type{T}), \]
    и присваивание специального значения null:
    \[ x \gets \op{null}. \]

    Изначальное состояние памяти (\M"=переменная) получается специальным
    образом:
    \[ \M_0 \gets \op{initialmemory}. \]
    Формальный параметр $p$ консервативно берется из разделяемой памяти
    \[ p \gets \op{shared}(\M_0). \]

    Чтение обычного поля $\field{f}$ из переменной $a$ использует
    \M"=переменную:
    \[ x \gets \op{getfield}(\M_i, a, \field{f}), \]
    аналогично имеем чтение статического поля $\sfield{T}{f}$:
    \[ x \gets \op{getstatic}(\M_i, \sfield{T}{f}). \]
    Запись переменной $x$ в обычное поле $\field{f}$ переменной $a$ порождает
    \M"=переменную:
    \[ \M_j \gets \op{putfield}(\M_i, a, \field{f}, x), \]
    аналогично порождает \M"=переменную запись в статическое поле
    $\sfield{T}{f}$:
    \[ \M_j \gets \op{putstatic}(\M_i, \sfield{T}{f}, x). \]

    Чтение и запись $i$-го элемента массива консервативно преобразуется в
    работу с синтетическим полем $\field{elements}$, которое добавляется всем
    типам"=массивам.

    Вызов функции с параметрами $p_0, \ldots, p_n$ и возвращаемым значением,
    которое записывается в переменную $x$, консервативно представляется
    следующим образом:
    \[\begin{aligned}
      \M_j &\gets \op{escape}(\M_i, p_0, \ldots, p_n); \\
      \M_k &\gets \op{reload}(\M_j); \\
      x    &\gets \op{shared}(\M_k).
    \end{aligned}\]
    Заметим, что в случае отсутствия возвращаемого значения, последнюю строку
    необходимо убрать.

    В соответствии с моделью памяти языка \java, необходимо перечитывать
    значения полей объектов перед чтением \eng{volatile} полей и при входе в
    блок синхронизации:
    \[ \M_j \gets \op{reload}(\M_i). \]

    \todo{Привести пример как простенькая программа выглядит в такой
    терминологии}

  \sectionwithoutnumber{Заключение}

    Целью данной работы являлась разработка алгоритма анализа указателей и
    синонимов для языка \java, учитывающего особенности языка и его модели
    памяти.

    В ходе работы было сделано следующее:
    \begin{itemize}
      \item Проведен анализ существующих алгоритмов анализа указателей и
            синонимов, выделены их основные отличительные характеристики.
      \item Разработана схема выражения зависимостей между операциями
            работающими с памятью: все операции языка \java, работающие с
            памятью, были выражены через набор примитивных операций, работающих
            с \M"=переменной. Семантика этих операций подробно описана и
            согласована с моделью памяти языка.
      \item Разработан внутрипроцедурный, нечувствительный к потоку управления
            алгоритм анализа указателей, использующий \M"=переменную для
            выражения зависимостей по данным.
      \item Реализован алгоритма анализа указателей в рамках проекта
            \eng{Excelsior RVM} и оптимизация удаления избыточных чтений полей
            объектов, использующая результаты анализа.
    \end{itemize}

  \sectionwithoutnumber{Дальнейшая работа}

    В дальнейшем планируется реализовать представленный алгоритм анализа
    указателей в промышленном статическом компиляторе языка \java в
    рамках проекта \eng{Excelsior JET}. Потребуется проведение более
    тщательного комплексного тестирования и поддержки некоторых дополнительных
    возможностей компилятора, которые не вошли в данную работу.

    Также планируется дальнейшее усовершенствование алгоритма для
    проведения межпроцедурного анализа указателей.


  \newpage
  \bibliographystyle{../../common/gost71u2003}
  \bibliography{../../common/biblio}

\end{document}

