\documentclass[14pt,titlepage,final]{extarticle}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PACKAGES
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage[pdftex,unicode,hidelinks,final]{hyperref}
\usepackage{ucs}
\usepackage[utf8x]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{indentfirst}

\usepackage{geometry}

\usepackage[usenames,dvipsnames]{color}

\usepackage{ifdraft}

\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{mathtools} % some extensions over amsmath

\usepackage{xspace} % for \xspace
\usepackage{hyphenat} % for \hyp

\usepackage{footmisc}
\renewcommand{\footnotelayout}{\small}

\usepackage{etoolbox}
\apptocmd{\sloppy}{\hbadness 10000\relax}{}{}

\usepackage[obeyDraft, textwidth=2.5cm, textsize=footnotesize,
  backgroundcolor=orange!50, linecolor=black!50]{todonotes}

\usepackage{cypokcommon}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% DOCUMENT-SPECIFIC COMMANDS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\input{../../gitinfo.tex}

\newcommand{\java}{\eng{Java}\xspace}

\newcommand{\M}{\mathbb{M}}
\newcommand{\Mhyp}{$\M$\hyp}
\newcommand{\Mfield}[1]{\ensuremath{\mathrm{#1}}}

\newcommand{\phihyp}{$\phi$\hyp}

\newcommand{\type}[1]{\mathrm{#1}}
\newcommand{\field}[1]{\mathrm{#1}}
\newcommand{\sfield}[2]{\type{#1}.\field{#2}}

\newcommand{\pts}[1]{\widebar{#1}}

\newcommand{\assig}{\leftarrow}

\newcommand{\irOp}[1]{\mathbf{#1}}
\newcommand{\NEW}{\irOp{new}}
\newcommand{\NULL}{\irOp{null}}
\newcommand{\INITIALMEMORY}{\irOp{initialmemory}}
\newcommand{\GETFIELD}{\irOp{getfield}}
\newcommand{\PUTFIELD}{\irOp{putfield}}
\newcommand{\GETSTATIC}{\irOp{getstatic}}
\newcommand{\PUTSTATIC}{\irOp{putstatic}}
\newcommand{\ESCAPE}{\irOp{escape}}
\newcommand{\SHARED}{\irOp{shared}}
\newcommand{\RELOAD}{\irOp{reload}}
\newcommand{\PHI}{\irOp{phi}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% TEXT FORMAT
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\geometry{top=2cm,bottom=2cm,bindingoffset=0cm}
\ifdraft{
  \geometry{left=1cm,right=4cm}
}{
  \geometry{left=3cm,right=2cm}
}
\linespread{1.3}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% BODY
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{
  Применение анализа указателей и синонимов
  для оптимизации многопоточных программ
}
\author{
  Владимир Парфиненко
}

\begin{document}

  \thispagestyle{empty}
  \begin{center}
    \ifdraft{
      \
      \vspace{3cm}

      {\large \textsc{Черновик}}

      \vspace{2cm}

      Курсовая работа

      \vspace{0.2cm}

      Парфиненко Владимир Владимирович

      \vspace{1.5cm}

      \textbf{
        ПРИМЕНЕНИЕ АНАЛИЗА УКАЗАТЕЛЕЙ И СИНОНИМОВ\\
        ДЛЯ ОПТИМИЗАЦИИ МНОГОПОТОЧНЫХ ПРОГРАММ
      }

      \vspace{3.5cm}

      Git-информация

      \vspace{0.5cm}

      \begin{tabular}{rp{8cm}}
        sha1: & \texttt{\GitAbbrHash} \\
        title:& \GitSubject \\
        date: & \GitDate
      \end{tabular}
    }{
      Министерство образования и науки\\
      Российской Федерации

      \vspace{0.7cm}

      Государственное образовательное учреждение\\
      высшего профессионального образования\\
      <<Новосибирский национальный исследовательский\\
      государственный университет>> (НГУ)

      \vspace{0.7cm}

      Механико\hyp{}математический факультет

      \vspace{0.2cm}

      Кафедра программирования

      \vspace{1.2cm}

      Курсовая работа

      \vspace{0.2cm}

      ПАРФИНЕНКО Владимир Владимирович

      \vspace{1.5cm}

      \textbf{
        ПРИМЕНЕНИЕ АНАЛИЗА УКАЗАТЕЛЕЙ И СИНОНИМОВ\\
        ДЛЯ ОПТИМИЗАЦИИ МНОГОПОТОЧНЫХ ПРОГРАММ
      }

      \vspace{2.5cm}

      \begin{flushright}

        Научные руководители

        м.\,н.\,с.~ИСИ~СО~РАН, Павлов\,П.\,Е.\\
        зав.\,лаб.~ИСИ~СО~РАН, к.\,т.\,н.~Шелехов\,В.\,И.

      \end{flushright}

      \vspace {4cm}

      Новосибирск 2012
    }
  \end{center}

  \listoftodos

  \tableofcontents

  \section{Анализ указателей и синонимов}

    Анализ указателей~--- это один из видов статического анализа, который
    позволяет определить, на какие объекты в памяти могут указывать выражения
    ссылочного типа в программе (такие объекты называются целями выражения
    ссылочного типа). Анализ синонимов похож на анализ указателей: его целью
    является определение, могут ли два разных выражения ссылаться на одно и
    то же место в памяти (такие выражения называют синонимами)~\cite{andersen}.

    \subsection{Классификация алгоритмов анализа указателей}
    \label{section:analysis_classification}

      Разные алгоритмы анализа указателей отличаются по точности, по скорости
      работы, по количеству памяти, необходимой для проведения анализа.
      Далее будут рассмотрены основные параметры алгоритмов, влияющие на эти
      характеристики.

      Для сравнения точности алгоритмов анализа указателей необходимо ввести
      некую меру точности. В качестве простой меры точности алгоритма часто
      используется усредненное количество синонимов для всех переменных
      ссылочного типа, появляющихся в
      программе~\cite[раздел~3.2]{hind_pointer_analysis_not_solved_yet}
      (также существуют и более изощренные
      меры~\cite{hind_pointer_analysis_not_solved_yet,diwan_tbaa}).

      Понятно, что для «идеального» алгоритма анализа это число будет
      минимальным, а для самого консервативного алгоритма максимальным.

      \subsubsection{Чувствительные к потоку данных алгоритмы}
        \label{section:analysis_classification_data_flow}

        Примером алгоритма, не учитывающего потоки данных в программе, может
        служить алгоритм анализа синонимов, основанный на типах, применимый
        для языков со строгой типизацией (подробнее про строгую систему типов в
        разделе~\ref{section:type_system})
        Простейшая реализация такого алгоритма дает следующий результат:
        независимо от контекста и потоков данных в программе, два выражения
        могут быть синонимами, если они имеют совместимые формальные
        типы~\cite[раздел~2.2]{diwan_tbaa}.
        Такой алгоритм работает за константное время, но обладает очень низкой
        точностью.

        Большей точностью обладают алгоритмы анализа, которые учитывают потоки
        данных в программе.
        Например, если существует только одно присваивание переменной $v$ вида
        $v = \NEW T()$, то можно гарантировать, что переменная $v$ может
        указывать только на объект, созданный этим оператором \eng{new}.
        С присваиванием вида $v_1 = v_2$ ситуация сложнее. Рассмотрим
        пример~\ref{code:data_flow}.

        \label{code:data_flow}
        \todo{
          Сравнение алгоритмов \eng{subset-based} и \eng{equality-based} типов
        }
        %\begin{algorithm}
        %  \caption{Сравнение алгоритмов \eng{subset-based} и
        %                                \eng{equality-based} типов}
        %  \label{code:data_flow}
        %  \begin{algorithmic}[1]
        %    \STATE $b$ = \NEW T()
        %    \STATE $c$ = \NEW T()
        %    \STATE $a$ = $b$
        %    \STATE $a$ = $c$
        %  \end{algorithmic}
        %\end{algorithm}

        Цели указателя, то есть множество объектов, на которые может указывать
        переменная $p$ (или любое другое выражение ссылочного типа), для
        удобства обозначим как $Pts(p)$ \engdef{points-to set}.
        Учитывая строки 1 и 2, для переменных $b$ и $c$ мы можем точно
        определить множество объектов, на которые они указывают:
        \[Pts(b) = \{O_1\}, Pts(c) = \{O_2\},\]
        где $O_1$ и $O_2$~--- уникальные объекты в куче, соответствующие
        операторам \eng{new} в строках 1 и 2.  То есть мы учли поток данных от
        оператора \eng{new}, создавшего новый объект, в переменную.

        Интерпретировать присваивание $a = b$ можно двумя способами,
        и алгоритмы анализа разбиваются на два типа по этому признаку:
        \begin{itemize}
          \item алгоритмы первого типа накладывают ограничение
                $Pts(a) \supset Pts(b)$
                (\eng{subset-based} алгоритмы)~\cite{andersen}
          \item алгоритмы второго типа накладывают ограничение
                $Pts(a) = Pts(b)$
                (\eng{equality-based} алгоритмы)~\cite{steensgaard}
        \end{itemize}
        В нашем примере \eng{subset-based} алгоритм получит, что
        \[Pts(a) = \{O_1, O_2\}, Pts(b) = \{O_1\}, Pts(c) = \{O_2\},\]
        а \eng{equality-based}
        \[Pts(a) = Pts(b) = Pts(c) = \{O_1, O_2\}.\]
        Первый тип алгоритмов более точен, хотя его время работы в худшем
        случае кубически зависит от размера анализируемой программы.
        Второй тип алгоритмов работает за практически линейное время\footnote{
          Временная сложность \eng{equality-based} алгоритма
          $O(N \alpha(N))$~\cite{steensgaard}, где $\alpha(N)$~--- обратная
          функция Аккермана. Она является очень медленно растущей, и при
          анализе асимптотики алгоритмов можно принять ее за константу.
        },
        предоставляя менее точные результаты.
        Каждый из этих алгоритмов имеет свою область применения, например,
        \eng{subset-based} алгоритм имеет смысл использовать при анализе
        отдельного метода программы, в то время как \eng{equality-based} лучше
        подходит для анализа всей программы целиком.


      \subsubsection{Чувствительные к потоку управления алгоритмы}
        \label{section:analysis_classification_control_flow}

        Также для повышения точности алгоритм анализа указателей может
        учитывать поток управления в программе.
        Рассмотрим пример~\ref{code:control_flow}.

        \label{code:control_flow}
        \todo{Сравнение чувствительного и нечувствительного к потоку
          управления алгоритмов}
        %\begin{algorithm}
        %  \caption{Сравнение чувствительного и нечувствительного к потоку
        %           управления алгоритмов}
        %  \label{code:control_flow}
        %  \begin{algorithmic}[1]
        %    \STATE $a$ = \NEW T()
        %    \STATE $b$ = \NEW T()
        %    \STATE $c$ = \NEW T()
        %    \STATE $a$ = $b$
        %    \STATE $b$ = $c$
        %    \STATE $c$ = $a$
        %  \end{algorithmic}
        %\end{algorithm}

        Нечувствительный к потоку управления алгоритм анализа воспринимает
        программу как неупорядоченный набор операций.
        Для указанного примера такой алгоритм получит следующее
        \[Pts(a) = Pts(b) = Pts(c) = \{O_a, O_b, O_c\}.\]
        Этот результат не является особо точным, но зато он верен
        для любой точки программы.

        Чувствительный к потоку управления алгоритм получит следующие данные
        после 3-ей строки
        \[\textrm{строка 3}:
            Pts(a) = \{O_a\}, Pts(b) = \{O_b\}, Pts(c) = \{O_c\}.\]
        Далее, при анализе 4-ой строки, присваивание будет интерпретировано
        как строгое присваивание (подробнее в
        разделе~\ref{section:flow_sensetive_analysis}), и алгоритм получит
        результат, что $Pts(a) = \{O_b\}$. То есть присваивание нового значения
        в переменную уничтожило информацию о том, что $a$ может указывать на
        $O_a$. Продолжая подобные рассуждения до последней строки, получаются
        следующие результаты:
        \[\textrm{строка 6}:
            Pts(a) = \{O_b\}, Pts(b) = \{O_c\}, Pts(c) = \{O_b\}.\]
        Хотя такой алгоритм дает более точный результат, приходится хранить
        информацию о целях каждого указателя для каждой точки программы
        отдельно, что значительно увеличивает суммарный объем памяти,
        занимаемый результатами анализа.

      \subsubsection{Межпроцедурные алгоритмы}

        Алгоритм анализа может учитывать потоки данных не только внутри
        единственной анализируемой функции, но и между отдельными функциями,
        которые могут быть вызваны из анализируемой.
        Рассмотрим пример~\ref{code:interprocedural}.

        \label{code:interprocedural}
        \todo{Демонстрация работы межпроцедурного алгоритма}
        %\begin{algorithm}
        %  \caption{Демонстрация работы межпроцедурного алгоритма}
        %  \label{code:interprocedural}
        %  \begin{algorithmic}[1]
        %    \STATE \FUNCTION foo($x$, $y$) \{
        %    \RETURN $x$
        %    \STATE \}
        %    \STATE
        %    \STATE $b$ = \NEW T()
        %    \STATE $c$ = \NEW T()
        %    \STATE $a$ = foo($b$, $c$)
        %  \end{algorithmic}
        %\end{algorithm}

        Наша задача понять, чему равно $Pts(a)$.
        Алгоритмы анализа можно разделить на две категории, в зависимости от
        того, как они обрабатывают вызовы функций:
        \begin{itemize}
          \item межпроцедурные алгоритмы анализа могут сначала проанализировать
                тело вызываемой функции, и затем учесть результат при обработке
                вызова,
          \item внутрипроцедурные алгоритмы рассматривают вызов функции в
                наиболее консервативном предположении: может быть возвращен
                либо один из параметров, либо один из глобальных объектов.
        \end{itemize}
        Понятно, что первый тип алгоритмов дает более точные результаты,
        а второй потребляет меньше памяти и работает
        быстрее~\cite[с.~117]{andersen}.
        В нашем примере межпроцедурный алгоритм анализа, проанализировав
        функцию \eng{foo}, запоминает, что для нее выполнено следующее условие
        на возвращаемое значение
        \[Pts(retval) = Pts(x),\]
        и тогда может сделать вывод, что \[Pts(a) = Pts(b) = \{O_1\}.\]
        В такой же ситуации внутрипроцедурный алгоритм анализа обязан сделать
        консервативное предположение
        \[Pts(a) = Pts(b) \cup Pts(c) = \{O_1, O_2\}.\]

  \section{Внутренее представление}

    Вспомогательное внутреннее представление содержит информацию только о
    переменных ссылочного типа и информацию о состоянии памяти в виде
    \Mhyp переменной.

    Ключевыми понятиями анализа являются абстрактные объекты и их множества.
    Абстрактные объекты будем обозначать буквой $O$; множество целей, на
    которые может указывать переменная $x$, будем обозначать $\pts{x}$.

    $AbstractObjects$~--- это множество всех абстрактных объектов. Оно
    состоит из уникальных объектов, соответствующих операциям создания объекта,
    и одного специального объекта $O_{global}$, который олицетворяет все
    объекты, созданные вне анализируемого метода.

    Опишем структуру \Mhyp{}переменной. Во\hyp{}первых, она содержит информацию о
    множестве целей полей объектов:
    \[ \M.\Mfield{fields}\colon
      AbstractObjects \times InstanceFieldDescs \to
      \powerset{AbstractObjects},
    \]
    где $InstanceFieldDescs$~--- это множество идентификаторов полей объектов.
    Аналогично хранится информация о множестве целей статических полей:
    \[ \M.\Mfield{statics}\colon
      StaticFieldDescs \to \powerset{AbstractObjects},
    \]
    где $StaticFieldDescs$~--- это множество идентификаторов
    статических полей.

    Заметим, что, во-первых, эти отображения можно рассматривать как множества.
    А во-вторых, эти отображения будут иметь умолчательное значение: если у нас
    не определено отображение для некоторого значения, то образ этого значения
    есть пустое множество.\todo{Мысль понятна, как переформулировать?}

    Во-вторых, \Mhyp переменная должна содержать информацию о разделяемых
    объектах и об объектах, которые утекут \engdef{escape} из метода и станут
    разделяемыми. Для представления этой информации хранится два множества
    объектов: объекты (\eng{shared}), которые утекли из метода и уже являются
    разделяемыми (консервативно предполагается, что эти объекты могут быть
    прочитаны из любой разделяемой памяти), и объекты (\eng{escaped}), которые
    утекли, но еще не являются разделяемыми.
    \[ \M.\Mfield{shared} \in \powerset{AbstractObjects}; \]
    \[ \M.\Mfield{escaped} \in \powerset{AbstractObjects}. \]

    Исходное значение \Mhyp переменной порождается с помощью операции
    $\INITIALMEMORY$ и содержит пустые множества \Mfield{fields} и
    \Mfield{statics}, множество \Mfield{escaped} изначально также является
    пустым. Однако множество \Mfield{shared} содержит специальный объект
    $O_{global}$.
    \[\M \assig \INITIALMEMORY \Rightarrow \]
    \[\begin{split}
      \M = \{ &\Mfield{fields} = \emptyset, \Mfield{statics} = \emptyset, \\
      &\Mfield{escaped} = \emptyset,
      \Mfield{shared} = \{O_{global}\}
    \}.
    \end{split}\]

    Утекание объектов моделируется операцией, которая добавляет данные объекты
    в множество \Mfield{escaped}, причем при добавлении в множество
    \Mfield{escaped} какого-либо объекта, добавляются в множество еще и все
    объекты, доступные через поля этого объекта.
    \[ \M' \assig \ESCAPE(\M, a_1, \ldots, a_N) \Rightarrow \]
    \[\begin{split}
      \M' = \M, \text{кроме } \M'.\Mfield{escaped} =
        \M.\Mfield{escaped} \cup
        \mathcal{TC}_\M(\pts{a_1} \cup \ldots \cup \pts{a_N}),
    \end{split}\]
    где $\mathcal{TC}_\M(set)$~--- это транзитивное замыкание множества
    объектов и множеств целей их полей \engdef{transitive closure}.
    $\mathcal{TC}_\M(set)$ может быть вычислено следующим образом:
    \[\left\{\begin{aligned}
      &\mathcal{TC}_\M^0(set) = set; \\
      &\mathcal{TC}_\M^{i+1}(set) = \mathcal{TC}_\M^i(set) \cup
        \smashoperator{\bigcup_{\substack{O \in \mathcal{TC}_\M^i(set)\\
                           f \in InstanceFieldDescs}}}
          \M.\Mfield{fields}(O, f); \\
      &\mathcal{TC}_\M(set) =
        \bigcup_{i \in \mathbb{N}} \mathcal{TC}_\M^i(set).
    \end{aligned}\right.\]

    В соответствии с моделью памяти \java есть операции, которые приводят к
    перечитыванию памяти \todocite. При этом все утекшие объекты становятся
    разделяемыми.
    \[ \M' \assig \RELOAD(\M) \Rightarrow \]
    \[\begin{split}
      \M' = \M, \text{кроме }
        &\M'.\Mfield{shared} = \M.\Mfield{shared} \cup \M.\Mfield{escaped}, \\
        &\M'.\Mfield{escaped} = \emptyset.
    \end{split}\]

    Специальное значение null соответствует пустому множеству целей переменной
    ссылочного типа:
    \[ x \assig \NULL \Rightarrow
       \pts{x} = \emptyset. \]

    Создание нового объекта порождает уникальный абстрактный объект:
    \[ x \assig \NEW(\type{T}) \Rightarrow
       \pts{x} = \{O_i\}. \]

    Чтение разделяемого объекта использует множество разделяемых объектов из
    \Mhyp переменной:
    \[ x \assig \SHARED(\M) \Rightarrow
       \pts{x} = \M.\Mfield{shared}. \]

    Чтение статического поля возвращает множество всех разделяемых объектов в
    объединении с объектами, записанными непосредственно в это поле:
    \[ x \assig \GETSTATIC(\M, \sfield{T}{f}) \Rightarrow \]
    \[
      \pts{x} = \M.\Mfield{shared} \cup \M.\Mfield{statics}(\sfield{T}{f}).
    \]

    Запись в статическое поле $\sfield{T}{f}$ имеет более сложную семантику.
    По-мимо изменения значения $\Mfield{statics}(\sfield{T}{f})$, записываемые
    объекты утекают, то есть добавляются в множество
    $\Mfield{escaped}$:
    \[ \M' \assig \PUTSTATIC(\M, \sfield{T}{f}, x) \Rightarrow \]
    \[\begin{split}
      \M' = \M, \text{кроме }
        &\M'.\Mfield{statics}(\sfield{T}{f}) = \pts{x}, \\
        &\M'.\Mfield{escaped} = \M.\Mfield{escaped} \cup
        \mathcal{TC}_\M(\pts{x}).
    \end{split}\]
    Заметим, что в этом случае мы выполняем, так называемый, \eng{strong
    update}, то есть мы не расширяем множество
    $\Mfield{statics}(\sfield{T}{f})$, а именно заменяем его новым множеством
    целей.

    Чтение поля из переменной $a$ возвращает множество объектов, записанных
    непосредственно в это поле. Однако, если переменная $a$ может указывать хоть
    на один раздеяляемый объект, то возвращаемое множество расширяется всеми
    разделяемыми объектами:
    \[ x \assig \GETFIELD(\M, a, \field{f}) \Rightarrow \]
    \[
      \pts{x} = \left( \bigcup_{O \in \pts{a}} \M.\Mfield{fields}(O,
      \field{f}) \right) \cup
      \begin{cases}
        \M.\Mfield{shared}, & \text{если } \pts{a} \cap \M.\Mfield{shared} \ne \emptyset;\\
        \emptyset, & \text{иначе}.
      \end{cases}
    \]

    Запись в поле $\field{f}$ переменной $a$ модифицирует значение памяти,
    расширяя множество целей $\Mfield{fields}(O, \field{f})$ для всех $O \in
    \pts{a}$, и если переменная $a$ может указывать хоть на один разделяемый
    объект, то записываемые объекты утекают. В этом случае мы не имеем права
    безусловно замещать множество целей $\Mfield{fields}(O, \field{f})$ для
    всех $O$, так как при исполнении программы реальная запись поля случится
    только для одного из объектов, но не для всех. Однако, последнее
    высказывание может подтолкнуть на мысль о том, что если множество целей
    $\pts{a} = \{O_i\}$, то есть содержит только один абстрактный объект,
    отличный от $O_{global}$, то мы можем установить множество
    $\Mfield{fields}(O_i, \field{f})$ равным $\pts{x}$.
    \[ \M' \assig \PUTFIELD(\M, a, \field{f}, x) \Rightarrow \]
    \[\begin{split}
      \M' = \M,\ &\text{кроме} \\
        &\begin{split}
          \text{для всех } &O \in \pts{a}\colon
            \M'.\Mfield{fields}(O, \field{f}) =
            \pts{x}\ \cup \\
            &\cup
            \begin{cases}
              \M.\Mfield{fields}(O, \field{f}), & \text{если }
                |\pts{a}| > 1 \vee \pts{a} = \{O_{global}\};\\
              \emptyset, & \text{иначе},
            \end{cases}
        \end{split} \\
        &\begin{split}
          \M'.&\Mfield{escaped} = \M.\Mfield{escaped}\ \cup \\
          &\cup
            \begin{cases}
              \mathcal{TC}_\M(\pts{x}), & \text{если }
                \pts{a} \cap (\M.\Mfield{shared} \cup \M.\Mfield{escaped}) \ne \emptyset;\\
              \emptyset, & \text{иначе}.
            \end{cases}
        \end{split}
    \end{split}\]

    В результате перевода программы в SSA-форму могут появиться \phihyp функции
    от переменных ссылочного типа и от \Mhyp переменных. Оба вида функций
    обладают довольно простой семантикой:
    \[ x \assig \PHI(a_1, \ldots, a_N) \Rightarrow
       \pts{x} = \bigcup_{i = 1}^N \pts{a_i}; \]
    \[ \M' \assig \PHI(\M_1, \ldots, \M_N) \Rightarrow \]
    \[\begin{split}
      \M' = \{
      &\Mfield{fields}(O, f) = \bigcup_{i = 1}^N \M_i.\Mfield{fields}(O, f), \\
      &\Mfield{statics}(f) = \bigcup_{i = 1}^N \M_i.\Mfield{statics}(f), \\
      &\Mfield{escaped} = \bigcup_{i = 1}^N \M_i.\Mfield{escaped}, \\
      &\Mfield{shared} = \bigcup_{i = 1}^N \M_i.\Mfield{shared}
      \}.
    \end{split}\]


  \section{Операции языка Java}

    При анализе указателей достаточно рассматривать далеко не все операции.
    Благодаря этому мы можем построить вспомогательное внутреннее представление
    только с необходимой и достаточной информацией о потоках данных и
    зависимостями по памяти.

    Приведем список всех рассматриваемых в рамках анализа указателей операций и
    их интерпретацию в вспомогательном внутреннем представлении.

    Не зависят от памяти две операции. Создание нового объекта типа $\type{T}$:
    \[ x \assig \NEW(\type{T}), \]
    и присваивание специального значения null:
    \[ x \assig \NULL. \]

    Изначальное состояние памяти (\Mhyp переменная) получается специальным
    образом:
    \[ \M_0 \assig \INITIALMEMORY. \]
    Формальный параметр $p$ консервативно берется из разделяемой памяти
    \[ p \assig \SHARED(\M_0). \]

    Чтение обычного поля $\field{f}$ из переменной $a$ использует
    \Mhyp переменную:
    \[ x \assig \GETFIELD(\M_i, a, \field{f}), \]
    аналогично имеем чтение статического поля $\sfield{T}{f}$:
    \[ x \assig \GETSTATIC(\M_i, \sfield{T}{f}). \]
    Запись переменной $x$ в обычное поле $\field{f}$ переменной $a$ порождает
    \Mhyp переменную:
    \[ \M_j \assig \PUTFIELD(\M_i, a, \field{f}, x), \]
    аналогично порождает \Mhyp переменную запись в статическое поле
    $\sfield{T}{f}$:
    \[ \M_j \assig \PUTSTATIC(\M_i, \sfield{T}{f}, x). \]

    Чтение и запись $i$-го элемента массива консервативно преобразуется в
    работу с синтетическим полем $\field{elements}$, которое добавляется всем
    типам\hyp{}массивам.

    Вызов функции с параметрами $p_0, \ldots, p_n$ и возвращаемым значением,
    которое записывается в переменную $x$, консервативно представляется
    следующим образом:
    \[\begin{aligned}
      \M_j &\assig \ESCAPE(\M_i, p_0, \ldots, p_n); \\
      \M_k &\assig \RELOAD(\M_j); \\
      x  &\assig \SHARED(\M_k).
    \end{aligned}\]
    Заметим, что в случае отсутствия возращаемого значения, последнюю строку
    необходимо убрать.

    В соответствии с моделью памяти языка \java, необходимо перечитывать
    значения полей объектов перед чтением \eng{volatile} полей и при входе в
    блок синхронизации:
    \[ \M_j \assig \RELOAD(\M_i). \]

    \todo{Привести пример как простенькая программа выглядит в такой
    терминологии}

  \newpage
  \bibliography{../../biblio}

\end{document}

