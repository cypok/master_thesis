\documentclass[14pt,titlepage]{extarticle}
\usepackage[pdftex,unicode,hidelinks]{hyperref}
\usepackage{ucs}
\usepackage[utf8x]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{indentfirst}
\usepackage[usenames,dvipsnames]{color}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{multicol}
\usepackage{rotating}
\usepackage{array}
\usepackage{multirow}
\usepackage{xspace}
\usepackage{subfig}
\usepackage{amsthm}

% gnuplot & lua should be installed,
% this *.sty file is generated by `lua %GNUPLOT%/lua/gnuplot-tikz.lua style`
\usepackage{gnuplot-lua-tikz}

\usepackage[left=3cm,right=2cm,top=2cm,bottom=2cm,bindingoffset=0cm]{geometry}
\linespread{1.3}

\usepackage{numprint}
\newcommand{\num}[1]{\numprint{#1}}
  \npthousandsep{\,}
  \npthousandthpartsep{}
  \npdecimalsign{,}

\usepackage{tikz}
\usetikzlibrary{positioning,arrows,shapes}

\usepackage{footmisc}
\renewcommand{\footnotelayout}{\small}

\usepackage{etoolbox}
\apptocmd{\sloppy}{\hbadness 10000\relax}{}{}

% used by bibliography:
\usepackage{datetime}
\newcommand{\usedate}[3]{({\Russian дата обращения: \formatdate{#1}{#2}{#3}})}
\bibliographystyle{gost71u2003} % can be found in the root of repo

% widebar
% from mathabx.sty and mathabx.dcl
\DeclareFontFamily{U}{mathx}{\hyphenchar\font45}
\DeclareFontShape{U}{mathx}{m}{n}{
      <5> <6> <7> <8> <9> <10>
      <10.95> <12> <14.4> <17.28> <20.74> <24.88>
      mathx10
      }{}
\DeclareSymbolFont{mathx}{U}{mathx}{m}{n}
\DeclareFontSubstitution{U}{mathx}{m}{n}
\DeclareMathAccent{\widebar}{0}{mathx}{"73}

%\setcounter{tocdepth}{2} % глубина оглавления

\newcommand{\M}{\ensuremath{\mathbb{M}}}
\newcommand{\Mfield}[1]{\textrm{#1}}

\newcommand{\NEW}{\textbf{new}}
\newcommand{\NULL}{\textbf{null}}
\newcommand{\INITIALMEMORY}{\textbf{initialmemory}}
\newcommand{\GETFIELD}{\textbf{getfield}}
\newcommand{\PUTFIELD}{\textbf{putfield}}
\newcommand{\GETSTATIC}{\textbf{getstatic}}
\newcommand{\PUTSTATIC}{\textbf{putstatic}}
\newcommand{\ESCAPE}{\textbf{escape}}
\newcommand{\SHARED}{\textbf{shared}}
\newcommand{\RELOAD}{\textbf{reload}}
\newcommand{\PHI}{\textbf{phi}}

\newcommand{\pts}[1]{\widebar{#1}}

\newcommand{\Type}[1]{\textrm{Type}(#1)}
\newcommand{\IsAssignable}[2]{\textrm{IsAssignable}(#1, #2)}
\newcommand{\Pts}[1]{\textrm{Pts}(#1)}
\newcommand{\OFPts}[2]{\overline{#1.#2}}
\newcommand{\Shared}{\overline{shared}}
\newcommand{\Filter}[2]{\textrm{Filter}_{#1}(#2)}
\newcommand{\cupe}{\,\cup\!\!=}

\let\oldphi\phi
\renewcommand{\phi}{\ensuremath{\oldphi}}

\renewcommand{\emptyset}{\varnothing}

\renewcommand{\leq}{\leqslant}
\renewcommand{\geq}{\geqslant}
\newcommand{\incomp}{\not\lessgtr}

\newcommand\Set[2]{\left\{ #1 \mid #2 \right\}}

%\newcommand{\remark}[1]{}
%\newcommand{\todo}[1]{}
%\newcommand{\todocite}{}
\newcommand{\remark}[1]{\textcolor{Green}{(#1)}}
\newcommand{\todo}[1]{\textcolor{red}{(\eng{TODO}: #1)}}
\newcommand{\todocite}{[\textcolor{red}{\eng{cite}}]}

\newcommand{\eng}[1]{{\English#1}}
\newcommand{\engdef}[1]{(англ.~\eng{#1})}

\addto\captionsrussian{
  \let\oldrefname\refname
  \renewcommand\refname{\addcontentsline{toc}{section}{\oldrefname}\oldrefname}
}

% русские нумераторы
\renewcommand{\theenumii}{(\asbuk{enumii})}
\renewcommand{\labelenumii}{\asbuk{enumii})}
\renewcommand{\thesubfigure}{\asbuk{subfigure}}


% обёртка с моими настройками поверх figure:
% \begin{myfigure}{подпись}{label} ... \end{myfigure}
\newenvironment{myfigure}[2]%
  {\pushQED{\caption{#1} \label{#2}} % push caption & label
   \begin{figure}[!htb]\centering } %
  {  \popQED % pop caption & label
   \end{figure}}
\newenvironment{myplot}[2]%
  {\pushQED{\caption{#1} \label{#2}} % push caption & label
   \begin{figure}[p]\centering\small } %
  {  \popQED % pop caption & label
   \end{figure}}

%\newcommand{\inputplot}[1]{\input{#1}}
\newcommand{\inputplot}[1]{Here would be plot}

\let\oldsection\section
\renewcommand{\section}{\newpage\oldsection}

\newcommand{\sectionwithoutnumber}[1]{
  \section*{#1}
  \addcontentsline{toc}{section}{#1}
}

\newcommand{\java}{\eng{Java}\xspace}

\title{
  Применение анализа указателей и синонимов
  для оптимизации многопоточных программ
}
\author{
  Владимир Парфиненко
}

\begin{document}

  \thispagestyle{empty}
  \begin{center}

    Министерство образования и науки\\
    Российской Федерации

    \vspace{0.7cm}

    Государственное образовательное учреждение\\
    высшего профессионального образования\\
    <<Новосибирский национальный исследовательский\\
    государственный университет>> (НГУ)

    \vspace{0.7cm}

    Механико-математический факультет

    \vspace{0.2cm}

    Кафедра программирования

    \vspace{1.2cm}

    Курсовая работа

    \vspace{0.2cm}

    ПАРФИНЕНКО Владимир Владимирович

    \vspace{1.5cm}

    \textbf{
      ПРИМЕНЕНИЕ АНАЛИЗА УКАЗАТЕЛЕЙ И СИНОНИМОВ\\
      ДЛЯ ОПТИМИЗАЦИИ МНОГОПОТОЧНЫХ ПРОГРАММ
    }

    \vspace{2.5cm}

    \begin{flushright}

      Научные руководители

      м.\,н.\,с.~ИСИ~СО~РАН, Павлов\,П.\,Е.\\
      зав.\,лаб.~ИСИ~СО~РАН, к.\,т.\,н.~Шелехов\,В.\,И.

    \end{flushright}

    \vspace {4cm}

    Новосибирск 2012 \remark{версия от \today}
  \end{center}

  \tableofcontents

  \sectionwithoutnumber{Внутренее представление}

    Вспомогательное внутреннее представление содержит информацию только о
    переменных ссылочного типа и информацию о состоянии памяти в виде
    \M-переменной.

    Ключевыми понятиями анализа являются абстрактные объекты и их множества.
    Абстрактные объекты будем обозначать буквой $O$; множество целей, на
    которые может указывать переменная $x$, будем обозначать $\pts{x}$.

    Опишем структуру \M-переменной. Во-первых, она содержит информацию о
    множестве целей полей объектов:
    \[ \M.\Mfield{fields}\colon
      (\textrm{AbstractObject},\ \textrm{InstanceFieldDesc}) \to
      \textrm{Set}[\textrm{AbstractObject}].
    \]
    Аналогично хранится информация о множестве целей статических полей:
    \[ \M.\Mfield{statics}\colon
      \textrm{StaticFieldDesc} \to
      \textrm{Set}[\textrm{AbstractObject}].
    \]
    Заметим, что эти отображания можно рассматривать как множества.

    Во-вторых, \M-переменная должна содержать информацию о разделяемых объектах
    и об объектах, которые утекут \engdef{escape} из метода и станут
    разделяемыми. Для представления этой информации хранится два множества
    объектов: объекты (\eng{shared}), которые утекли из метода и уже являются
    разделяемыми (т.\,е. могут быть прочитаны из статических полей, возвращены
    из вызванного метода и т.\,д.), и объекты (\eng{escaped}), которые утекли,
    но которые еще не являеются разделяемыми (т.\,е. не могут быть прочитаны из
    статических полей и т.\,д.).
    \[\begin{aligned}
      &\M.\Mfield{shared}\colon \textrm{Set}[\textrm{AbstractObject}]; \\
      &\M.\Mfield{escaped}\colon \textrm{Set}[\textrm{AbstractObject}].
    \end{aligned}\]

    Исходное значение \M-переменной порождается операцией $\INITIALMEMORY$ и
    содержит пустые множества \Mfield{fields} и \Mfield{statics}, множество
    \Mfield{escaped} изначально также является пустым. Однако множество
    \Mfield{shared} содержит один специальный объект $O_{global}$, который
    олицетворяет все объекты, созданные вне анализируемого метода.
    \[\M \leftarrow \INITIALMEMORY \Rightarrow \]
    \[\begin{split}
      \M = \{ &\Mfield{fields} = \emptyset, \Mfield{statics} = \emptyset, \\
      &\Mfield{escaped} = \emptyset,
      \Mfield{shared} = \{O_{global}\}
    \}.
    \end{split}\]

    В соответствии с моделью памяти \java есть операции, которые приводят к
    перечитыванию памяти. При этом все утекшие объекты становятся разделяемыми.
    И более того, все объекты, которые доступны через поля разделяемых
    объектов, также становятся разделяемыми.
    \[ \M' \leftarrow \RELOAD(\M) \Rightarrow \]
    \[\left\{\begin{aligned}
      &S_0 = \M.\Mfield{escaped} \cup \M.\Mfield{shared}; \\
      &S_{i+1} = S_i \cup
       \Set{O}{\exists f \in \textrm{InstanceFieldDesc}, O_s \in S_i \colon
       O \in \M.\Mfield{fields}(O_s, f)};
    \end{aligned}\right.\]
    \[ S = \text{неподвижная точка последовательности } \{S_i\}; \]
    \[\begin{split}
      \M' = \M, \text{кроме } &\M'.\Mfield{escaped} = \emptyset, \\
         &\M'.\Mfield{shared} = S.
    \end{split}\]
    \todo{Транзитивное замыкание должно делаться при добавлении объектов в
    escaped, ввести TC(set).}

    Утекание объектов моделируется операцией, которая просто добавляет объекты
    в множество \Mfield{escaped}:
    \[ \M' \leftarrow \ESCAPE(\M, a_1, \ldots, a_N) \Rightarrow \]
    \[\begin{split}
      \M' = \M, \text{кроме } \M'.\Mfield{escaped} =
        \M.\Mfield{escaped} \cup \pts{a_1} \cup \ldots \cup \pts{a_N}.
    \end{split}\]

    Специальное значение null соответствует пустому множеству целей переменной
    ссылочного типа:
    \[ x \leftarrow \NULL \Rightarrow
       \pts{x} = \emptyset. \]

    Создание нового объекта порождает уникальный абстрактный объект:
    \[ x \leftarrow \NEW(\textrm{T}) \Rightarrow
       \pts{x} = \{O_i\}. \]

    Чтение разделяемого объекта использует множество разделяемых объектов из
    \M-переменной:
    \[ x \leftarrow \SHARED(\M) \Rightarrow
       \pts{x} = \M.\Mfield{shared}. \]

    Чтение статического поля возвращает множеством всех разделяемых объектов в
    объединении с объектами, записанными непосредственно в это поле:
    \[ x \leftarrow \GETSTATIC(\M, \textrm{T.f}) \Rightarrow \]
    \[
      \pts{x} = \M.\Mfield{shared} \cup \M.\Mfield{statics}(\textrm{T.f}).
    \]

    Запись в статическое поле \textrm{T.f} имеет более сложную семантику.
    По-мимо изменения значения $\Mfield{statics}(\textrm{T.f})$, записываемые
    объекты утекают, т.\,е. добавляются в множество $\Mfield{escaped}$:
    \[ \M' \leftarrow \PUTSTATIC(\M, \textrm{T.f}, x) \Rightarrow \]
    \[\begin{split}
      \M' = \M, \text{кроме }
        &\M'.\Mfield{statics}(\textrm{T.f}) = \pts{x}, \\
        &\M'.\Mfield{escaped} = \M.\Mfield{escaped} \cup \pts{x}.
    \end{split}\]

    Чтение поля из переменной $a$ возвращает множеством объектов, записанных
    непосредственно в это поле. Однако, если переменная $a$ может указывать хоть
    на один раздеяляемый объект, то возвращаемое множество расширяется всеми
    разделяемыми объектами:
    \[ x \leftarrow \GETFIELD(\M, a, \textrm{f}) \Rightarrow \]
    \[
      \pts{x} = \left( \bigcup_{O \in \pts{a}} \M.\Mfield{fields}(O,
      \textrm{f}) \right) \cup
      \begin{cases}
        \M.\Mfield{shared}, & \text{если } \pts{a} \cap \M.\Mfield{shared} \ne \emptyset;\\
        \emptyset, & \text{иначе}.
      \end{cases}
    \]

    \todo{strong update?}
    Запись в поле $\textrm{f}$ переменной $a$ модифицирует значение памяти,
    расширяя множество целей $\Mfield{fields}{O, \textrm{f}}$ для всех $O \in
    \pts{a}$, и если переменная $a$ может указывать хоть на один раздеяляемый
    объект, то записываемые объекты также утекают.
    \[ \M' \leftarrow \PUTFIELD(\M, a, \textrm{f}, x) \Rightarrow \]
    \[\begin{split}
      \M' = \M, \text{кроме }
        &\M'.\Mfield{fields}(O, \textrm{f}) =
        \pts{x} \cup \M.\Mfield{fields}(O, \textrm{f})
        \text{ для всех } O \in \pts{a}, \\
        &\M'.\Mfield{escaped} = \M.\Mfield{escaped} \cup
        \begin{cases}
          \pts{x}, & \text{если } \pts{a} \cap \M.\Mfield{shared} \ne \emptyset;\\
          \emptyset, & \text{иначе}.
        \end{cases}
    \end{split}\]

    \todo{в putfield и putstatic в cases: $\cap$ с shared или с shared $\cup$
    escaped $\cup$ their fields}

    В результате перевода программы в SSA-форму могут появиться \phi-функции от
    переменных ссылочного типа и от \M-переменных. Оба вида функций обладают
    довольно простой семантикой:
    \[ x \leftarrow \PHI(a_1, \ldots, a_N) \Rightarrow
       \pts{x} = \bigcup_{i = 1}^N \pts{a_i}; \]
    \[ \M' \leftarrow \PHI(\M_1, \ldots, \M_N) \Rightarrow \]
    \[\begin{split}
      \M' = \{
      &\Mfield{fields}(O, f) = \bigcup_{i = 1}^N \M_i.\Mfield{fields}(O, f), \\
      &\Mfield{statics}(f) = \bigcup_{i = 1}^N \M_i.\Mfield{statics}(f), \\
      &\Mfield{escaped} = \bigcup_{i = 1}^N \M_i.\Mfield{escaped}, \\
      &\Mfield{shared} = \bigcup_{i = 1}^N \M_i.\Mfield{shared}
      \}
    \end{split}\]


  \sectionwithoutnumber{Операции языка Java}

    При анализе указателей достаточно рассматривать далеко не все операции.
    Тогда мы можем построить вспомогательное внутреннее представление только с
    необходимой и достаточной информацией о потоках данных и зависимостями по
    памяти.

    Приведем список всех рассматриваемых в рамках анализа указателей операций и
    их интерпретацию в вспомогательном внутреннем представлении.

    Не зависят от памяти две операции. Создание нового объекта типа
    $\textrm{T}$:
    \[ x \leftarrow \NEW(\textrm{T}), \]
    и присваивание специального значения null:
    \[ x \leftarrow \NULL. \]

    Изначальное состояние памяти (\M-переменная) получается специальным
    образом:
    \[ \M_0 \leftarrow \INITIALMEMORY. \]
    Формальный параметр $p$ консервативно берется из разделяемой памяти
    \[ p \leftarrow \SHARED(\M_0). \]

    Чтение обычного поля $\textrm{f}$ из переменной $a$ использует
    \M-переменную:
    \[ x \leftarrow \GETFIELD(\M_i, a, \textrm{f}), \]
    аналогично имеем чтение статического поля $\textrm{T.f}$:
    \[ x \leftarrow \GETSTATIC(\M_i, \textrm{T.f}). \]
    Запись переменной $x$ в обычное поле $\textrm{f}$ переменной $a$ порождает
    \M-переменную:
    \[ \M_j \leftarrow \PUTFIELD(\M_i, a, \textrm{f}, x), \]
    аналогично порождает \M-переменную запись в статическое поле $\textrm{T.f}$:
    \[ \M_j \leftarrow \PUTSTATIC(\M_i, \textrm{T.f}, x). \]

    Чтение и запись $i$-го элемента массива консервативно преобразуется в
    работу с синтетическим полем $\textrm{elements}$, которое добавляется всем
    типам-массивам.

    Вызов функции с параметрами $p_0, \ldots, p_n$ и возвращаемым значением,
    которое записывается в переменную $x$, консервативно представляется
    следующим образом:
    \[\begin{aligned}
      \M_j &\leftarrow \ESCAPE(\M_i, p_0, \ldots, p_n); \\
      \M_k &\leftarrow \RELOAD(\M_j); \\
      x  &\leftarrow \SHARED(\M_k).
    \end{aligned}\]
    Заметим, что в случае отсутствия возращаемого значения, последнюю строку
    необходимо убрать.

    В соответствии с моделью памяти языка \java, необходимо перечитывать
    значения полей объектов перед чтением \eng{volatile} полей и при входе в
    блок синхронизации:
    \[ \M_j \leftarrow \RELOAD(\M_i). \]




  \newpage
  \bibliography{../../biblio}

\end{document}

