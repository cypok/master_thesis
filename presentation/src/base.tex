\documentclass[12pt]{article}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PACKAGES
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage[pdftex,unicode,hidelinks,final]{hyperref}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{indentfirst}

\usepackage[babel,final,protrusion=true,expansion]{microtype}

\usepackage{geometry}

\usepackage[usenames,dvipsnames]{xcolor}

\usepackage{xspace} % for \xspace

\usepackage{totcount} % for \newtotcounter & \total

\usepackage{amssymb} % for mathbb

\usepackage{../../common/cypokcommon}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% DOCUMENT-SPECIFIC COMMANDS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\input{../../common/gitinfo}

\newcommand{\java}{\eng{Java}\xspace}

\newcommand{\M}{\ensuremath{\mathbb{M}}}

% TODO: rename \slide => \frame, \click => \slide
\newtotcounter{framescount}
\newcounter{slidescount}
\newcommand{\slide}[1]{%
  \stepcounter{framescount}%
  \setcounter{slidescount}{1}
  \textcolor{Blue}{[Слайд \arabic{framescount}/\total{framescount}: #1]}
}
\newcommand{\click}{%
  \stepcounter{slidescount}%
  \textcolor{Blue}{[Слайд \arabic{framescount}.\arabic{slidescount}]}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% TEXT FORMAT
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\geometry{a4paper,top=2cm,bottom=2cm,left=2.5cm,right=2.5cm,bindingoffset=0cm}
\linespread{1.3}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% BODY
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\titleauthor{%
  Презентация работы на тему «Применение анализа указателей и синонимов
  для оптимизации многопоточных программ»%
}{%
  Владимир Парфиненко%
}

\begin{document}
  {\Large Текст презентации для защиты, 10 минут.}

  Git date: \GitDate.
  \medskip\hrule

  \paragraph{Кто я.}
  \slide{титульный с названием и фамилиями моей и научрука}
  Здравствуйте, меня зовут Владимир Парфиненко и тема моей работы
  <<Применение анализа указателей и синонимов для оптимизации многопоточных
  программ>>.

  \paragraph{Что такое анализ синонимов и указателей.}
  \slide{анализ синонимов и... указателей (с английскими названиями)}
  В моей работе рассматривается анализ синонимов, который предоставляет
  информацию о том, могут ли два выражения ссылочного типа быть синонимами, то
  есть ссылаться на один и тот же объект в памяти. Анализ синонимов тесно
  связан с анализом указателей, который предоставляет более общую информацию:
  множество всех объектов, на которые может ссылаться выражение.

  \paragraph{Постановка задачи.}
  \slide{цель и задачи}
  Теперь, зная основную терминологию, можно сформулировать цель данной
  работы: разработка алгоритма анализа указателей и синонимов для языка \java,
  учитывающего особенности языка и его модели памяти. Для этого необходимо
  было изучить существующие алгоритмы анализа, сравнить их точность,
  эффективность и разработать усовершенствованный алгоритм, выбрав за основу
  один из существующих. Особое внимание требовалось уделить способу выражения
  неявных зависимостей по данным между операциями работающими с памятью и
  согласовать этот способ с моделью памяти языка \java. Также необходимо было
  реализовать некоторую оптимизацию, использующую результаты алгоритмы анализа
  и провести замеры ее эффективности.

  \paragraph{Предыдущая работа.}
  В рамках предыдущей работы на соискание степени бакалавра, мною уже был
  разработан алгоритм анализа указателей для языка \java.
  \slide{пример с отсутствием чувствительности к потоку}
  Однако этот алгоритм при анализе многих программ вел себя через
  чур консервативно, не смотря на предпринятые улучшения. Это было связано
  во-первых с отсутствием чувствительности к потоку управления. В данном примере
  легко увидеть, что $a$ и $b$ ссылаются на заведомо разные объекты и не могут
  быть синонимами. \click Однако алгоритм получал результат, что $a$ и $b$
  могут быть синонимами, так как их значения получаются из одного и того же
  поля $f$ переменной $x$.

  \paragraph{Проблемы нечувствительного к потоку алгоритма.}
  Так как проведение чувствительного к потоку управления анализа до сих пор
  является неприемлемым в промышленном компиляторе из-за
  временной\slash{}емкостной сложности, необходимо было придумать другой способ
  решения этой проблемы.
  \slide{сравнение видения программы чувствительным и нечувствительным к потоку
  анализом}
  Довольно быстро стало понятно, что проблема не столько в самом алгоритме
  анализа, сколько в нехватке информации во внутреннем представлении, так как
  нечувствительный к потоку управления анализ работает с программой как с
  неупорядоченным множеством операций, и две операции чтения поля $f$
  переменной $x$ для такого анализа абсолютно идентичны и никак не зависят от
  операций записи в поле.

  \paragraph{\M"=переменная.}
  \slide{пример программы с \M"=переменной}
  Описанную проблему удалось решить с помощью введения в программу
  символической \M"=переменной, олицетворяющей образ всей памяти
  (\eng{M} от английского слова \eng{memory}).
  Таким образом все операции читающие память должны иметь своим аргументом
  \M"=переменную, а операции модифицирующие память должны порождать
  \M"=переменную.
  Заметим, что на ряду с обычными переменными \M"=переменная версионируется при
  переводе в SSA-форму.
  Эта переменная дает необходимые явные зависимости между операциями
  чтения\slash{}записи полей: видно, что два чтения поля в первой и последней строке
  не идентичны, они работают с разными версиями \M"=переменной, и алгоритм
  анализа может получить более точные результаты о синонимичности переменных
  $u$ и $v$.

  \paragraph{Операции языка \java}
  \slide{примитивные операции}
  С помощью небольшого набора примитивных операций, работающих с
  \M"=переменной, можно представить все операции языка \java, работающие с
  переменными ссылочного типа и памятью, при этом сохранив всю информацию,
  необходимую для проведения анализа указателей, и выражения свойств модели
  памяти языка \java.

  \paragraph{Алгоритм анализа: граф операций.}
  Теперь можно описать работу разработанного алгоритма анализа
  указателей.
  \slide{пример графа}
  Он работает с графом зависимостей по данным~--- это ориентированный граф с
  помеченными дугами, вершинами которого являются примитивные операции. А дуга
  помеченная числом $i$ соединяет две операции, если вторая использует
  результат первой в качестве $i$-го аргумента.
  На слайде приведен пример программы и соответствующего графа.

  \paragraph{Алгоритм анализа: абстрактные объекты.}
  \slide{абстрактные объекты}
  Затем строится множество абстрактных объектов, соответствующих различным
  объектам при исполнении программы. Источниками таких объектов являются
  операции $new$. Отдельно выделяется специальный объект $global$,
  соответствующий всем разделяемым объектам, на который могут указывать,
  например, формальные параметры метода или статические поля классов.

  \paragraph{Алгоритм анализа: потоковый анализа}
  Затем проводится анализ потока данных на графе зависимостей по данным.

  \slide{потоковые свойства}
  Каждой операции, порождающей значение ссылочного типа, предписывается
  множество абстрактных объектов, на которые данное выражение может указывать
  во время исполнения. Данные множества образуют полурешетку, верхним элементом
  которой является пустое множество, а нижним элементом~--- множество всех
  абстрактных объектов. Соответственно, операцией сбора полурешетки является
  объединение множеств.

  \click
  Каждой операции, порождающей \M"=переменную, также предписывается некоторое
  более сложное свойство, которое является кортежем декартова произведений
  полурешеток множеств абстрактных объектов. Данное свойство хранит информацию
  о множестве целей полей всех абстрактных объектов и множестве разделяемых
  абстрактных объектов, которые доступны извне анализируемого метода.

  \paragraph{Алгоритм анализа: потоковый анализа}
  \slide{потоковые функции}
  Для каждой примитивной операции была определена ее абстрактная семантика и
  сконструирована потоковая функция. Все потоковые функции являются
  монотонными, что гарантирует сходимость и корректность данного потокового
  анализа. На слайде приведен примеры потоковых функций.

  \slide{результаты алгоритма анализа}
  В результате алгоритм предоставляет информацию о множестве целей каждого
  выражения ссылочного типа, что достаточно для проверки синонимичности.

  \paragraph{Оптимизация удаления чтений полей}
  \slide{пример оптимизации}
  В качестве оптимизации, использующей результаты анализа, была разработана
  оптимизация удаления избыточных чтений полей.
  Суть оптимизации заключается в замене операции чтения на непосредственное
  значение, которое было ранее записано: например, здесь мы могли бы заменить
  последнее чтение на значение 42.
  \click
  Однако, такое преобразование корректно, только если $a$ и $b$ не являются
  синонимами.
  \click
  Также необходимо помнить, что в общем случае любая программа на языка \java
  является многопоточной, и при анализе отдельного методы необходимо учитывать
  возможное влияние других потоков программы, которые могут модифицировать
  разделяемую память: поэтому в консервативном случае данная оптимизация
  невозможна для чтений из разделяемой памяти.

  \paragraph{Проблема многопоточности и модель памяти.}
  \slide{пример однопоточной и многопоточной программы}
  Решить эту проблему помогает модель памяти \java.
  Она задает, когда значения полей объектов могут храниться в локальной памяти,
  что исключает влияние других потоков и позволяет корректно проводить
  оптимизацию.
  И также модель памяти задает, когда значения полей объектов обязаны
  быть перечитаны из разделяемой памяти, что необходимо учитывать для
  соблюдения корректности.
  \click
  На слайде приведены два примера, в одном из которых можно корректно удалить
  операцию чтения, а в другом нет из-за наличия чтения волатильной переменной.

  \paragraph{Реализация.}
  \slide{реализованный анализ и оптимизация}
  Разработанный алгоритм анализа реализован в статическом компиляторе языка
  \java в рамках проекта \eng{Excelsior RVM}.
  Также была реализована оптимизация удаления избыточных чтений, что позволило
  оценить относительную точность алгоритма анализа указателей по результатам
  работы оптимизации.
  \slide{результаты оптимизации}
  Были проведены замеры на различных приложениях того, сколько чтений сможет
  удалить оптимизация в зависимости от используемого алгоритма анализа
  указателей: в одном случае это был консервативный алгоритм, использующий
  только информацию о типах, в другом это был разработанный алгоритм.
  Хотя эти цифры не могут гарантировать высокую абсолютную точность алгоритма,
  но они могут служить показателем того, что результаты анализа достаточно
  точны для эффективного проведения оптимизаций, использующих анализ синонимов.

  \paragraph{Заключение.}
  \slide{что сделано}
  В итоге в ходе работы был проведен анализ существующих алгоритмов анализа
  указателей, разработана схема явного выражения зависимостей по памяти. Эта
  схема позволила точнее отобразить семантику модели памяти языка \java,
  разработать более точный алгоритма анализа и алгоритм оптимизации удаления
  избыточных чтений.
  Которые затем были реализованы в рамках проекта \eng{Excelsior~RVM}.

  Также работа была представлена на 51-ой конференции МНСК и отмечена дипломом
  первой степени.

  \paragraph{Дальнейшая работа.}
  \slide{что планируется сделать}
  В дальнейшем планируется внедрить разработанный алгоритм в промышленный
  статический \java компилятор \eng{Excelsior JET}, и адаптировать алгоритм для
  межпроцедурного анализа.

  \paragraph{Конец.}
  \slide{спасибо за внимание}
  Спасибо за внимание, я готов ответить на ваши вопросы.

\end{document}
