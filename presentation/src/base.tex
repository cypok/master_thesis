\documentclass[12pt]{article}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PACKAGES
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage[pdftex,unicode,hidelinks,final]{hyperref}
\usepackage{ucs}
\usepackage[utf8x]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{indentfirst}

\usepackage{geometry}

\usepackage[usenames,dvipsnames]{xcolor}

\usepackage{xspace} % for \xspace

\usepackage{totcount} % for \newtotcounter & \total

\usepackage{amssymb} % for mathbb

\usepackage{../../common/cypokcommon}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% DOCUMENT-SPECIFIC COMMANDS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\input{../../common/gitinfo}

\newcommand{\java}{\eng{Java}\xspace}

\newcommand{\M}{\ensuremath{\mathbb{M}}}

\newtotcounter{slidescount}
\newcommand{\slide}[1]{%
  \stepcounter{slidescount}%
  \textcolor{Blue}{[Слайд \arabic{slidescount}/\total{slidescount}: #1]}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% TEXT FORMAT
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\geometry{a4paper,top=2cm,bottom=2cm,left=2.5cm,right=2.5cm,bindingoffset=0cm}
\linespread{1.3}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% BODY
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{
  Презентация работы на тему <<Применение анализа указателей и синонимов
  для оптимизации многопоточных программ>>
}
\author{
  Владимир Парфиненко
}

\begin{document}
  {\Large Текст презентации для МНСК, 10 минут.}

  Git date: \GitDate.
  \medskip\hrule

  \paragraph{Кто я.}
  \slide{титульный с названием и фамилиями моей и научрука}
  Здравствуйте, меня зовут Владимир Парфиненко и тема моей работы
  <<Применение анализа указателей и синонимов для оптимизации многопоточных
  программ>>.

  \paragraph{Что такое анализ синонимов и указателей.}
  \slide{анализ синонимов и... указателей (с английскими названиями)}
  В моей работе рассматривается анализ синонимов, который предоставляет
  информацию о том, могут ли два выражения ссылочного типа быть синонимами, то
  есть ссылаться на один и тот же объект в памяти. Анализ синонимов тесно
  связан с анализом указателей, который предоставляет более общую информацию:
  множество всех объектов, на которые может ссылаться выражение.

  \paragraph{Постановка задачи.}
  \slide{цель и задачи}
  Теперь, зная основную терминологию, мы можем сформулировать цель данной
  работы: разработка алгоритма анализа указателей и синонимов для языка \java,
  учитывающего особенности языка и его модели памяти. Для этого необходимо
  было изучить существующие алгоритмы анализа, сравнить их точность, эффективность и
  разработать усовершенствованный алгоритм, выбрав за основу один из
  существующих. Особое внимание требуется уделить способу выражения неявных
  зависимостей по данным между операциями работающими с памятью, также очень
  важно согласовать этот способ с моделью памяти языка \java.

  \paragraph{Предыдущая работа.}
  В рамках предыдущей работы на соискание степени бакалавра, мною уже был
  разработан алгоритм анализа указателей для языка \java. Он основывался на
  алгоритме Андерсена, являлся внутрипроцедурным,
  нечувствительным к потоку управления и использовал типовый анализ.
  \slide{пример с отсутствием чувствительности к потоку}
  Однако этот алгоритм при анализе многих программ вел себя через
  чур консервативно, не смотря на предпринятые улучшения. Это было связано
  во-первых с отсутсвием чувствительности к потоку управления. В данном примере
  легко увидеть, что $a$ и $b$ ссылаются на заведомо разные объекты и не могут
  быть синонимами. Однако разработанный алгоритм получал консервативный
  результат, что $a$ и $b$ синонимы, так как их значения получаются из одного и
  того же поля $f$ переменной $x$.

  \paragraph{Проблемы нучувствительного к потоку алгоритма.}
  Так как проведение чувствительного к потоку управления анализа до сих пор
  является неприемлимым в промышленном компиляторе из-за временной/емкостной
  сложности, необходимо было придумать другой способ решения этой проблемы.
  \slide{сравнение видения программы чувствительным и нечувствительным к потоку
  анализом}
  Довольно быстро стало понятно, что проблема не столько в самом алгоритме
  анализа, сколько в нехватке информации во внутреннем представлении, так как
  нечуствительный к потоку управления анализ работает с программой как с
  неупорядоченным множеством операций, и две операции чтения поля $f$
  переменной $x$ для такого анализа абсолютно идентичны и никак не зависят от
  операций записи в поле.

  \paragraph{\M"=переменная.}
  \slide{пример программы с \M"=переменной}
  Описанную проблему удалось решить с помощью введения в программу специальной
  переменной, \M"=переменной \engdef{memory}, олицетворяющей образ всей памяти.
  Таким образом все операции читающие память должны иметь своим аргументом
  \M"=переменную, а операции модифицирующие память должны порождать
  \M"=переменную.
  Заметим, что на ряду с обычными переменными \M"=переменная версионируется при
  переводе в SSA-форму.
  Эта переменная дает необходимые явные зависимости между операциями
  чтения/записи полей: видно, что два чтения поля в строке 1 и 8 не идентичны,
  они работают с разными версиями \M"=переменной, и алгоритм анализа может
  получить более точные результаты о синонимичности переменных $u$ и $v$.

  \paragraph{Операции языка \java}
  \slide{примитивные операции}
  С помощью небольшого набора примитивных операций, работающих с
  \M"=переменной, можно представить все операции языка \java, работающие с
  переменными ссылочного типа и памятью, при этом сохранив всю информацию,
  необходимую для проведения анализа указателей, и выражения свойств модели
  памяти языка \java.
  Получаем две группы операций, одни модифицируют память и не возвращают
  значений, а другие не модифицируют память и возвращают значение.

  \paragraph{Алгоритм анализа: абстрактные объекты.}
  Теперь можно описать работу разработанного алгоритма анализа
  указателей.
  \slide{абстрактные объекты}
  Изначально строится множество абстрактных объектов, соответствующих различным
  объектам при исполнении программы. Источниками таких объектов являются
  операции $new$. Отдельно выделяется специальный объект $global$,
  соответствующий всем разделяемым объектам, на который могут указывать
  формальные параметры метода и статические поля классов.
  (На слайде черта сверху означает множество целей переменной.)

  \paragraph{Алгоритм анализа: граф операций.}
  \slide{пример графа операций}
  Затем строится вспомогательное внутреннее представление, представляющее из
  себя ориентированный граф, у которого в узлах находятся операции, работающие
  с \M"=переменной, а дугам соответствуют явно выраженные зависимости по данным
  и памяти.
  На слайде приведен пример программы и соответствующего графа.
  Каждый узел, содержащий операцию, возвращающую значение ссылочного типа,
  также хранит множество абстрактных объектов, на которые это значение может
  указывать.
  А каждый узел, содержащий операцию, порождающую \M"=переменную, хранит
  множество целей полей всех абстрактных объектов, множество целей всех
  статических полей и множество разделяемых абстрактных объектов. Поля
  разделяемых объектов обладают тем свойством, что их значения могут изменяться
  извне анализируемого метода.

  \paragraph{Алгоритм анализа: потоковый анализ.}
  \slide{суммарный алгоритм анализа}
  Затем алгоритм проводит потоковый анализ над этим графом: имея изначально
  пустые множества целей переменных ссылочного типа, проводятся итерации по
  множеству операций, во время которых каждая операция интерпретируется в
  соответствии с ее семантикой, расширяя множества объектов.
  Таким образом получается полурешетка свойств с монотонными потоковыми
  функциями, что гарантирует сходимость и корректность алгоритма.
  В результате алгоритм предоставляет информацию о множестве целей каждого
  выражения ссылочного типа, что достаточно для проверки синонимичности.

  \paragraph{Модель памяти.}
  Однако необходимо помнить, что в общем случае любая программа на языка \java
  является многопоточной, и при анализе отдельного методы необходимо учитывать
  возможное влияние других потоков программы, что в худшем случае может
  приводить к сильному огрублению результатов анализа.

  Решить эту проблему помогает модель памяти \java.
  Модель памяти для многопоточной системы определяет в каком
  порядке могут происходить доступы к памяти в программе и, как следствие,
  какие значения может возвращать конкретное чтение памяти.
  В случае виртуальной машины \java модель памяти задает, когда значения полей
  объектов могут храниться в локальной памяти, что исключает влияние других
  потоков и позволяет уточнить алгоритм анализа. И соответственно модель памяти
  задает, когда значения полей объектов обязаны быть перечитаны из разделяемой
  памяти, что алгоритм обязан учитывать, чтобы оставаться корректным.
  На слайде приведены два примера, в одном из которых алгоритм анализа может
  локально хранить поле, а в другом нет.

  \paragraph{Реализация.}
  Разработанный алгоритм анализа реализован в статическом компиляторе языка
  \java в рамках проекта \eng{Excelsior RVM}.
  Благодаря реализации данного анализа, стало возможным реализовать несколько
  важных оптимизаций.

  \slide{пример}
  Во-первых, данных анализ позволяет определять, можно ли поменять местами две
  операции работающие с памятью~--- это можно сделать только тогда, когда эти
  операцию работают с заведомо разными участками памяти, то есть
  несинонимичными значениями ссылочного типа. Стало возможным реализовать
  оптимизацию удаления чтений поля объекта и их замену на аргумент
  предшествующей записи в это поле.

  \slide{пример}
  Во-вторых, замечу, что разработанный алгоритм анализа активно использует
  и вычисляет информацию о том, могут ли значения ссылочного типа <<утекать>>
  из анализируемого метода, то есть становиться доступными извне метода.
  Поэтому стало возможным реализовать две оптимизации: взрыв объектов, когда
  создание объекта заменяется на набор локальных переменных, и стековую
  аллокацию, выделение памяти под создаваемый объект на стеке.

  \paragraph{Заключение.}
  \slide{что сделано}
  В ходе работы был проведен анализ существующих алгоритмов анализа указателей,
  разработана схема явного выражения зависимостей по памяти. Эта схема была
  применена для существенного повышения точности алгоритма анализа, что также
  позволило точнее отобразить семантику модели памяти языка \java. Алгоритм
  анализа был реализован в рамках проекта \eng{Excelsior~RVM}.

  \paragraph{Дальнейшая работа.}
  \slide{что планируется сделать}
  В дальнейшем планируется внедрить разработанный алгоритм в промышленный
  статический \java компилятор \eng{Excelsior JET}, и адаптировать алгоритм для
  межпроцедурного анализа.

  \paragraph{Конец.}
  \slide{спасибо за внимание}
  Спасибо за внимание, я готов ответить на ваши вопросы.

\end{document}
